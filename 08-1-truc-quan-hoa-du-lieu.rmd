---
output:
  pdf_document: default
  html_document: default
---
```{r, warning = FALSE, echo = FALSE}
library(readxl)
library(knitr)
library(kableExtra)
library(ggplot2)
library(forcats)
library(grid)
library(gridExtra)
library(forcats)
library(pryr)
library(tibble)
library(dplyr)
library(dslabs)
library(lubridate)
library(tidyr)
library(ggthemes)
library(ggrepel)
library(wesanderson)
library(RColorBrewer)
library(plotly)
library(ggiraph)
library(tidyverse)
library(gganimate)
library(gifski)

```


# Trực quan hóa dữ liệu

Trực quan hóa dữ liệu là nghệ thuật mô tả dữ liệu thông qua việc sử dụng đồ họa và hình ảnh như các biểu đồ, sơ đồ, hình vẽ, bao gồm cả hình ảnh động hoặc hình ảnh tương tác. Đây là phương pháp truyền đạt thông tin một cách trực quan và dễ hiểu từ người quản lý dữ liệu đến người tiếp nhận. Trực quan hóa giúp mô tả một cách hiệu quả các mối quan hệ dữ liệu phức tạp, các thông tin chuyên sâu, và các vấn đề bất thường ẩn chứa trong dữ liệu.

Tại sao lại cần trực quan hóa dữ liệu ? Thứ nhất là do não bộ của con người sẽ cho phản ứng đối với hình ảnh, màu sắc, kích thước, hay khoảng cách, tốt hơn nhiều so với các ký hiệu, chuỗi ký tự, hay các con số. Thứ hai là do dữ liệu đang ngày càng trở nên lớn hơn và phức tạp hơn. Trực quan hóa là phương pháp hiệu quả nhất để tìm ra các giá trị ẩn chứa bên trong dữ liệu. Đây chính là nguyên nhân khiến kỹ năng trực quan hóa dữ liệu được đánh giá là kỹ năng quan trọng nhất đối với những người phân tích dữ liệu.

Có nhiều công cụ để trực quan hóa dữ liệu một cách chuyên nghiệp. Tiêu biểu phải kể đến hai công cụ quen thuộc là Power BI và Tableau. Đây là hai công cụ thân thiện với người dùng, cho phép người dùng tạo bảng điều khiển và báo cáo tương tác một cách nhanh chóng và dễ dàng. Cả hai đều có giao diện kiểu kéo và thả con trỏ giúp dễ dàng tạo hình ảnh trực quan mà không cần bất kỳ kỹ năng lập trình nào.

Khác với Power BI hay Tableau, R sử dụng thư viện $\textbf{ggplot2}$ để trực quan hóa dữ liệu. Sẽ là không dễ dàng cho người mới bắt đầu vẽ được đồ thị bằng các câu lệnh của $\textbf{ggplot2}$. Điểm mạnh của thư viện $\textbf{ggplot2}$ so với các công cụ như Power BI hay Tableau là cho phép người dùng tạo các hình ảnh có khả năng tùy biến cao. $\textbf{ggplot2}$ là lựa chọn phù hợp dành cho các nhà phân tích dữ liệu, những người cảm thấy hứng thú với việc viết các câu lệnh để tạo ra các hình ảnh trực quan phức tạp, và quan trọng nhất là đúng theo ý muốn của mình. Với một chút kinh nghiệm về Power BI và Tableau, cùng với nhiều hơn một chút kinh nghiệm về $\textbf{ggplot2}$, chúng tôi cho rằng bạn đọc nên làm quen với cả hai cách trực quan hóa dữ liệu. Khi bạn phải tạo các báo cáo trực quan trong một thời gian ngắn, Power BI hay Tableau sẽ là lựa chọn tối ưu. Khi bạn muốn vẽ những hình ảnh phức tạp, có tính cá nhân cao, và bạn có thời gian để làm việc đó, hãy sử dụng R và thư viện $\textbf{ggplot2}$.

## Tổng quan về $\textbf{ggplot2}$ {#ggplot_intro}

Như chúng tôi đã giới thiệu, $\textbf{ggplot2}$ là một thư viện để trực quan hóa dữ liệu trong R. Ngoài $\textbf{ggplot2}$, bạn đọc cũng có thể sử dụng các đồ thị cơ bản của R, hoặc sử dụng các thư viện khác như $\textbf{lattice}$ để vẽ đồ thị. Tuy nhiên, không giống như hầu hết các công cụ khác, $\textbf{ggplot2}$ trực quan hóa dữ liệu dựa trên Ngữ pháp của đồ thị (Wilkinson 2005). Hai chữ $\textbf{gg}$ bắt đầu có nghĩa là "Grammar of Graphic" hay Ngữ pháp của đồ thị. Ngữ pháp cho phép bạn đọc vẽ đồ thị bằng cách kết hợp các cấu phần độc lập lại với nhau. Đây chính là điểm mạnh của $\textbf{ggplot2}$. Thay vì bị giới hạn ở các bộ đồ thị đã được xác định trước, bạn đọc có thể tạo đồ thị mới phù hợp với mục tiêu của mình. Ý tưởng phải học ngữ pháp để vẽ đồ thị có thể làm cho bạn đọc cảm thấy nản chí, nhưng sự thật là ngữ pháp của $\textbf{ggplot2}$ thực sự dễ học. Chỉ có một số nguyên tắc cốt lõi đơn giản và có rất ít trường hợp đặc biệt. Khi đã thông thạo Ngữ pháp của đồ thị, ngoài tạo ra những đồ thị quen thuộc, bạn đọc còn có thể tạo ra những đồ thị mới hơn, đẹp hơn và mang tính cách riêng. Bạn đọc có thể gặp khó khăn một chút thời gian ban đầu nhưng chúng tôi tin rằng khi đã quen với thư viện $\textbf{ggplot2}$ thì sẽ rất ít bạn đọc muốn quay lại với các công cụ trực quan hóa dữ liệu khác.

Chúng ta hãy thử xem một ví dụ để hình dung về cách thư viện $\textbf{ggplot2}$ trực quan hóa dữ liệu. Chúng ta sẽ bắt đầu với một dữ liệu có tên là $\textbf{murders}$ trong thư viện $\textbf{dslabs}$. Đây là dữ liệu do FBI cung cấp về số vụ sát nhân bằng súng tại các bang của nước Mỹ vào năm 2010. Giả sử bạn muốn du lịch đến Mỹ nhưng bạn lo ngại về việc cho phép sử dụng súng ở quốc gia này và bạn muốn biết ở những bang nào có tỷ lệ số vụ sát nhân bằng súng cao. Chúng ta sẽ bắt đầu bằng việc tìm hiểu thông tin sơ bộ về dữ liệu này. Bạn đọc đã có kiến thức về data.frame, nên bạn đọc cũng đã quen với các câu lệnh giúp tìm hiểu về dữ liệu bằng như `head()`, `str()`, `view()`:

```{r, warning=FALSE, message=FALSE}
library(dslabs)
head(murders)
# str(murders)
# View(murders)
```

Dù dữ liệu chỉ có hơn 51 dòng và 5 cột nhưng thật khó để có thể có được cái nhìn tổng thể về dữ liệu nếu chỉ nhìn vào các bảng, các con số, các véc-tơ kiểu chuỗi ký tự như trên. Nếu thay vì nhìn vào các con số, ký tự, bạn đọc có thể trình bày dữ liệu $\textbf{murders}$ dưới dạng một đồ thị phân tán như Hình \@ref(fig:fgggplot01)

```{r fgggplot01, warning=FALSE, message=FALSE, echo = FALSE, fig.cap = "Đồ thị phân tán mô tả số vụ sát nhân bằng súng tại 51 bang của Mỹ vào năm 2010. Có mối liên hệ cùng chiều giữa dân số của các bang và số vụ sát nhân bằng súng tại mỗi bang."}
murders %>% ggplot(aes(x = population/10^6, y = total, label = abb)) +
  geom_smooth(method = "lm", se = FALSE, linetype = 2, color="grey")+
  geom_point(aes(fill=region), size = 3, shape=21, alpha = 0.8) +
  geom_text_repel(color = "black", size = 3) +
  scale_x_log10() +
  scale_y_log10() +
  scale_fill_brewer(palette = "Dark2",
                    guide = guide_legend(title = "Vùng"))+
  xlab("Dân số của bang (triệu dân)") +
  ylab("Tổng số vụ sát nhân bằng súng") +
  ggtitle("Số vụ sát nhân bằng súng trong năm 2010 tại Mỹ")+
  theme_minimal()+
  theme(legend.position = "top")
```

Chúng tôi đã sử dụng một vài kỹ thuật biến đổi dữ liệu để vẽ đồ thị ở trên:

- Do biến $total$ (tổng số vụ sát nhân) và biến $population$ (dân số của mỗi bang) đều có đuôi dài, nghĩa là có nhiều điểm tập trung ở khu vực trung tâm, và một số ít điểm tập trung ở phía đuôi bên phải, do đó thay vì sử dụng chính xác giá trị của các biến trên đồ thị, các điểm của đồ thị rải điểm sẽ phân bố không đồng đều. Giá trị hiển thị trên đồ thị đã được điều chính lại theo hàm `log()` cơ số 10. Bạn đọc có thể thấy rằng trên trục y khoảng cách từ 10 đến 100 sẽ bằng khoảng cách từ 100 đến 1000.

- Chúng tôi thêm vào một đường thẳng tuyến tính (đường kẻ màu xám đi qua trung tâm) để mô tả mối quan hệ chung giữa hai biến $total$ và $population$. Đây có thể hiểu là đường thẳng mô tả mối quan hệ cùng chiều giữa biến $population$ và biến $total$. Điều này có nghĩa là ở các bang có dân số càng đông thì tổng số vụ sát nhân bằng súng càng cao.

Dựa trên đồ thị rải điểm ở trên, bạn đọc có thể đưa ra được các nhận xét như sau

- Bang nào có dân số càng cao thì số vụ sát nhân bằng súng càng nhiều. 

- Hầu hết các bang nằm phía trên đường trung bình là các bang ở miền Nam.

- Các vùng còn lại không có sự phân biệt rõ ràng về tỷ lệ số vụ sát nhân bằng súng.

- Bang "District of Columbia" là bang nằm cao hơn hẳn so với đường trung bình, và cũng là bang có tỷ lệ số vụ sát nhân bằng súng cao nhất.

- Bang California có tổng số vụ sát nhân bằng súng lớn nhất, nhưng tỷ lệ số vụ sát nhân bằng súng trên đầu người chỉ bằng mức trung bình chung.

Không dễ dàng để đưa ra được các nhận xét như trên nếu chỉ dựa trên quan sát con số và dữ liệu. Thay vào đó chúng ta có thể đưa ra nhiều phân tích có ý nghĩa về dữ liệu khi sử dụng đồ thị như trên.

Wilkinson (2005) giới thiệu khái niệm Ngữ pháp đồ thị để mô tả các thành phần cơ bản làm nền tảng cho tất cả các đồ thị sử dụng và cách các thành phần tương tác trong mô tả dữ liệu. Ngữ pháp đồ thị là mô tả chính xác nhất cho câu hỏi đồ thị trực quan hóa dữ liệu là gì? Thư viện $\textbf{ggplot2}$ được Wickham giới thiệu vào 2009 và xây dựng dựa trên Ngữ pháp đồ thị mà Wilkinson đã đề cập bằng cách tập trung vào việc xây dựng các đồ thị trực quan dựa trên nhiều lớp (layer). Nhìn chung, ngữ pháp đồ thị cho chúng ta biết quy tắc cho tương ứng các biến của dữ liệu đến các thuộc tính thẩm mỹ (các aesthetic attributions) của đối tượng hình ảnh xuất hiện (các geometries). Đồ thị được vẽ bằng thư viện $\textbf{ggplot2}$ cũng có thể bao gồm các mô hình thống kê của dữ liệu và hệ tọa độ mà đồ thị sử dụng. Bạn đọc cũng có thể chia dữ liệu thành các tập hợp con dựa trên các biến rời rạc và mô tả dữ liệu thông qua một nhóm các đồ thị con thông qua kỹ thuật facetting. Sự kết hợp của các thành phần độc lập kể trên tạo nên một đồ thị mô tả dữ liệu.

Bạn đọc không cần phải lo lắng nếu khái niệm Ngữ pháp đồ thị chúng tôi vừa giải thích ở trên không có ý nghĩa ngay lập tức. Trong phần sau của cuốn sách, chúng tôi sẽ nói về ngữ pháp đồ thị một cách chi tiết hơn. Bạn sẽ có nhiều cơ hội hơn để tìm hiểu về Ngữ pháp và các sử dụng ngữ pháp để các cấu phần độc lập của một đồ thị hoạt động cùng nhau. Trong phần giới thiệu này, chúng tôi muốn bạn đọc hãy ghi nhớ $\textbf{bảy}$ thành phần độc lập tạo nên một đồ thị cơ bản trong thư viện $\textbf{ggplot2}$:

1. Dữ liệu ($Data$) là dữ liệu hay tập hợp các dữ liệu mà bạn đọc muốn trực quan hóa. Thông thường thì chỉ có một dữ liệu chính mà bạn đọc muốn minh họa cho người tiếp nhận dữ liệu, trong khi các dữ liệu khác được sử dụng với mục đích để mô tả và minh họa cho dữ liệu chính. Một ví dụ điển hình của dữ liệu phụ là dữ liệu kiểu bản đồ. Chẳng hạn như khi bạn đọc muốn mô tả về dữ liệu $\textbf{murders}$ ở trên, bạn đọc có thể sử dụng dữ liệu về bản đồ nước Mỹ để có mô tả tốt hơn.

2. Hình dạng đồ họa (được gọi là các $geometries$ hay viết tắt là các $geoms$) là những hình dạng đồ họa mà chúng ta muốn nhìn thấy trên đồ thị. Các hình dạng này có thể là các điểm, các thanh, các đường.

3. Các ánh xạ thẩm mỹ (được gọi là $Aesthetic$ $mapping$) là các quy tắc cho tương ứng từ các biến (cột của dữ liệu) đến các thuộc tính thẩm mỹ (aesthetic attribution) của các hình dạng đồ họa. Các thuộc tính thẩm mỹ có thể là hình dạng, màu sắc, độ đậm nhạt, ...

4. Các mô hình hay biến đổi thống kê (các $statistics$ hay viết tắt là $stats$) là các quy tắc tóm tắt dữ liệu, các mô hình xây dựng trên dữ liệu được mô tả dưới dạng một hình dạng đồ họa nhằm tăng tính dễ hiểu cho đồ thị hoặc làm nổi bật một xu thế nào đó. Ví dụ như trong đồ thị phân tán mô tả dữ liệu $\textbf{murders}$, chúng tôi đã sử dụng một mô hình tuyến tính mô tả mối quan hệ giữa biến $total$ và biến $population$ với mục đích phân loại ra các bang có tỷ lệ số vụ sát nhân bằng súng thấp hơn trung bình và các bang có tỷ lệ số vụ sát nhân bằng súng cao hơn so với mức trung bình.

5. Hệ tọa độ ($Cordinate$) mô tả cách dữ liệu được trực quan hóa trên mặt phẳng của đồ họa. Đa số các trường hợp chúng ta sẽ sử dụng hệ tọa độ Descartes, nhưng cũng có một số hệ tọa độ khác có thể sử dụng bao gồm tọa độ cực và bản đồ.

6. Một thành phần mô tả cách dữ liệu được hiển thị là chia nhỏ dữ liệu để mô tả bằng một nhóm các đồ thị thay vì một đồ thị duy nhất được gọi là $facetting$. Thành phần này thường được sử dụng để mô tả dữ liệu có kích thước lớn và hoặc chúng ta muốn so sánh trực quan dữ liệu ở các nhóm khác nhau.

7. Thành phần cuối cùng của đồ thị là ngữ cảnh của đồ thị, còn được gọi là các $themes$. Theme quy định khung hoặc nền mà đồ thị được hiển thị chẳng hạn như kích thước phông chữ hoặc màu nền. Mặc dù các giá trị mặc định trong thư viện $\textbf{ggplot2}$ đã được lựa chọn hợp lý nhưng bạn đọc cũng có thể cần tham khảo các tài liệu tham khảo khác để tạo ra một ngữ cảnh phù hợp hơn cho đồ thị của mình.

Mỗi khi vẽ một đồ thị sử dụng $\textbf{ggplot2}$, bạn đọc cần tự định nghĩa ít nhất ba thành phần: 1. Dữ liệu; 2. Các hình dạng đồ họa; và 3. Các ánh xạ thẩm mỹ. Các thành phần 5. Hệ tọa độ; và 7. Ngữ cảnh; sẽ được tự động gán cho các giá trị mặc định nếu bạn đọc không quy định trong câu lệnh. Và các thành phần 4. Mô hình; và 6. Facetting; chỉ xuất hiện khi bạn đọc gọi lên trong câu lệnh của mình. 

Trước khi đi vào giới thiệu chi tiết các cách tạo nên một đồ thị trực quan hóa, bạn đọc cũng cần biết được các hạn chế khi trực quan hóa dữ liệu bằng $\textbf{ggplot2}$:

- $\textbf{ggplot2}$ là một thư viện của R nên bạn đọc cần có kỹ năng viết câu lệnh R tương đối thành thạo.

- Thư viện $\textbf{ggplot2}$ không gợi ý bạn đọc nên sử dụng đồ thị nào khi gặp một dữ liệu cụ thể. Điều đó cũng có nghĩa là bạn đọc cần có một chút kinh nghiệm về trực quan hóa dữ liệu trước khi sử dụng thư viện này.

- Thư viện $ggplot2$ không được phát triển để vẽ các đồ thị động hay đồ thị tương tác mà chỉ tập trung vào vẽ các đồ thị tĩnh. Muốn vẽ các đồ thị tương tác hay đồ thị động, bạn đọc phải sử dụng các thư viện đi kèm như $\textbf{gganimate}$ hay $\textbf{ggplotly}$. 

Để kết thúc phần giới thiệu, chúng tôi sẽ sử dụng thư viện $\textbf{ggplot2}$ kết hợp với thư viện vẽ hình ảnh động $\textbf{gganimate}$ để kể một câu chuyện về sự phát triển về sự tiến bộ y tế của các quốc gia trên thế giới từ năm 1960 đến năm 2010 thông qua hai khía cạnh là tuổi thọ trung bình và tỷ lệ tử . Dữ liệu chính được sử dụng là dữ liệu $\textbf{gapminder}$ trong thư viện $\textbf{dslabs}$ mà bạn đọc đã làm quen trong phần phân tích dữ liệu. Sự thay đổi của tuối thọ trung bình và thu nhập bình quân đầu người của các quốc gia được mô tả lại một cách sinh động qua Hình \@ref(fig:fgggplot02)

```{r, warning=FALSE, message=FALSE, echo = FALSE}
library(imputeTS)
dat<-gapminder
list_country<-unique(dat$country)
for (ct in list_country){
  ind<-(dat$country == ct)
  if (sum(!is.na(dat$infant_mortality[ind]))>=2){
    dat$infant_mortality[ind] <- na.interpolation(dat$infant_mortality[ind])
  }
}
dat$continent<-as.character(dat$continent)
dat$continent[dat$continent == "Africa"]<-"Châu Phi"
dat$continent[dat$continent == "Asia"]<-"Châu Á"
dat$continent[dat$continent == "Europe"]<-"Châu Âu"
dat$continent[dat$continent == "Americas"]<-"Châu Mỹ"
dat$continent[dat$continent == "Oceania"]<-"Châu Đại Dương"
dat$continent<-as.factor(dat$continent)

Visual_Na<-function(df,variable){
  # Tìm chỉ số của biến variable
  ind<-names(df)==variable
  
  # Tính tỷ lệ NA của từng biến theo từng nhóm
  # Nhóm đươc xác định theo giá trị của variable
  df1<-df%>%group_by(df[,ind])%>%
    group_modify(~summarize(.x, across(everything(), function(x) sum(is.na(x))/length(x) ))) %>%
    as.data.frame()%>%gather(variables,na_rate,-1)
  
  # Đặt lại tên biến nhóm theo
  names(df1)[1]<-"variable"
  
  # Biểu diễn đồ thị
  p<-df1%>%ggplot(aes(x = variable, y = variables, fill = na_rate))+
    geom_tile(color = "grey", height = 1, width = 1)+
    scale_fill_gradient(low="white", high = "orange",
                        labels = scales::label_percent())+
    theme_minimal()+ylab("")+xlab("")
  return(p)
}

```

```{r fgggplot02, warning = FALSE, message = FALSE, echo = FALSE, fig.cap = "Sự thay đổi trong tỷ lệ tử vong trẻ sơ sinh, tính trên 1000 trẻ, và tuổi thọ trung bình của cá quốc gia trên thế giới từ năm 1960 đến năm 2010"}

  k<-1.4
  p<-dat%>%
    # FIX DU LIEU
    filter(year<=2011)%>%
    # AESTHETIC MAPPING
    ggplot(aes(y=life_expectancy,x=infant_mortality,size = population, fill= continent))+
    # TAO DO THI SCATTERPLOT
    geom_point(shape=21, alpha = 0.6)+
    # THAY DOI TITLE CUA DO THI, TRUC X, TRUC Y
    labs(title = 'Năm: {as.integer(frame_time)}',
         y = "Tuổi thọ trung bình",
         x = "Tỷ lệ tử vong trên 1000 trẻ sơ sinh")+
    #GIOI HAN LAI GIA TRI TREN X,Y
    
    #xlim(0,10)+ylim(20,90)+
    # SCALE LAI SIZE (POPULATION)
    scale_size(range = c(1, 25)) +
    # SCALE LAI MAU SAC THE0 DAI MAU "SET1" CUA BREWER
    scale_fill_brewer(palette = "Set1")+
    # LAM TITLE THAY DOI THEO NAM
    transition_time(year)+
    
    # theme
    theme_minimal()+
    guides(fill = guide_legend(override.aes = list(size=5)))+
    #SIZE & FONT CHU
    theme(plot.title = element_text(size = 10*k),
          axis.title.x = element_text(size = 10*k),
          axis.title.y = element_text(size = 10*k),
          axis.text.x = element_text(size = 10*k),
          axis.text.y = element_text(size = 10*k),
          legend.text = element_text(size = 10*k,
                                     margin = margin(r = 10*k, unit = "pt")),
          legend.title = element_text(size = 10*k),
          #    legend.text=element_text(size=20*2),
    )
  #legend.key.size = element_rect(size = rel(1.5)),
  
  # TAO DO THI DANG DONG
  animate(p, renderer = gifski_renderer())

```

Dựa trên đồ thị ở trên, bạn đọc hãy quan sát và trả lời các câu hỏi dưới đây:

1. Xu hướng di chuyển chung của các điểm dữ liệu là như thế nào ? Điều này cho biết tỷ lệ tử vong của trẻ sơ sinh và tuổi thọ bình quân của các quốc gia trên thế giới từ năm 1960 đến năm 2010 thay đổi như thế nào ? Điều này cho thấy việc phát triển về y tế nhìn chung là như thế nào ?

2. Trong xu thế phát triển chung đó, sự khác biệt của các Châu lục là như thế nào ?

3. Kích thước của các điểm trong đồ thị phân tán cho biết dân số quốc gia đó, bạn có nhận thấy sự thay đổi của kích thước của các điểm theo thời gian là như thế nào không ? Bạn có nhận ra các quốc gia đông dân như Trung Quốc, Ấn Độ, Mỹ, Nhật Bản từ đồ thị trên hay không ?

4. Một vài quốc gia Châu Phi có quỹ đạo di chuyển bất thường khi điểm dữ liệu bị "rơi" xuống theo trục $y$ trong một vài năm, theo bạn đó là do nguyên nhân gì ?

## Tạo một đồ thị cơ bản
Trước khi giới thiệu chi tiết về các thành phần độc lập của đồ thị và cách sử dụng ngữ pháp của đồ thị, chúng tôi nghĩ rằng sẽ tốt hơn nếu bạn đọc bắt đầu vẽ các đồ thị đơn giản bằng cách sao chép và dán các câu lệnh vẽ đồ thị. Sau khi thực thi một vài lần, bạn đọc sẽ có cảm nhận được phần nào cách mà một đồ thị của thư viện $\textbf{ggplot2}$ được xây dựng. Dữ liệu chúng tôi sử dụng để trực quan hóa trong suốt chương sách này là dữ liệu $\textbf{gapminder}$, dữ liệu về sức khỏe và thu nhập của tất cả các quốc gia trên thế giới bắt đầu từ năm 1960 đến năm 2016. Trong phần giới thiệu chúng ta đã làm quen với dữ liệu này. Hình \@ref(fig:fgggplot03) mô tả tỷ lệ biến không dữ liệu không quan sát được của các biến qua các năm

```{r fgggplot03, warning=FALSE, message=FALSE, echo = FALSE, fig.cap = "Tỷ lệ giá trị không quan sát được của các biến trong dữ liệu gapminder theo năm bắt đầu từ 1960 đến 2016", fig.height=3}
Visual_Na(gapminder,"year")
```

Bạn đọc có thể thấy rằng dữ liệu $gapminder$ có nhiều giá trị không quan sát được trong năm 2016. Hai cột có tỷ lệ không quan sát được qua các năm lớn là $infant\_mortality$ và $gdp$. Riêng biến $gdp$ là gần như không quan sát được từ năm 2012 đến 2016. Do chỉ sử dụng dữ liệu với mục đích trực quan hóa nên chúng tôi sẽ xử lý dữ liệu một cách đơn giản là xóa các quan sát của các năm 2012 đến 2016. Giá trị không quan sát được từ năm 1960 đến 2011 sẽ được thay thế bằng cách nội suy tuyến tính theo chuỗi thời gian. Thư viện để nội suy tuyến tính các giá trị không quan sát được theo chuỗi thời gian là thư viện $\textbf{imputeTS}$.

```{r, warning=FALSE, message=FALSE}
library(imputeTS) # Thư viện dùng để nội suy tuyến tính
mydat<-gapminder%>%filter(year<=2011)
list_country<-unique(mydat$country)
for (ct in list_country){
  ind<-(mydat$country == ct)
  if (sum(!is.na(mydat$infant_mortality[ind]))>=2){
    mydat$infant_mortality[ind]<-na.interpolation(mydat$infant_mortality[ind])
  }
  if (sum(!is.na(mydat$gdp[ind]))>=2){
    mydat$gdp[ind] <- na.interpolation(mydat$gdp[ind])
  }
}
```

Hàm số sử dụng vẽ đồ thị thư viện $\textbf{ggplot2}$ là hàm `ggplot()`. Ba thành phần bắt buộc phải có của một đồ thị là 1. Dữ liệu; 2. Ít nhất một hình dạng đồ họa; và 3. Ánh xạ thẩm mỹ. Đồ thị dưới đây mô tả hai biến gdp bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới vào năm 2011. Bạn đọc có thể sao chép các câu lệnh ở dưới vào cửa sổ Script và thực thi giống như các câu lệnh thông thường
```{r fgggplot04, warning=FALSE, message=FALSE, fig.cap = "Thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới năm 2011"}
# Biến đổi dữ liệu
dat<-mydat%>%filter(year==2011)%>%
  mutate(gdp_per_capita = gdp/population)

# Trực quan hóa
ggplot(dat, aes(x = life_expectancy, y = gdp_per_capita)) +
  geom_point()
```

Trong câu lệnh `ggplot()` ở trên, dữ liệu được đưa vào là $\textbf{dat}$ - dữ liệu được biến đổi từ dữ liệu $\textbf{gapminder}$ sau khi thêm cột thu nhâp bình quân đầu người và lọc theo năm 2011. Hình dạng đồ họa là các điểm trên trục tọa độ Descartes. Hình dạng đồ họa này được gọi bằng hàm `geom_point()`. Ánh xạ thẩm mỹ được khai báo thông qua hàm `aes()` nằm trong hàm `ggplot()`. Trong ánh xạ thẩm mỹ ở trên, chúng ta đã cho tương ứng (ánh xạ) biến $life\_expectancy$ với giá trị trên trục $x$ của các điểm và biến $gdp\_per\_capita$ tương ứng (ánh xạ) với giá trị trên trục $y$ của các điểm.

Mặc dù đồ thị trên Hình \@ref(fig:fgggplot04) còn đơn giản, nhưng chúng ta đã có thể nhận thấy được một vài thông tin về thu nhập bin

- Có mối liên hệ đồng biến giữa tuổi thọ trung bình và thu nhập bình quân đầu người. Quốc gia nào có thu nhập bình quân đầu người cao thì tuổi thọ trung bình cũng sẽ cao. Điều này khá hợp lý bởi các quốc gia có thu nhập trung bình cao thường là các nước phát triển có hệ thống chăm sóc sức khỏe tốt, do đó tuổi thọ trung bình cũng sẽ cao.

- Mối liên hệ đồng biến nhưng không tuyến tính, thu nhập bình quân đầu người tăng nhanh hơn rất nhiều ro với tuổi thọ trung bình.

- Có một vài điểm có khả năng là ngoại lai trong mối liên hệ tuyến tính này. Đây là các quốc gia có mức thu nhập bình quân khá cao (từ 10 nghìn USD - 20 nghìn USD/1 người) nhưng lại có tuổi thọ trung bình không cao. Tuy nhiên chỉ với các thông tin như trên chúng ta không thể đưa ra giải thích cho các giá trị này.

Hình dạng đồ họa là những hình dạng cụ thể mà bạn đọc nhìn thấy trên đồ thị, chẳng hạn như các điểm, các đường, thanh, hay các khối hình khác. Khi gọi các hình dạng đồ họa, thư viện $\textbf{ggplot2}$ luôn luôn sử dụng các hàm số bắt đầu bởi `geom` - viết tắt của geometries. Bạn đọc có thể thử các câu lệnh để vẽ các khối hình khác như dưới đây:
```{r, warning=FALSE, message=FALSE, eval = FALSE}
## geom_histogram() sử dụng các thanh 
## mô tả phân phối của một biến liên tục
ggplot(dat,aes(x = gdp_per_capita))+
  geom_histogram()

## geom_bar() sử dụng các thanh 
## mô tả phân phối của một biến rời rạc
ggplot(dat,aes(x = continent))+
  geom_bar()

## geom_boxplot() sử dụng các hình hộp 
## mô tả phân phối của biến liên tục
ggplot(dat,aes(x = continent, y = life_expectancy))+
  geom_boxplot()

## geom_line() sử dụng đường nối các điểm 
## mô tả các điểm theo thứ tự xuất hiện
dat1<-filter(gapminder, year<=2011, country == "United States")%>%
  select(year,gdp)
ggplot(dat1,aes(x = year, y = gdp))+
  geom_line()
```

Còn nhiều hàm `geom_*()` khác có thể được sử dụng để trực quan hóa dữ liệu từ thư viện $\textbf{ggplot2}$. Bạn đọc có thể tham khảo danh sách các geom thường sử dụng trong link dưới đây.

https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf

Bạn đọc có thể thấy rằng trong danh sách các geom có thể sử dụng bao gồm gợi ý cho người sử dụng nên dùng hàm `geom_*()` nào trong từng trường hợp. Chẳng hạn như `geom_point()` được gợi ý khi mô tả hai biến liên tục. Hoặc `geom_boxplot()` được gợi ý khi mô tả một biến liên tục và một biến rời rạc. Ngoài ra, mỗi hàm `geom_*()` sẽ có một danh sách các thuộc tính thẩm mỹ đi kèm. Ví dụ, khi sử dụng `geom_point()` sẽ có các thuộc tính thẩm mỹ bao gồm `x`, `y`, `alpha`, `color`, `fill`, `shape`, `size`, và `stroke`. Chúng ta có thể tham khảo hướng dẫn sử dụng của hàm `geom_point()` để biết các thuộc tính thẩm mỹ này có ý nghĩa như thế nào. Trong các thuộc tính thẩm mỹ được sử dụng với `geom_point()`, các thuộc tính thẩm mỹ `color`, `fill`, `shape`, và `size` là các thuộc tính thẩm mỹ xuất hiện ở nhiều hàm `geom_*()` khác. Đây là các thuộc tính thẩm mỹ thường xuyên được sử dụng để tăng khả năng mô tả dữ liệu của các đồ thị $\textbf{ggplot2}$.

Chúng ta tiếp tục với ví dụ về mô tả trực quan mối liên hệ giữa thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới năm 2011. Để đồ thị giải thích tốt hơn, chúng ta cần thêm thông tin vào đồ thị trong Hình \@ref(fig:fgggplot04). Một phương pháp đơn giản để thêm biến khác vào một đồ thị là ánh xạ biến đó đến một trong các thuộc tính thẩm mỹ của đồ thị được vẽ bởi hàm `geom_point()`. Biến được thêm vào đồ thị trong Hình \@ref(fig:fgggplot05) là biến $continent$. Chúng ta sẽ ánh xạ biến này đến thuộc tính thẩm mỹ `color` như sau

```{r fgggplot05, warning=FALSE, message=FALSE, fig.cap="Thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới năm 2011. Biến continent được ánh xạ đến thuộc tính thẩm mỹ màu sắc của các điểm"}
# Vẽ đồ thị phân tán, ánh xạ biến continent đến màu sắc
ggplot(dat, aes(x=life_expectancy, y=gdp_per_capita,
                color=continent))+
  geom_point()
```

Bằng cách thêm biến $continent$ vào đồ thị sử dụng thuộc tính thẩm mỹ màu sắc, chúng ta đã có thể đưa ra thêm các phân tích về mối liên hệ giữa tuổi thọ trung bình và thu nhập bình quân đầu người của các quốc gia trên thế giới vào năm 2011: 

- có sự phân bố không đồng đều về thu nhập bình quân và tuổi thọ trung bình của các quốc gia trên thế giới. Đa số các quốc gia Châu Phi có thu nhập bình quân đầu người thấp và tuổi thọ trung bình thấp trong khi các quốc gia Châu Âu có thu nhập bình quân đầu người cao và tuổi thọ trung bình cao. Có sự phân hóa rõ ràng ở Châu Đại Dương và Châu Mỹ, một vài quốc gia nằm trong nhóm các nước có thu nhập cao, tuổi thọ trung bình cao trong khi đa số các quốc gia còn lại nằm trong nhóm thu nhập thấp và tuổi thọ trung bình thấp. Sự phân hóa ở các nước Châu Á không quá rõ ràng. 

- các nước có mối liên hệ giữa thu nhập bình quân và tuổi thọ trung bình ít giống như các nước khác là các quốc gia ở Châu Phi và Châu Mỹ. 

Có một vài nguyên tắc khi sử dụng các thuộc tính thẩm mỹ là thuộc tính thẩm mỹ `color` thường được sử dụng với biến rời rạc trong khi thuộc tính thẩm mỹ `size` thường được sử dụng với biến liên tục. Thuộc tính thẩm mỹ `shape` chỉ có thể được sử dụng với biến rời rạc, R sẽ báo lỗi nếu bạn ánh xạ một biến liên tục vào thuộc tính thẩm mỹ `shape`. Ngoài ra có 21 giá trị khác nhau cho thuộc tính thẩm mỹ `shape` và R sẽ đưa ra cảnh báo nếu bạn đọc ánh xạ một biến rời rạc có nhiều hơn 21 giá trị vào cấu phần thẩm mỹ này.

Đồ thị dưới đây thêm biến $population$ vào đồ thị bằng cách sử dụng thuộc tính thẩm mỹ `size`. Bạn đọc hãy luôn nhớ rằng khai báo ánh xạ thẩm mỹ từ một biến dữ liệu đến một thuộc tính thẩm mỹ luôn luôn phải thực hiện bên trong hàm `aes()`:

```{r fgggplot06, warning=FALSE, message=FALSE, fig.cap= "Thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới năm 2011. Biến continent ánh xạ đến thuộc tính thẩm mỹ màu sắc của các điểm và biến population ánh xạ đến thuộc tính thẩm mỹ kích thước" }
# Vẽ đồ thị phân tán, ánh xạ biến continent đến màu sắc
# ánh xạ population đến kích thước
ggplot(dat, aes(x = life_expectancy, y = gdp_per_capita, 
                color = continent, size = population)) + 
  geom_point(alpha = 0.5)
```

Tham số `alpha` sử dụng trong hàm `geom_point()` trong trường hợp dữ liệu có nhiều điểm bị trùng lên nhau. `alpha` nhận giá trị từ 0 đến 1 cho biết độ trong suốt của các điểm tăng dần. Cho `alpha` nhận giá trị nhỏ hơn 1 cho phép chúng ta quan sát được tất cả các điểm trên đồ thị phân tán. `alpha` cũng có thể được sử dụng như một thuộc tính thẩm mỹ và chúng ta sẽ thảo luận chi tiết hơn về thuộc tính này trong phần sau của chương sách. 

Bạn đọc có thể thấy rằng khi thêm biến $population$ bằng cách ánh xạ vào thuộc tính kích thước các điểm như Hình \@ref(fig:fgggplot06) giúp cho đồ thị có thêm thông tin: chúng ta có thể nhận ra vị trí của các quốc gia đông dân tiêu biểu như Trung Quốc và Ấn Độ vào năm 2011, có thể nhận thấy hai quốc gia này vẫn nằm trong nhóm các nước có thu nhập bình quân đầu người thấp; hoặc cũng có thể nhận ra Mỹ và Nhật Bản là các quốc gia nằm ở góc trên bên phải là các nước cũng có dân số tương đối lớn so với các quốc gia khác. Tất nhiên, so với thuộc tính thẩm mỹ màu sắc thì thuộc tính thẩm mỹ kích thước không hiệu quả bằng. Ngoài ra, bạn đọc cũng có thể nhận ra rằng khi cùng sử dụng nhiều thuộc tính thẩm mỹ trên một đồ thị, hiệu quả sẽ không được như mong muốn. Chính vì thế, để tạo các đồ thị rõ ràng hơn, đặc biệt với các dữ liệu có nhiều quan sát, bạn đọc có thể chia nhỏ dữ liệu thành các nhóm và mô tả dữ liệu trong mỗi nhóm bằng một đồ thị khác nhau. Kỹ thuật này được gọi là $facetting$ và được mô tả trong Hình \@ref(fig:fgggplot07)

```{r fgggplot07, warning=FALSE, message=FALSE, fig.cap="Chia dữ liệu thành năm nhóm tương ứng với năm lục địa và sử dụng năm đồ thị phân tán để mô tả phân bố của các điểm dữ liệu"}
# Dùng facet_wrap để chia dữ liệu ra thành các nhóm
ggplot(dat, aes(x = life_expectancy, y = gdp_per_capita,
                size = population)) +
  geom_point(alpha = 0.3)+
  facet_wrap(~continent)
```

Có thể nhận thấy rằng sử dụng năm đồ thị phân tán có cùng khoảng giá trị của trục tọa độ $x$ và $y$ để mô tả mối quan hệ giữa thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia thuộc năm châu lục là rõ ràng hơn rất nhiều so với sử dụng một đồ thị duy nhất và phân biệt các lục địa khác nhau bằng màu sắc. 

Một thành phần tuy không bắt buộc nhưng bạn đọc có thể thêm vào đồ thị của $\textbf{ggplot2}$ để tăng tính thẩm mỹ và sự rành mạch là ngữ cảnh hay còn gọi là các $themes$. Có một số $theme$ có sẵn khi chúng ta cài đặt thư viện và cũng có các ngữ cảnh nằm trong các thư viện cài đặt bổ sung như thư viện $\textbf{ggthemes}$. Chúng ta sẽ thảo luận chi tiết về cách tùy chỉnh ngữ cảnh và tự tạo ngữ cảnh cho đồ thị ở phần sau của chương. Để thay đổi ngữ cảnh mặc định của các đồ thị ggplot2, chúng ta sử dụng các hàm `theme_*()`. Ví dụ, trong Hình \@ref(fig:fgggplot08) chúng tôi thay đổi ngữ cảnh mặc định của Hình \@ref(fig:fgggplot07) thành ngữ cảnh khác bằng cách sử dụng hàm `theme_minimal()`:

```{r fgggplot08, warning=FALSE, message=FALSE, fig.cap = "Thay đổi ngữ cảnh mặc định của ggplot sang ngữ cảnh khác giúp đồ thị rõ ràng hơn"}
ggplot(dat, aes(x = life_expectancy, y = gdp_per_capita, size = population)) +
  geom_point(shape = 21, alpha = 0.5, fill = "blue")+
  facet_wrap(~continent, ncol = 2)+
  # thêm title
  labs( title = "Thu nhập bình quân và tuổi thọ trung bình")+
  xlab("Tuổi thọ trung bình (năm)")+
  ylab("Gdp bình quân đầu người (USD)")+
  theme_minimal()# thêm ngữ cảnh
```

Thành phần chưa được nhắc đến khi tạo đồ thị trực quan hóa dữ liệu là các $statistics$ hay các $stats$. Do đây là thành phần phức tạp và liên quan đến các kiến thức về xây dựng mô hình trên dữ liệu nên chúng tôi không đề cập đến trong phần này. Mục tiêu của chúng tôi trong phần giới thiệu là để bạn đọc làm quen với cách sử dụng các câu lệnh vẽ đồ thị trong $\textbf{ggplot2}$. Trong các phần tiếp theo, từng thành phần của đồ thị và các cấu phần thẩm mỹ quan trọng sẽ được thảo luận chi tiết cùng với ngữ pháp của đồ thị.

## Cấu trúc nhiều lớp và ngữ pháp của đồ thị

Cấu trúc theo lớp (layer) của đồ thị $\textbf{ggplot2}$ giúp cho người phân tích dữ liệu xây dựng đồ thị của mình theo một đối tượng có cấu trúc. Đồ thị được tạo thành từ $\textbf{ggplot2}$ từ đơn giản đến phức tạp đều được tạo thành từ (ít nhất) một đến nhiều lớp. Mỗi lớp trong đồ thị có mục tiêu hiển thị khác nhau:

- Mục tiêu hiện thị đầu tiên và cũng là mục tiêu chính, đó là để hiển thị dữ liệu. Luôn luôn có một hoặc một vài lớp chính với mục tiêu mô tả dữ liệu thô, mô tả cấu trúc tổng thể, và các giá trị ngoại lai của dữ liệu. Lớp này xuất hiện trên tất cả các đồ thị. Trong giai đoạn đầu của quá trình mô tả dữ liệu bằng trực quan hóa, lớp này thường xuất hiện duy nhất. Đơn giản như khi mô tả mỗi quan hệ giữa thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới năm 2011, lớp được hiển thị bằng hàm `geom_point()` là lớp hiển thị dữ liệu chính.

- Các lớp có mục tiêu tóm tắt và mô tả ý nghĩa thống kê của dữ liệu. Bằng cách thêm vào đồ thị các mô hình hoặc bằng cách hiển thị các dự đoán dựa trên mô hình mà người tiếp nhận dữ liệu hoặc người phân tích dữ liệu sẽ nhận biết được những giá trị bên trong dữ liệu và những chi tiết mà khi xây dựng mô hình có thể bỏ sót.

- Các lớp có mục tiêu thêm vào ngữ cảnh của dữ liệu. Các lớp này hiển thị bối cảnh nền, thêm vào các chú thích giúp mang lại ý nghĩa cho dữ liệu thô hoặc các giá trị tham chiếu nhằm hỗ trợ việc so sánh hoặc đánh giá. Đây thường là lớp cuối cùng được thêm vào trong đồ thị.

Lớp chính của đồ thị có thể bao gồm bảy thành phần độc lập giống như chúng ta đã giới thiệu ở phần đầu. Cấu trúc của các lớp còn lại của đồ thị $\textbf{ggplot2}$ có thể bao gồm các thành phần sau:

1. Dữ liệu: nếu bạn không khai báo dữ liệu trong mỗi lớp, $\textbf{ggplot2}$ sẽ sử dụng dữ liệu ban đầu là dữ liệu mặc định.

2. Ánh xạ thẩm mỹ: được khai báo trong hàm `aes()` trong mỗi lớp, nếu không có khai báo riêng về ánh xạ thẩm mỹ, $\textbf{ggplot2}$ sẽ sử dụng ánh xạ thẩm mỹ được khai báo trong hàm `ggplot()`.

3. Một hình dạng đồ họa được gọi bằng các hàm `geom_*()`.

4. Một biến đổi thống kê hoặc một tóm tắt của dữ liệu được gọi bằng hàm $stat_*()$.

5. Vị trí xuất hiện của lớp đó trong bố cục chung.

Khi đồ thị chỉ có một lớp với mục tiêu hiển thị dữ liệu chính, bạn không cần phải am hiểu về ngữ pháp của đồ thị. Bạn đọc chỉ cần khai báo chính xác ánh xạ thẩm mỹ trong hàm `aes()` để có được kết quả mong muốn. Tuy nhiên khi xây dựng đồ thị có nhiều lớp, bạn đọc cần phải nắm được ngữ pháp để kết hợp các lớp lại với nhau theo ý muốn của mình.

### Ánh xạ thẩm mỹ trong đồ thị có nhiều lớp

Hãy quan sát đồ thị trong Hình \@ref(fig:fgggplot09), khi bạn muốn thêm vào một đường mô tả mối liên hệ giữa thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia trên thế giới vào năm 2011. Hàm số dùng để thêm vào một đường mô tả mối liên hệ là `geom_smooth()`

```{r fgggplot09, warning=FALSE, message=FALSE, fig.cap = "Đồ thị có hai lớp bao gồm một đồ thị phân tán và một đường mô tả mối liên hệ giữa các điểm. Hình bên trái: ánh xạ thẩm mỹ màu sắc được khai báo trong hàm ggplot(). Hình bên phải: ánh xạ thẩm mỹ màu sắc được khai báo trong hàm geom_point()"}
## Hình bên trái, khai báo color trong ggplot()
p1<-dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita,
                color = continent)) +
  geom_point(alpha = 0.5)+
  geom_smooth(se=FALSE)+
  theme(legend.position = "none")+
  theme_minimal()

## Hình bên phải, khai báo color trong geom_point()
p2<-dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita))+
  geom_point(aes(color = continent), alpha = 0.5) +
  geom_smooth(se=FALSE)+
  theme(legend.position = "none")+
  theme_minimal()

## Vẽ p1 và p2 trên cùng một đồ thị
grid.arrange(p1,p2,nrow= 1 , ncol = 2)
```

Bạn đọc có thể thấy sự khác nhau giữa hai đồ thị là các đường mô tả mối liên hệ giữa tuổi thọ trung bình và thu nhập bình quân đầu người được xây dựng theo từng lục địa cho hình bên trái Hình \@ref(fig:fgggplot09) và chỉ có duy nhất một đường được xây dựng cho tất cả các quốc gia trong hình bên phải của Hình \@ref(fig:fgggplot09). Sự khác biệt là do trong hình bên phải chúng ta đã khai báo ánh xạ thẩm mỹ đến thuộc tính `color` bên trong hàm `geom_point()` trong khi trong hình bên trái chúng ta khai báo ánh xạ thẩm mỹ đến thuộc tính `color` bên trong hàm `ggplot()`

Nếu như hàm `geom_point()` là lớp chính mô tả dữ liệu thô thì hàm `geom_smooth()` là lớp phụ được thêm vào nhằm tăng khả năng mô tả của dữ liệu. Các ánh xạ thẩm mỹ được khai báo trong hàm `ggplot()` cũng giống như các biến toàn cục trong một đồ thị, còn các ánh xạ thẩm mỹ được khai báo trong các hàm `geom_*()` giống như khai báo giá trị cho các biến cục bộ trong môi trường của hàm số đó. Các biến cục bộ nếu không được khai báo trong các hàm `geom_*()` sẽ được tìm trên môi trường toàn cục của hàm `ggplot()`. Trong trường hợp trong các hàm `geom_*()` và `ggplot()` đều không được khai báo giá trị các thuộc tính thẩm mỹ của lớp phụ sẽ nhận giá trị mặc định.

Trong hình bên trái của Hình \@ref(fig:fgggplot09), các thuộc tính thẩm mỹ `x`, `y`, và `color` được khai báo trong hàm `ggplot()`; đồng thời trong các hàm `geom_point()` và `geom_smooth()` không khai báo các ánh xạ thẩm mỹ; do đó cả hai hàm này đều hiểu các thuộc tính thẩm mỹ `x`, `y`, và `color` giống như khai báo ban đầu. Trong hình bên phải của Hình \@ref(fig:fgggplot09), hai thuộc tính thẩm mỹ `x` và `y` được khai báo trong hàm `ggplot()` trong khi thuộc tính thẩm mỹ `color` được khai báo bên trong hàm `geom_point()`. Do đó, hàm `geom_smooth()` chỉ hiểu hai thuộc tính thẩm mỹ `x` và `y` như được khai báo trong `ggplot()`. Thuộc tính thẩm mỹ `color` của hàm `geom_smooth()` trong hình bên phải của Hình \@ref(fig:fgggplot09) sẽ được gán giá trị mặc định. Cách ghi nhận các thuộc tính thẩm mỹ của hai lớp của các đồ thị trong Hình \@ref(fig:fgggplot09) được tổng kết lại như sau:
```{r, warning=FALSE, message=FALSE, echo = FALSE}
Col1 = c("Hình bên trái", "Hình bên phải")
Col2 = c("x, y và color", "x, y, và color")
Col3 = c("x, y và color", "x, y")
dat0<-data.frame(c1 = Col1, c2 = Col2, c3 = Col3 )

kable(dat0, booktabs = T,
      col.names = c(" ",
        "geom_point()", "geom_smooth()"),
      escape=F) %>%
  column_spec(c(2,2)) %>%
  kable_styling(latex_options = "scale_down")
```

Đường mô tả mối liên hệ giữa hai biến thu nhập bình quân và tuổi thọ trung bình được xây dựng bằng hàm `geom_smooth()` dựa trên phương pháp được gọi là hồi quy cục bộ (locally estimated scatterplot smoothing hay loess) mà chúng ta sẽ thảo luận trong phần mô hình cộng tính tổng quát. Khi thuộc tính thẩm mỹ `color` được sử dụng và ánh xạ đến một biến rời rạc, hàm `geom_smooth()` sẽ chia dữ liệu thành các nhóm, mỗi nhóm tương ứng với một giá trị của biến ánh xạ đến `color`, sau đó trước xây dựng mô hình hồi quy cục bộ mà thu nhập bình quân phụ thuộc vào tuổi thọ trung bình cho mỗi nhóm. Điều này giải thích tại sao trong hình bên trái có năm mô hình được xây dựng tương ứng với năm Châu lục, trong khi trong hình bên phải chỉ có một mô hình duy nhất được xây dựng cho tất cả các quốc gia trên thế giới.

Vậy khi nào bạn nên khai báo ánh xạ thẩm mỹ trong hàm `ggplot()` và khi nào bạn nên khai báo ánh xạ thẩm mỹ bên trong hàm `geom_*()`? Câu trả lời là nếu đa số các lớp bạn đọc sử dụng chung một dữ liệu và chung các ánh xạ thẩm mỹ, bạn nên khai báo ánh xạ thẩm mỹ bên trong hàm `ggplot()`. Còn trong trường hợp các lớp sử dụng dữ liệu khác nhau, hoặc có ánh xạ thẩm mỹ khác nhau, bạn hãy khai báo ánh xạ thẩm mỹ bên trong mỗi hàm `geom_*()`. Trong trường hợp bạn dùng một hàm thuộc nhóm hàm `geom_()*` và không muốn sử dụng ánh xạ thẩm mỹ đã khai báo trong `ggplot()`, bạn có thể khai báo lại hoặc khai báo thuộc tính thẩm mỹ đó bằng `NULL` nếu không muốn sử dụng ánh xạ thẩm mỹ đó.

Một lưu ý quan trọng cần được thảo luận trong ngữ pháp của đồ thị đó là sự khác nhau giữa sử dụng ánh xạ thẩm mỹ và thiết lập tham số. Trước hết, bạn đọc hãy quan sát ba đồ thị trong Hình \@ref(fig:fgggplot10)

```{r fgggplot10, warning=FALSE, message=FALSE, fig.cap= "Sự khác nhau giữa ánh xạ thẩm mỹ và thiết lập tham số. Hình bên trái: có hàm geom_smooth() sử dụng ánh xạ thẩm mỹ color mặc định. Hình ở giữa: hàm geom_smooth() được thiết lập tham số color (màu đen). Hình bên phải: hàm geom_smooth() sử dụng ánh xạ thẩm mỹ, thuộc tính color ánh xạ đến một biến kiểu chuỗi ký tự"}
## Hình góc trên bên trái, geom_smooth có aes(color = NULL)
p1<-dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita,
                color = continent)) +
  geom_point(alpha = 0.5)+
  geom_smooth(aes(color=NULL), se = FALSE)+
  theme(legend.position = "right")+
  theme_minimal()

## Hình góc trên bên phải, geom_smooth có thiết lập (color = back)
p2<-dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita,
                color = continent)) +
  geom_point(alpha = 0.5)+
  geom_smooth(color="black", se = FALSE)+
  theme(legend.position = "right")+
  theme_minimal()

## Hình góc dưới bên trái, geom_smooth có aes(color = "black")
p3<-dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita,
                color = continent)) +
  geom_point(alpha = 0.5)+
  geom_smooth(aes(color="black") , se = FALSE)+
  theme(legend.position = "right")+
  theme_minimal()


## Hình góc dưới bên phải, geom_smooth có aes(color = newcol)
p4<-dat%>%mutate(newcol = "black")%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita)) +
  geom_point(aes(color = continent))+
  geom_smooth(aes(color = newcol) , se = FALSE)+
  theme(legend.position = "right")+
  theme_minimal()

## Vẽ các đồ thị trên cùng một hình
grid.arrange(p1,p2,p3,p4, nrow= 2 , ncol = 2)
```

Có hai cách để chúng ta tác động đến các thuộc tính thẩm mỹ của đồ thị được vẽ bằng các hàm `geom_*()`, đó là dùng ánh xạ thẩm mỹ hoặc thiết lập tham số. Sự khác nhau giữa hai cách này là việc bạn khai báo giá trị của thuộc tính thẩm mỹ bên trong hay bên ngoài hàm `aes()`. Hình \@ref(fig:fgggplot10) cho thấy rằng:

- Hình góc trên bên trái có đường hồi quy liên tục mô tả mối liên hệ giữa hai biến có màu mặc định. Nguyên nhân là do khi gọi hàm `geom_smooth()` chúng ta đã cho thuộc tính thẩm mỹ `color` nhận giá trị mặc định. Thật vậy, trong hàm `aes()` của `geom_smooth()` thuộc tính `color` được ánh xạ đến giá trị NULL.

- Hình góc trên bên phải đã thực hiện thiết lập cấu phần thẩm mỹ `color` bằng một giá trị cố định là "black" (màu đen). Do đó đường hồi quy được tạo từ `geom_smooth()` sẽ có màu đen đúng như yêu cầu từ thiết lập. Bạn đọc chỉ cần sử dụng giá trị màu sắc có ý nghĩa với R để thiết lập cho thuộc tính thẩm mỹ màu sắc. Nếu trong một hàm `geom_*()` vừa có ánh xạ thẩm mỹ được khai báo trong hàm `aes()` và vừa có thiết lập thuộc tính thẩm mỹ, đồ thị $\textbf{ggplot2}$ sẽ ưu tiên giá trị nằm ngoài `aes()`, nghĩa là ưu tiên thiết lập tham số.

- Hình góc dưới bên trái phức tạp hơn một chút. Khác với hình ở giữa, thuộc tính `color` được gán cho giá trị $"black"$ bên trong hàm `aes()`. Bạn đọc có thể thấy rằng đường hồi quy được tạo từ hàm `geom_smooth()` không có màu đen như hình ở giữa. Nguyên nhân là do khi khai báo thuộc tính thẩm mỹ trong hàm `aes()`, chúng ta đã ánh xạ thuộc tính `color` của hàm `geom_smooth()` đến một giá trị kiểu ký tự là $"black"$ chứ không phải cho màu sắc của đường cong nhận giá trị màu đen tương ứng! Trong hàm `geom_point()` trước đó đã ánh xạ biến $continent$ tới thuộc tính thẩm mỹ `color`, khi chúng ta tiếp tục ánh xạ một biến $"black"$ tới thuộc tính `color` trong `geom_smooth()` thì $\textbf{ggplot2}$ sẽ hiểu rằng có thêm một giá trị mới cho thuộc tính `color`  là $"black"$ thêm vào cùng với các giá trị hiện có là tên của 5 châu lục. Điều này giải thích tại sao trong chú giải của hình bên tay phải có 6 loại thay vì 5 loại như hình ở giữa. Đường hồi quy tạo bởi `geom_smooth()` có màu xanh lá cây vì giá trị $"black"$ có thứ hạng là 4 khi sắp xếp 6 giá trị ánh xạ tới thuộc tính `color` theo thứ tự tăng dần.

- Hình góc dưới bên phải được vẽ trên dữ liệu sau khi được thêm vào cột mới có tất cả các giá trị là chuỗi ký tự $"black"$. Đồ thị vẫn bao gồm hai lớp là `geom_point()` và `geom_smooth()`. Cả hai lớp đều sử dụng chung thuộc tính thẩm mỹ `x` và `y`. Thuộc tính thẩm mỹ `color` của `geom_point()` được ánh xạ đến biến $continent$ trong khi thuộc tính thẩm my `color` của `geom_smooth()` ánh xạ đến cột mới được tạo thành. Bạn đọc có thể thấy rằng đồ thị được tạo ra hoàn toàn giống như đồ thị được tạo ra trong bước trước khi chúng ta gán trực tiếp thuộc tính `color` của `geom_smooth()` với giá trị $"black"$.

Khi cân nhắc sử dụng ánh xạ hay thiết lập giá trị cho các thuộc tính thẩm mỹ, bạn đọc cần cân nhắc về việc có muốn tác động lên thuộc tính thẩm mỹ nữa hay không. Nếu bạn muốn cố định giá trị cho thuộc tính thẩm mỹ, hãy sử dụng thiết lập giá trị. Còn nếu bạn muốn tác động lên thuộc tính thẩm mỹ sau đó, hãy sử dụng ánh xạ thẩm mỹ. Chúng ta sẽ thảo luận thêm về vấn đề này khi nói về các hàm `scale_*()`.

Bạn đọc hãy lưu ý về cách chú giải ghi nhận giá trị mới của một thuộc tính thẩm mỹ. Trong đồ thị góc dưới bên trái của Hình \@ref(fig:fgggplot10), khi chúng ta khai báo giá trị $"black"$ cho thuộc tính `color`, đồ thị $\textbf{ggplot2}$ ghi nhận $"black"$ như một giá trị mới tương đương với tên các Châu lục đã sử dụng trong khai báo trước đó. Cách ghi nhận tên biến mới trong chú giải sẽ rất hữu ích khi chúng ta muốn tạo một đồ thị nhiều lớp và đặt tên cho từng lớp trong phần chú giải của đồ thị. Ví dụ, khi chúng ta muốn so sánh ba phương pháp xây dựng mô hình mô tả mối liên hệ giữa biến tuổi thọ trung bình và biến thu nhập bình quân đầu người bao gồm: phương pháp hồi quy tuyến tính thông thường (`method = "lm"`); phương pháp hồi quy loess (`method = "loess"`), và phương pháp hồi quy cộng tính tổng quát (`method = "gam"`), chúng ta có thể sử dụng ánh xạ thẩm mỹ `color` như sau:

```{r fgggplot11, warning=FALSE, message=FALSE, fig.cap= "Sử dụng trực quan hóa để so sánh ba phương pháp xây dựng mô hình mô tả mối liên hệ giữa tuổi thọ trung binh và thu nhập bình quân đầu người của các quốc gia trên thế giới năm 2011" }
# So sánh ba phương pháp xây dựng mô hình khác nhau của hàm geom_smooth
dat%>%ggplot(aes(x = life_expectancy, y = gdp_per_capita)) +
  #Layer 1: đồ thị rải điểm
  geom_point(alpha = 0.4)+

  # Layer 2: Đường hồi quy tuyến tính
  geom_smooth(aes(color="Hồi quy tuyến tính"), method = "lm" , se = FALSE)+

  # Layer 3: Đường hồi quy loess
  geom_smooth(aes(color="Hồi quy loess"), method = "loess", span = 0.3 , se = FALSE)+

  # Layer 4: Mô hình GAM (generalized additive model)
  geom_smooth(aes(color="Mô hình cộng tính tổng quát"), method = "gam" , se = FALSE)+
  theme_minimal()
```

Đồ thị trong Hình \@ref(fig:fgggplot11) có bốn lớp. Khi chúng ta khai báo thuộc tính thẩm mỹ `x` và `y` trong hàm `ggplot()`, cả bốn lớp đều sử dụng chung các ánh xạ thẩm mỹ này. Hàm `geom_point()` không sử dụng thêm ánh xạ thẩm mỹ nào. Mỗi hàm `geom_smooth()` thêm một đường hồi quy vào trong đồ thị, và thêm một giá trị vào thuộc tính thẩm mỹ `color`. Đồ thị `ggplot()` sẽ sử dụng ba màu sắc mặc định để mô tả ba đường hồi quy tương ứng, với chú giải là tên của phương pháp xây dựng đường hổi quy.

### Các hàm `geom_*()` cơ bản
Các hình dạng đồ họa, gọi tắt là các geoms, là một cách phổ biến để hiển thị một lớp của một đồ thị mô tả dữ liệu. Ví dụ như sử dụng `geom_point()` sẽ tạo ra một đồ thị phân tán hay còn gọi là đồ thị rải điểm; khi sử dụng `geom_line()` sẽ tạo ra các đồ thị theo đường,... Danh sách các geoms và các thuộc tính thẩm mỹ bạn đọc có thể tìm trong danh sách được liệt kê trong link ở phần \@ref(sec:ggplot_intro). Trong phần này, chúng tôi phân loại và giải thích cách sử dụng các geoms chi tiết hơn.

#### Mô tả một biến
Khi sử dụng đồ thị của $\textbf{ggplot2}$ để mô tả một biến rời rạc, hàm thường được sử dụng là `geom_bar()`. Tần suất xuất hiện của các giá trị trong các biến rời rạc được mô tả dưới dạng các thanh. Các thuộc tính thẩm mỹ quan trọng của `geom_bar()` bao gồm:

- Thuộc tính thẩm mỹ `x` được ánh xạ đến tên biến (rời rạc).

- Thuộc tính thẩm mỹ `color` là màu sắc của đường viền xung quanh các thanh.

- Thuộc tính thẩm mỹ `fill` là màu sắc của các thanh. `fill` ngoài ý nghĩa tăng tính thẩm mỹ cho đồ thị dạng thanh còn có ý nghĩa khi mô tả mối liên hệ giữa biến rời rạc được mô tả bởi thuộc tính thẩm mỹ `x` với một biến khác.

Hình \@ref(fig:fgggplot12) sử dụng đồ thị dạng thanh mô tả phân phối xác suất của biến $continent$ trong dữ liệu $\textbf{gapminder}$ trong năm 2011.

```{r fgggplot12, warning=FALSE, message=FALSE, fig.cap= "Phân phối xác suất của biến continent trong dữ liệu gapminder trong năm 2011. Hình bên trái: phân phối xác suất của biến continent mô tả theo thứ tự của giá trị xuất hiện. Hình bên phải: phân phối xác suất của biến continent mô tả theo thứ tự của tần suất xuất hiện của các biến tăng dần." }
p1<-dat%>%ggplot() + 
  geom_bar(aes(x = continent), color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
p2<-dat%>%ggplot() + 
  geom_bar(aes(x = continent), color = "orange", fill = "blue", alpha = 0.5)+
  scale_x_discrete(limits = names(sort(table(dat$continent))))+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```
Khi mô tả biến rời rạc, `geom_bar()` luôn mặc định sắp xếp các thanh theo thứ tự các giá trị xuất hiện trong biến rời rạc tăng dần. Tuy nhiên, để đồ thị dạng thanh mô tả hiệu quả hơn, chúng ta thường để các thanh xuất hiện theo thứ tự có chiều cao tăng dần hoặc giảm dần giống như hình bên trái của Hình \@ref(fig:fgggplot12). Để thực hiện việc này, chúng ta cần thay đổi thứ tự xuất hiện của các giá trị trên trục $x$ theo thứ tự tần suất tăng dần hay giảm dần bằng hàm `scale_x_discrete()`. Chúng ta sẽ thảo luận về các hàm này trong phần sau.

Hàm `geom_bar()` cũng thường được sử dụng để mô tả các giá trị liên tục được lưu trong một biến tương ứng với các giá trị rời rạc được lưu trong biến khác. Ví dụ, khi chúng ta muốn mô tả thu nhập bình quân của 10 nước có thu nhập bình quân đầu người lớn nhất thế giới năm 2011, chúng ta có thể sử dụng geom_bar() với đầy đủ hai thuộc tính thẩm mỹ `x` và `y` như sau:
```{r fgggplot13, warning=FALSE, message=FALSE, fig.cap= "10 nước có thu nhập bình quân đầu người cao nhất thế giới năm 2011. Hình bên trái: Thứ tự các nước không được sắp xếp theo thu nhập bình quân đầu người. Hình bên phải: các nước xuất hiện theo thứ tụ thu nhập bình quân đâu người giảm dần."}
p1<-dat%>%arrange(desc(gdp_per_capita))%>%head(10)%>%
  ggplot() + 
  geom_bar(aes(x = gdp_per_capita, y = country), 
           stat = "identity",
           color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
p2<-dat%>%arrange(desc(gdp_per_capita))%>%head(10)%>%
  ggplot() + 
  geom_bar(aes(x = gdp_per_capita, y = reorder(country,gdp_per_capita)), 
           stat = "identity",
           color = "orange", fill = "blue", alpha = 0.5)+
  ylab("country")+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```
Khi sử dụng `geom_bar()` để mô tả hai biến như Hình \@ref(fig:fgggplot13) chúng ta cần cho tham số `stat` nhận giá trị bằng $"identity"$ để phân biệt với khi sử dụng `geom_bar()` khi mô tả một biến liên tục. Chúng tôi sẽ giải thích tham số `stat` trong phần lập trình trong ggplot2 ở phần sau. Để biễn cách cột theo thứ tự tăng dần hay giảm dần, bạn đọc sử dụng hàm `reorder()`. Trong đồ thị bên phải của Hình \@ref(fig:fgggplot13), chúng tôi ánh xạ cấu phần thẩm mỹ `y` của `geom_bar()` đến biến $country$ nhưng được sắp xếp theo thứ tự $gdp_per_capita$ của giảm dần. 

Để mô tả một biến liên tục chúng ta sử dụng `geom_histogram()`. Hình dạng đồ họa của `geom_histogram()` giống với `geom_bar()` là sử dụng các thanh hoặc các cột để mô tả tần suất xuất hiện của các giá trị trong biến. Nguyên tắc vẽ đồ thị dạng cột của hàm này là chia khoảng được xác định bởi giá trị nhỏ nhất và giá trị lớn nhất của biến lien tục thành $k$ khoảng bằng nhau, sau đó đếm trong mỗi khoảng có bao nhiêu giá trị của biến liên tục xuất hiện. Độ rộng của các cột chính là độ rộng của các khoảng còn chiều cao của các cột là số lần (hoặc tần suất) xuất hiện của các giá của biến liên tục trong khoảng đó. Tham số `bins` cho biết chúng ta sử dụng bao nhiêu khoảng để chia miền giá trị của biến liên tục. Các cấu phần thẩm mỹ của `geom_histogram()` tương đối giống với `geom_bar()` nên chúng tôi sẽ không nhắc lại.

Hình \@ref(fig:fgggplot14) mô tả biến thu nhập bình quân đầu người trong năm 2011 của tất cả các quốc gia trên thế giới.
```{r fgggplot14, warning=FALSE, message=FALSE, fig.cap= "Phân phối của biến thu nhập bình quân đầu người của các quốc gia trên thế giới năm 2011. Hình bên trái: Sử dụng 10 bins để mô tả. Hình bên phải: Sử dụng 30 bins để mô tả."}
p1<-dat%>%ggplot() + 
  geom_histogram(aes(x = gdp_per_capita), bins = 10,
           color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
p2<-dat%>%ggplot() + 
  geom_histogram(aes(x = gdp_per_capita), bins = 40,
           color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
  
```

Lựa chọn số `bins` để hiển thị là rất quan trọng trong mô tả phân phối xác suất của một biết liên tục. Trong trường hợp biến có ít quan sát như Hình \@ref(fig:fgggplot13) lựa chọn giữa 10 bins hoặc 30 bins không dẫn đến sự khác biệt nhiều. Tuy nhiên, khi biến liên tục có nhiều quan sát, lựa chọn số `bins` quá ít sẽ làm cho chúng ta hiểu sai về phân phối của biến. Hãy quan sát ví dụ khi chúng ta mô tả biến $price$ trong dữ liệu có tên là $\textbf{diamond}$ là biến chứa giá của hơn 50 nghìn viên kim cương như Hình \@ref(fig:fgggplot15)
```{r fgggplot15, warning=FALSE, message=FALSE, fig.cap= "Phân phối của biến price trong dữ liệu diamonds với hơn 50 nghìn quan sát. Hình bên trái: Sử dụng 10 bins để mô tả. Hình bên phải: Sử dụng 60 bins để mô tả."}
p1<-diamonds%>%ggplot() + 
  geom_histogram(aes(x = price), bins = 10,
           color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
p2<-diamonds%>%ggplot() + 
  geom_histogram(aes(x = price), bins = 60,
           color = "orange", fill = "blue", alpha = 0.5)+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```

Bạn đọc có thể nhận thấy rằng nếu chúng ta sử dụng quá ít `bins` để mô tả một số lượng quan sát lớn có thể dẫn đến kết luận sai về phân phối của biến liên tục. Hình bên trái của Hình \@ref(fig:fgggplot15) là phân phối của một biến ngẫu nhiên chỉ có một giá trị mode (một đỉnh) tại giá trị 2500 và sau đó có tần suất xuất hiện giảm dần. Hình bên phải của Hình \@ref(fig:fgggplot15) cho biết đây là một phân phối liên tục có hai đỉnh tại các giá trị 1000 và 4500.  

Cũng để mô tả phân phối xác suất của biến liên tục, `geom_density()` có thể được sử dụng một cách độc lập hoặc bổ sung với histogram để mô tả phân phối của các biến một cách tốt hơn. Hình \@ref(fig:fgggplot16) mô tả cách sử dụng `geom_density()` cùng với `geom_histogram()` để mô tả phân phối của các biến liên tục.

```{r fgggplot16, warning=FALSE, message=FALSE, fig.cap= "Kết hợp geom_density và geom_histogram để mô tả phân phối xác suất của biến liên tục. Hình bên trái: phân phối của biến thu nhập bình quân đầu người của các quốc gia trên thế giới năm 2011. Hình bên phải: phân phối của giá của các viên kim cương trong dữ liệu diamonds"}
p1<-dat%>%ggplot() + 
  geom_histogram(aes(x = gdp_per_capita, after_stat(density)), bins = 30,
          fill = "blue", alpha = 0.2)+
  geom_density(aes(x = gdp_per_capita), color = "orange")+
  theme_classic()
p2<-diamonds%>%ggplot() + 
  geom_histogram(aes(x = price, after_stat(density)), bins = 60,
           fill = "blue", alpha = 0.2)+
  geom_density(aes(x = price),color = "orange")+
  theme_classic()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```

Để hiển thị đồng thời đồ thị histogram và đồ thị density trên cùng một đồ thị, chúng ta cần phải biến đổi đồ thị histogram từ mô tả số lần xuất hiện của biến liên tục thành tần suất xuất hiện. Bạn đọc thực hiện phép biến đổi này bằng cách thêm vào sau phần khai báo ánh xạ thẩm mỹ câu lệnh `after_stat(density)` để tổng diện tích của các hình được tạo bởi các thanh được quy đổi về 1.

Phương pháp vẽ đồ thị của `geom_density()` cũng giống như hàm `density()` có sẵn trong R xây dựng một đường liên tục là ước lượng cho hàm mật độ xác suất của một biến ngẫu nhiên liên lục. Hàm mật độ này được ước lượng bằng phương pháp kernel. Giá trị hàm mật độ tại một điểm $x$ bất kỳ nằm trong miền giá trị của một biến liên tục được tính bằng trung bình giá trị hàm $K$, được gọi là hàm kernel, tính trên khoảng cách từ điểm $x$ tới tất cả các quan sát. Ký hiệu $\hat{f}(x)$ là giá trị hàm mật độ tính tại $x$ bằng phương pháp kernel thì ta có
\begin{align}
\hat{f}(x) = \cfrac{1}{nh} \times \sum\limits_{i = 1}^{n} \ K\left( \cfrac{x - x_i}{h} \right)
(#eq:ggplot1)
\end{align}
trong đó $x_i$ là giá trị quan sát thứ $i$ và $h$ là được gọi là tham số làm mịn. $h$ càng lớn thì hàm $\hat{f}$ sẽ càng mịn. Hàm $K$ được sử dụng làm hàm kernel mặc định cho `geom_density()` là hàm mật độ của biến ngẫu nhiên phân phối chuẩn.

Một hàm số khác cũng có thể được sử dụng để mô tả phân phối của một biến liên tục là `geom_boxplot()` nhưng hàm số này có thể được sử dụng để mô tả mối liên hệ giữa biến rời rạc và biến liên tục nên chúng tôi sẽ thảo luận ở phần sau.

#### Mô tả hai biến liên tục
Đồ thị phân tán được vẽ bằng hàm `geom_point()` là cách hiệu quả nhất để mô tả trực quan hai biến liên tục. Bạn đọc đã làm quen với `geom_point()` cùng với các thuộc tính thẩm mỹ như `x`, `y`, `color`, `shape`, `size`, ... để mô tả mối liên hệ giữa các biến thu nhập bình quân đầu người và tuổi thọ bình quân của các quốc gia trên thế giới nên chúng tôi sẽ không nhắc lại cách sử dụng các cấu phần thẩm mỹ này của `geom_point()`

Đồ thị phân tán thường được sử dụng cùng với `geom_smooth()` để mô tả mối liên hệ giữa hai biến. Phương pháp xây dựng mô hình trong hàm `geom_smooth()` bao gồm:

- Phương pháp $"loess"$ là phương pháp mặc định để xây dựng hàm liên tục hay còn gọi là đường hồi quy mô tả mối liên hệ giữa biến được ánh xạ tới `y` theo biến được ánh xạ tới `x`. Phương pháp này được sử dụng khi số lượng quan sát nhỏ hơn 1000. Nguyên nhân là do thời gian xây dựng mô hình tăng lên tỷ lệ với bình phương của số lượng quan sát, do đó sẽ mất nhiều thời gian để vẽ đường hồi quy mô tả mối liên hệ giữa hai biến.

- Phương pháp $"lm"$ sẽ ước lượng đường thẳng (tuyến tính) mô tả mối liên hệ giữa biến ánh xạ đến `x` và biến ánh xạ đến `y`.

- Phương pháp $"gam"$ sẽ ước lượng một hàm liên tục được gọi là smoothing spline mô tả mối liên hệ giữa hai biến. Đây là phương pháp mặc định để xây dựng mô hình khi dữ liệu có kích thước lớn hơn 1000. Chúng ta sẽ thảo luận về smoothing spline trong phần Mô hình cộng tính tổng quát.

Trong trường hợp mô tả trực quan hai biến liên tục nhưng có nhiều điểm bị trùng nhau lên nhau thì `geom_point()` có thể sẽ gây nhầm lẫn về mật độ xuất hiện của các điểm. Hãy quan sát ví dụ dưới đây, chúng tôi sử dụng `geom_point()` để mô tả trực quan hai biến $cty$ và $hwy$ của dữ liệu $\textbf{mpg}$. Đây là hai biến liên tục mô tả mức độ tiêu hao nhiên liệu của 234 loại xe ô tô khác nhau được sản xuất vào các năm 1998 và 2008. Đơn vị của hai biến này đều là miles per gallon, nghĩa là cho biết số dặm mà xe đi được trên mỗi gallon nhiên liệu.
```{r fgggplot17, warning=FALSE, message=FALSE, fig.cap= "Sử dụng đồ thị phân tán để mô tả trực quan hai biến liên tục là hwy và cty trong dữ liệu mpg. Hình bên trái: không sử dụng tham số alpha. Hình bên phải sử dụng tham số alpha bằng 0.2 để biết mật độ xuất hiện của các điểm"}
p1<-mpg%>%ggplot(aes(x = cty,y = hwy)) + 
  geom_point()+
  geom_smooth(se = FALSE, linetype = 2, size = 0.7, color = "orange")+
  theme_minimal()
p2<-mpg%>%ggplot(aes(x = cty,y = hwy)) + 
  geom_point(alpha = 0.2)+
  geom_smooth(se = FALSE, linetype = 2, size = 0.7, color = "orange")+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```

Bạn đọc có thể nhận thấy rằng số lượng điểm xuất hiện trên đồ thị bên trái của Hình \@ref(fig:fgggplot17) không tương ứng với số quan sát của dữ liệu. Nhận xét này được khẳng định thêm từ đồ thị bên phải của Hình \@ref(fig:fgggplot17). Khi chúng ta cho tham số `alpha` nhận giá trị 0.2, độ đậm nhạt của các điểm là rất khác nhau. Điều này cho thấy sự xuất hiện trùng lặp của của các điểm tại một số giá trị nhất định. Để có hiển thị tốt hơn với dữ liệu như vậy, bạn đọc có thể sử dụng `geom_jitter()` thay cho `geom_point()`. Hàm cũng hiển thị các điểm trên hai trục tọa độ giống như `geom_point()`, tuy nhiên khác biệt của `geom_jitter()` đó là mỗi điểm sẽ được di chuyển các một cách ngẫu nhiên xung quanh điểm ban đầu để tránh việc hiển thị điểm bị trùng nhau.
```{r fgggplot18, warning=FALSE, message=FALSE, fig.cap= "Sử dụng đồ thị phân tán kết hợp với di chuyển ngẫu nhiên bằng geom_jitter để mô tả trực quan hai biến liên tục là hwy và cty trong dữ liệu mpg. Hình bên trái: các điểm được di chuyển một cách ngẫu nhiên với trung bình bằng 1 đơn vị. Hình bên phải: các điểm được di chuyển một cách ngẫu nhiên với trung bình bằng 3 đơn vị."}
p1<-mpg%>%ggplot(aes(x = cty,y = hwy)) + 
  geom_jitter(width = 1, height = 1, alpha = 0.5)+
  geom_smooth(se = FALSE, linetype = 2, size = 0.7, color = "orange")+
  theme_minimal()
p2<-mpg%>%ggplot(aes(x = cty,y = hwy)) + 
  geom_jitter(width = 3, height = 3,alpha = 0.5)+
  geom_smooth(se = FALSE, linetype = 2, size = 0.7, color = "orange")+
  theme_minimal()
grid.arrange(p1,p2, nrow= 1 , ncol = 2)
```

Có thể thấy rằng các điểm dữ liệu đã được hiển thị đầy đủ hơn trong Hình \@ref(fig:fgggplot18). Hai tham số quan trọng trong `geom_jitter()` là `width` và `height` cho biết các điểm được di chuyển theo chiều ngang và chiều dọc với giá trị trung bình là bao nhiêu. Nếu lựa chọn giá trị cho hai tham số này quá nhỏ, mục tiêu hiển thị đầy đủ các điểm sẽ không được đảm bảo, trong khi lựa chọn giá trị cho hai tham số này quá lớn sẽ làm cho dữ liệu bị thay đổi về bản chất. 

Một phương pháp khác được sử dụng để mô tả trực quan hai biến liên tục là `geom_text()` hoặc `geom_label()`. Thay vì hiển thị điểm như `geom_point()`, `geom_text()` hiển thị một biến kiểu chuỗi ký tự thay vì hiển thị điểm. `geom_text()` thường được sử dụng kết hợp với `geom_point()` hoặc cũng có thể sử dụng độc lập trên những dữ liệu nhỏ. Khi dữ liệu có kích thước trung bình hoặc lớn, `geom_text()` nên được sử dụng để nhấn mạnh hoặc chú thích cho một vài điểm quan trọng hơn là được sử dụng cho tất cả các điểm. Khi hiển thị biến kiểu ký tự và các điểm trên cùng một đồ thị, rất dễ dẫn đến hiện tượng ký tự và điểm bị trùng nhau hiển thị chồng lên nhau. Để điều chỉnh ký tự xuất hiện về các phía, bạn đọc cần phải sử dụng thêm các tham số như $hjust$, $vjust$.

Theo kinh nghiệm của chúng tôi, để hiện thị biến kiểu ký tự tốt hơn, nên sử dụng các hàm `geom_text_repel()` và `geom_label_repel()` thay thế cho `geom_text()` và `geom_label()`. Để sử dụng hai hàm này cần cài đặt thêm thư viện bổ sung là thư viện $\textbf{ggrepel}$.
 
```{r fgggplot19, warning=FALSE, message=FALSE, fig.cap = "Tỷ lệ sinh trung bình mỗi phụ nữ và tỷ lệ tử vong trên 1000 trẻ sơ sinh cả các quốc gia Đông Nam Á năm 2011. Hình phía trên bên phải: Sử dụng geom_text. Hình phía trên bên trái: Sử dụng geom_label. Hình phía dưới bên trái: Sử dụng geom_text_rebel. Hình phía dưới bên phải: Sử dụng geom_label_rebel"}
p1<-dat%>%filter(region == "South-Eastern Asia")%>%
  ggplot(aes(fertility, infant_mortality))+
  geom_point()+geom_text(aes(label = country), vjust=  - 1.1)+
  ggtitle("Sử dụng geom_text()")+
  theme_minimal()
p2<-dat%>%filter(region == "South-Eastern Asia")%>%
  ggplot(aes(fertility, infant_mortality))+
  geom_point()+geom_label(aes(label = country), vjust= - 1.1)+
  ggtitle("Sử dụng geom_label()")+
  theme_minimal()

p3<-dat%>%filter(region == "South-Eastern Asia")%>%
  ggplot(aes(fertility, infant_mortality))+
  geom_point()+geom_text_repel(aes(label = country),vjust=  1.1)+
  ggtitle("Sử dụng geom_text_repel()")+
  theme_minimal()
p4<-dat%>%filter(region == "South-Eastern Asia")%>%
  ggplot(aes(fertility, infant_mortality))+
  geom_point()+geom_label_repel(aes(label = country),vjust=  1.1)+
  ggtitle("Sử dụng geom_label_repel()")+
  theme_minimal()
grid.arrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Khi một trong hai biến liên tục là biến dạng thời gian thì chúng ta sẽ sử dụng `geom_line()`. `geom_point()` cũng có thể sử dụng cùng với `geom_line()` nếu số lượng điểm dữ liệu không quá lớn. Nguyên tắc vẽ hình của `geom_line()` là sử dụng các đường thẳng để nối các điểm xuất hiện trong dữ liệu theo thứ tự tăng dần của biến được ánh xạ tới cấu phần thẩm mỹ `x`. Khi vẽ đồ thị của một biến liên tục theo thời gian, biến thời gian luôn luôn được ánh xạ đến thuộc tính `x` của `geom_line()`.

```{r fgggplot20, warning=FALSE, message=FALSE, fig.cap = "Thu nhập bình quân đầu người thay đổi theo thời gian của bốn quốc gia là Pháp, Nhật Bản, Mỹ, và Vương quốc Anh từ năm 1960 đến năm 2016"}
gapminder%>%
  filter(country %in% c("United States","Japan","France","United Kingdom"))%>%
  ggplot(aes(x = year, y = gdp/population,color = country))+
  geom_line()+
  geom_point(size = 0.5, alpha = 0.5)+
  theme_minimal()
```

Hình \@ref(fig:fgggplot20) mô tả sự thay đổi của thu nhập bình quân đầu người của các quốc gia phát triển trên thế giới từ năm 1960 đến 2016. Biến thu nhập bình quân đầu người được ánh xạ đến thuộc tính `y` trong khi biến thời gian ($year$) được ánh xạ đến thuộc tính thẩm mỹ $x$. Để mô tả mỗi quốc gia bằng một đường khác nhau, bạn đọc cần
ánh xạ biến $country$ đến thuộc tính thẩm mỹ như `group`, `linetype`, hoặc `color`.

Khi số lượng quan sát cần hiển thị lớn thì hiển thị trực quan các điểm trên trục tọa độ sẽ không hiệu quả. Thay vào đó, chúng ta nên hiển thị tần xuất và mật độ xuất hiện của các điểm để đồ thị được rõ ràng hơn. `geom_bin2d()` và `geom_density2d()` là các hàm để trực quan hóa phân phối của hai biến liên tục.

- `geom_bin2d()` chia miền giá trị của từng biến thành các khoảng bằng nhau sau đó đếm trong mỗi miền tương ứng với một hình chữ nhật có kích thước bằng một đơn vị khi chia miền giá trị của từng biến có bao nhiêu điểm. Nguyên tắc trực quan hóa của `geom_bin2d()` là sử dụng màu sắc từ đậm nhạt để mô tả số lượng điểm trong từng hình chữ nhật từ lớn đến nhỏ.

- `geom_density2d()` sử dụng phương pháp kernel để tính giá trị hàm mật độ trong không gian hai chiều giống như cách tính toán của `geom_density()` trong công thức \@ref(eq:ggplot1). Khoảng cách từ quan sát $x_i$ đến điểm $x$ được sử dụng là khoảng cách Euclide thay vì $|x_i-x|$ trong không gian một chiều. Hàm kernel được sử dụng là hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều. Hàm `geom_density2d()` vẽ các đường nối các điểm có giá trị hàm mật độ bằng nhau lại với nhau được gọi là các đường bàng quang (hay contour). Hình vẽ dưới đây mô tả phân phối đồng của hai biến $price$ và $carat$ trong dữ liệu $diamonds$.

```{r fgggplot21, warning = FALSE, message=FALSE, fig.cap = "Biểu diễn phân phối của hai biến liên tục là price và carat trong dữ liệu diamonds.  và geom_density2d. Hình bên trái: sử dụng geom_bin2d để chia miền giá trị của các biến ra thành các ô vuông nhỏ và sử dụng màu sắc để mô tả mật độ xuất hiện. Hình bên phải: sử dụng geom_density2d kết nối các điểm có cùng ước lượng của hàm mật độ."}
p1<-diamonds%>%
  ggplot(aes(price, carat))+geom_bin2d(bins = 40)+
  scale_x_log10()+scale_y_log10()+
  theme_minimal()+scale_fill_viridis_c()+
  ggtitle("geom_bind2d")

p2<-diamonds%>%
  ggplot(aes(price, carat))+geom_density2d(color = "blue",alpha = 0.5)+
  scale_x_log10()+scale_y_log10()+
  theme_minimal()+
  ggtitle("geom_density2d")

grid.arrange(p1,p2,nrow=1, ncol = 2)
```

Hình \@ref(fig:fgggplot21) cho thấy phân phối đồng thời của hai biến $carat$ và $price$ trong dữ liệu $\textbf{diamonds}$ là phân phối có nhiều mode. Các điểm có tập trung mật độ đặc biệt cao là các điểm có ($price$, $carat$) bằng (1000, 0.3), (2200,0.7), và (4700, 1.0).

#### Mô tả một biến liên tục và một biến rời rạc
Đồ thị boxplot là phương pháp thông dụng nhất để mô tả mối liên hệ giữa một biến liên tục với một biến rời rạc. Đồ thị boxplot được vẽ bằng hàm `geom_boxplot()` với thuộc tính thẩm mỹ `x` được ánh xạ đến biến rời rạc và thuộc tính thẩm mỹ `y` được ánh xạ đên biến liên tục. Các thuộc tính thẩm mỹ như `color` và `fill` được sử dụng giống như `geom_histogram()`. Hình \@ref(fig:fgggplot22) mô tả mối liên hệ giữa biến thu nhập bình quân đầu người và biến Châu lục của tất cả các quốc gia trên thế giới vào năm 2011.

```{r fgggplot22, warning = FALSE, message=FALSE, fig.cap = "Logarit của thu nhập bình quân đầu người của các quốc gia trên thế giới theo Châu lục năm 2011. Hình bên trái: Các châu lục được sắp xếp theo thứ tự tên Châu lục tăng dần. Hình bên phải: các châu lục được sắp xếp theo thứ tự giá trị trung bình của biến thu nhập bình quân đầu người tăng dần"}
p1<-dat%>%ggplot(aes(x = continent, y = log(gdp_per_capita)))+
  geom_boxplot()+
  theme_minimal()
p2<-dat%>%ggplot(aes(x = reorder(continent, gdp_per_capita), 
                     y = log(gdp_per_capita)))+
  geom_boxplot()+
  theme_minimal()
grid.arrange(p1,p2,nrow=1, ncol = 2)
```

Khi mô tả mối liên hệ giữa một biến liên tục với một biến rời rạc, các đồ thị hộp nên được sắp xếp theo thứ tự mà giá trị trung bình của biến liên tục tương ứng với mỗi giá trị tăng dần giống như đồ thị bên phải của Hình \@ref(fig:fgggplot22). Chúng ta có thể thấy rằng thu nhập bình quân đầu người của Châu Mỹ thấp hơn Châu Á mặc dù các giá trị trung vị và tứ phân vị thứ nhất cao hơn. Nguyên nhân là do phân phối của biến thu nhập bình quân đầu người của châu Á lệch phải mạnh hơn so với phân phối của biến này tại các nước châu Mỹ.

Do `geom_boxplot()` chỉ thể hiện các giá trị phân vị của phân phối xác suất, nên đôi khi sẽ không cung cấp đầy đủ thông tin về phân phối của biến liên tục. Do đó, người phân tích dữ liệu thường sử dụng `geom_violin()` kết hợp cùng với `geom_boxplot()` để cho mô tả tốt hơn về phân phối xác suất của biến liên tục trong từng nhóm. `geom_violin()` đơn giản là vẽ hàm mật độ của biến liên tục trong từng nhóm được định nghĩa bởi biến rời rạc.
```{r fgggplot23, warning = FALSE, message=FALSE, fig.cap = "Logarit thu nhập bình quân đầu người của các quốc gia trên thế giới theo Châu lục năm 2011 kết hợp geom_boxplot và geom_violin"}
p1<-dat%>%ggplot(aes(x = reorder(continent, gdp_per_capita), 
                     y = log(gdp_per_capita)))+
  geom_boxplot()+
  theme_minimal()
p2<-dat%>%ggplot(aes(x = reorder(continent, gdp_per_capita), 
                     y = log(gdp_per_capita)))+
  geom_violin(draw_quantiles = c(0.25,0.5,0.75), 
              alpha = 0.3)+
  theme_minimal()
grid.arrange(p1,p2,nrow=1, ncol = 2)
```
Tham số `draw_quantiles` cho biết các giá ngưỡng phân vị mà chúng ta muốn vẽ cùng với các hàm mật độ. Trong Hình \@ref(fig:fgggplot23) sử dụng các ngưỡng phân vị 25%, 50% và 75% tương tự như `geom_boxplot()`.

#### Mô tả hai biến rời rạc
Đồ thị thường được sử dụng để mô tả trực quan phân phối của hai biến rời rạc là đồ thị kiểu bong bóng. Hàm số được sử dụng để vẽ đồ thị này là `geom_count()`. Tương ứng với mỗi cặp giá trị của hai biến rời rạc, hàm `geom_count()` tính toán số lượng điểm dữ liệu tương ứng với hai giá trị này và phản ánh số lượng điểm dữ liệu lên trên đồ thị thông qua kích thước của mỗi bong bóng. Chúng ta mô tả phân phối của hai biến rời rạc là $cut$ và $color$ trong dữ liệu $\textbf{diamonds}$ như sau:
```{r fgggplot24, warning=FALSE, message=FALSE, fig.cap = "Đồ thị bong bóng mô tả phân phối của hai biến rời rạc là cut và color trong dữ liệu diamonds. Hình bên trái sử dụng hình dạng tròn (shape = 21) để mô tả số điểm dữ liệu. Hình bên phải sử dụng hình vuông (shape = 22) để dễ phân biệt kích thước hơn"}
p1<-diamonds%>%ggplot(aes(cut,color))+
  geom_count(fill="blue",alpha = 0.5,shape = 21)+
  theme_minimal()+scale_size(range = c(1,12))+
  theme(legend.position = "top")

p2<-diamonds%>%ggplot(aes(cut,color))+
  geom_count(fill="blue",alpha = 0.5,shape = 22)+
  theme_minimal()+scale_size(range = c(1,12))+
  theme(legend.position = "top")
grid.arrange(p1,p2,nrow=1, ncol = 2)
```

Các thuộc tính thẩm mỹ của `geom_count()` hoàn toàn giống với `geom_point()` nên chúng ta có thể lựa chọn các hình dạng cho phép phân biệt kích thước tốt hơn thay vì sử dụng hình tròn như mặc định. Đồ thị trong Hình \@ref(fig:fgggplot24) còn sử dụng hàm `scale_size()` để giúp cho hiển thị được tốt hơn. Chúng ta sẽ thảo luận về các hàm `scale_*()` trong các phần tiếp theo. Từ Hình \@ref(fig:fgggplot24) để nhận ra tỷ lệ lớn các viên kim cương có biến $cut$ nhận giá trị $'ideal'$ và tỷ lệ lớn các viên kim cương có màu sắc nhận giá trị $'G'$. Các viên kim cương có biến $cut$ nhận giá trị $'ideal'$ và biến $color$ nhận giá trị $'G'$ cũng xuất hiện nhiều nhất trong dữ liệu với số lượng hơn 4000 viên.

Một phương pháp khác để trực quan hai biến rời rạc là trực quan một biến bằng `geom_bar()` sau đó ánh xạ thuộc tính `fill` đến biến rời rạc còn lại. 


#### Mô tả ba biến
Thư viện $\textbf{ggplot2}$ có hỗ trợ vẽ các hình ảnh trong không gian ba chiều, nhưng sử dụng các hình ảnh kiểu 3 chiều không phải là một phương pháp tốt để hiển thị ba biến trên cùng một đồ thị. Khi mô tả mối liên hệ giữa ba biến, phương pháp đơn giản và hiệu quả nhất là sử dụng ba đồ thị để mô tả mối liên hệ giữa ba cặp biến với nhau. Chỉ khi nào gặp trường hợp bắt buộc, chúng ta mới sử dụng cả ba biến trên cùng một đồ thị. Để mô tả ba biến, nguyên tắc là lựa chọn đồ thị cho hai biến trước sau đó ánh xạ biến còn lại vào một thuộc tính thẩm mỹ.

- Khi hai trong ba biến là biến liên tục và biến còn lại là biến rời rạc, hãy luôn luôn sử dụng đồ thị phân tán để mô tả hai biến liên tục và sử dụng màu sắc để ánh xạ tới biến rời rạc còn lại. 

- Khi hai trong ba biến là các biến rời rạc trong khi biến còn lại là biến liên tục, chúng ta có thể sử dụng `geom_tile()`. Hàm `geom_tile()` đặc biệt hiệu quả khi mô tả mối liên hệ giữa hai biến rời rạc với một biến liên tục bằng cách ánh xạ hai biến rời rạc vào các thuộc tính thẩm mỹ `x` và `y` trong khi giá trị của biến liên tục được mô tả thông qua màu sắc. Do tương ứng với màu sắc chỉ có một giá trị duy nhất của biến liên tục nên nếu tương ứng với một giá trị của biến rời rạc ánh xạ đến trục `x` và một giá trị của biến liên tục ánh xạ tới trục `y` có nhiều giá trị của biến liên tục thì màu sắc sẽ tương ứng với giá trị trung bình của biến liên tục. Ví dụ, khi chúng ta muốn mô tả ba biến $region$, $year$, và $life\_expectancy$ của dữ liệu $\textbf{gapminder}$ trên cùng một đồ thị, chúng ta sẽ cần tính $life\_expectancy$ trung bình của mỗi vùng trong mỗi năm trước khi thực hiện trực quan hóa.

```{r fgggplot25, warning=FALSE, message=FALSE, fig.cap = "Tuổi thọ trung bình của các vùng trên thế giới thay đổi qua các năm từ năm 1960 đến năm 2015"}
# Tạo danh sách các vùng có tuổi thọ trung bình tăng dần
dat1<-gapminder%>%group_by(region)%>%
     summarise(life_expectancy = mean(life_expectancy,na.rm = TRUE))%>%
    arrange(desc(life_expectancy))
region_list<-dat1$region

# Tạo dải màu rời rạc từ cam tới xanh
mycol<-colorRampPalette(c("orange", "blue"),space = "Lab")(10)

# Trực quan hóa 3 biến region, year, và life_expectancy
gapminder%>%group_by(year,region)%>%
     summarise(life_expectancy = mean(life_expectancy,na.rm = TRUE))%>%
     ggplot()+
     geom_tile(aes(x = year, y = region , fill = life_expectancy), color= "grey")+
     scale_fill_gradientn(colours = mycol)+
     scale_x_continuous(breaks = seq(1960,2015,5))+
     scale_y_discrete(limits = region_list)+
     theme_minimal()+
    xlab("")+ylab("")+
    theme(legend.position = "top")
```

Trong đồ thị của Hình \@ref(fig:fgggplot25) chúng tôi đã sử dụng thêm các hàm `scale_*()` để kiểm soát ánh xạ thẩm mỹ. Chẳng hạn giá trị năm (trục x) sẽ là cách đều 5 năm, các vùng trên trục $y$ được sắp xếp theo thứ tự có tuổi thọ trung bình trên toàn bộ dữ liệu tăng dần. Dải màu sắc cũng được gán giá trị cho dải màu liên tục từ cam sang xanh. Chúng ta sẽ thảo luận về `scale_*()` trong phần sau của chương sách.

### Các hàm `stat_*()`+--
Bạn đọc cũng có thể xây dựng các lớp cho đồ thị $\textbf{ggplot2}$ bằng các hàm `stat_*()`. Các hàm số này không hiển thị dữ liệu ở trạng thái ban đầu mà thường hiển thị dữ liệu dưới một phép biến đổi thống kê hoặc một phương pháp tóm tắt dữ liệu. Có sự tương đương giữa các hàm `stat_*()` với các hàm `geom_*()`, nghĩa là chúng ta có thể gọi hàm `geom_*()` bằng một hàm `stat_*()` và ngược lại. Ví dụ `stat_bin()` tương đương với `geom_histogram()` và `geom_bar()`; `stat_smooth()` tương đương với `geom_smooth()`, ... Về bản chất, các geom và các stat đều có nguồn gốc từ chung một hàm tạo một lớp mới cho đồ thị là hàm `layer()`. Chúng ta sẽ thảo luận về các hàm này trong phần Kiến thức nâng cao về $\textbf{ggplot2}$.

Thay vì sử dụng `geom_*()`, chúng ta có thể sử dụng `stat_*()` để mô tả phân phối của các biến liên tục:

```{r fgggplot26, warning=FALSE, message=FALSE, fig.cap = "Phân phối của biến tỷ lệ sinh trung bình một phụ nữ (fertility) năm 2011. Hình bên trái: histogram và mật độ của biến fertility. Hình bên phải: phân phối của biến fertility theo các lục địa"}
p1<-dat%>%ggplot(aes(fertility, after_stat(density)))+
  stat_bin(color = "blue",alpha = 0.5)+
  stat_density(color = "orange",alpha = 0.1)+
  theme_minimal()
p2<-dat%>%ggplot(aes(x = reorder(continent,fertility), y = fertility))+
  stat_boxplot(color = "blue", alpha = 0.5, fill = "grey40")+
  theme_minimal()
grid.arrange(p1,p2,nrow=1,ncol=2)
```

Bạn đọc có thể thấy rằng các đồ thị trong Hình \@ref(fig:fgggplot26) được tạo bằng các hàm `stat_()` và cho kết quả hoàn toàn giống với các hàm `geom_()` tương ứng.

## Hàm `scale_*()`
Các hàm `scale_*()` trong thư viện $\textbf{ggplot2}$ kiểm soát ánh xạ từ các biến của dữ liệu đến thuộc tính thẩm mỹ của đồ thị. Các hàm này lấy dữ liệu ban đầu và biến đổi giá trị trong dữ liệu thành các đối tượng trực quan mà chúng ta có thể nhìn thấy, như kích thước, màu sắc, vị trí, hoặc hình dạng. Bạn đọc có thể tạo đồ thị bằng thư viện $\textbf{ggplot2}$ mà không cần biết chính xác các ánh xạ thẩm mỹ hoạt động như thế nào. Tuy nhiên, hiểu về scales và cách thao tác các hàm `scale_*()` sẽ giúp bạn kiểm soát hoàn toàn những đối tượng trực quan trên đồ thị.

### Vị trí xuất hiện trên trục tọa độ
Đa số các đồ thị trong thư viện $\textbf{ggplot2}$ hiển thị dữ liệu trên trục tọa độ Descartes nên chúng tôi sẽ tập trung vào cách dữ liệu hiển thị trên hai trục tọa độ $x$ và $y$. Khi ánh xạ các biến của dữ liệu tới các trục tọa độ $x$ và $y$, nếu chúng ta không sử dụng các hàm `scale_*()`, các điểm sẽ được hiển thị đúng như giá trị của điểm đó trên các trục tọa độ. Trong nhiều trường hợp, hiển thị tại vị trí đúng như dữ liệu ban đầu sẽ không mang lại hiệu quả. Ví dụ như khi mô tả hai biến $total$ và $population$ của dữ liệu $\textbf{murders}$, bạn đọc có thể so sánh cách hiển thị giữa việc không kiểm soát và có kiểm soát ánh xạ thẩm mỹ như Hình \@ref(fig:fgggplot27)
```{r fgggplot27, warning=FALSE, message=FALSE, fig.cap="Hiển thị biến số vụ sát nhân bằng súng (total) và biến dân số của các bang trong dữ liệu murder. Hình bên trái: vị trí các điểm trên trục tọa độ là giá trị dữ liệu thô. Hình bên phải: vị trí trên các trục tọa độ đã được biến đổi bằng cách lấy logarit cơ số 10"}
p1<-murders%>%ggplot(aes(x = population,y = total))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  theme_minimal()+ggtitle("Không sử dụng scale")
p2<-murders%>%ggplot(aes(x = population,y = total))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  theme_minimal()+
  scale_x_continuous(trans = "log10")+
  scale_y_continuous(trans = "log10")+
  ggtitle("Có sử dụng scale (log10)")
grid.arrange(p1,p2,nrow=1,ncol=2)
```
Có thể thấy rằng đồ thị bên phải của Hình \@ref(fig:fgggplot27) hiển thị rõ ràng hơn hình bên trái sau khi chúng ta có tác động đến ánh xạ từ biến $population$ đến thuộc tính `x` và ánh xạ từ biến $total$ đến thuộc tính `y` bằng các hàm `scale_x_continuous()` và `scale_y_continuous()`. Đây là hai hàm số được dùng để kiểm soát vị trí xuất hiện của các điểm trên trục tọa độ khi các biến trong ánh xạ là các biến kiểu số liên tục. Các tham số có thể được sử dụng trong các hàm này bao gồm có:

- Tham số `trans`, là viết tắt của transformation, nhận giá trị mặc định là $'identity'$ nghĩa là lấy chính xác giá trị của biến ánh xạ vào thuộc tính `x` hoặc `y` tương ứng. Để biết các giá trị mà tham số này có thể nhận được bạn đọc có thể tham khảo trong tài liệu đi kèm với hàm `scale_x_continuous()` và `scale_y_continuous()`. Khi sử dụng scale trên các biến, chẳng hạn như $x_1$ và $x_2$, là các biến ánh xạ tới `x` và `y` trong ánh xạ thẩm mỹ bằng một hàm $f$ được khai báo bằng tham số `trans`, giá trị xuất hiện trên trục tọa độ $x$ và $y$ sẽ tương ứng là $f(x_1)$ và $f(x_2)$. Chẳng hạn như trong đồ thị phía bên phải ở trên, khi chúng ta thực hiện scale, sử dụng hàm $log10$, tọa độ của các điểm (các quốc gia) sẽ là $log10(population)$ và $log10(total)$. Việc chuyển đổi này sẽ hữu ích bởi rất đa số các quốc gia có dân số nhỏ, trong khi có một vài quốc gia có dân số rất lớn. Thực hiện chuyển đổi dữ liệu bằng các hàm $log$ sẽ giúp cho khoảng cách của các điểm cách đều nhau hơn và dễ dàng phân biệt hơn.

- Tham số `limits` giới hạn giá trị trên các thuộc tính thẩm mỹ `x` và `y` của đồ thị. Mỗi khi chúng ta vẽ đồ thị sử dụng thư viện $\textbf{ggplot2}$, tham số `limits` mặc định sẽ đảm bảo việc hiển thị được đầy đủ nhất. Tuy nhiên nhiều khi chúng ta cần phải thay đổi các giá trị giới hạn của các trục tọa độ, chẳng hạn như khi muốn so sánh hai dữ liệu trên cùng một miền giá trị của $x$ và $y$. Các đồ thị trong Hình \@ref(fig:fgggplot28) mô tả hai biến $fertility$ và $life\_expectancy$ trong các năm 1960 và 2011 và không sử dụng scale.

```{r fgggplot28, warning=FALSE, message=FALSE, fig.cap = "Mối liên hệ giữa hai biến tỷ lệ sinh trung bình của mỗi phụ nữ và tuổi thọ trung bình trong hai năm 1960 và 2010 sử dụng miền giá trị trên trục tọa độ khác nhau. Hình bên trái: dữ liệu của năm 1960. Hình bên phải: dữ liệu của năm 2011"}
p1<-gapminder%>%filter(year==1960)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 1960")+
  theme_minimal()
p2<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 2011")+
  theme_minimal()
grid.arrange(p1,p2,nrow=1,ncol=2)
```

Không thể nhận biết được sự khác biệt trong mối liên hệ giữa hai biến tỷ lệ sinh trung bình của mỗi phụ nữ và tuổi thọ trung bình trong các năm 1960 và 2010  do chúng ta không biểu diễn các biến trên cùng một miền giá trị của $x$ và $y$. Để khắc phục vấn đề này, Hình \@ref(fig:fgggplot29) sử dụng tham số $limits$ trong các hàm `scale_x_continuous()` và `scale_y_continuous()`. Để khai báo tham số cho tham số này, chúng ta sử dụng một véc-tơ hai chiều chứa giá trị nhỏ nhất và giá trị lớn nhất trên trục tọa độ mà bạn muốn hiển thị. 
```{r fgggplot29, warning=FALSE, message=FALSE,fig.cap = "Mối liên hệ giữa hai biến tỷ lệ sinh trung bình của mỗi phụ nữ và tuổi thọ trung bình trên cùng một miền giá trị của trục tọa độ. Hình bên trái: dữ liệu của năm 1960. Hình bên phải: dữ liệu của năm 2011"}
p1<-gapminder%>%filter(year==1960)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 1960")+
  scale_x_continuous(limits = c(1,9))+
  scale_y_continuous(limits = c(25,85))+
  theme_minimal()
p2<-gapminder%>%filter(year==2010)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 2010")+
   scale_x_continuous(limits = c(1,9))+
  scale_y_continuous(limits = c(25,85))+
  theme_minimal()
grid.arrange(p1,p2,nrow=1,ncol=2)
```

 - Tham số `breaks` kiểm soát vị trí các điểm được đánh dấu xuất hiện trên các trục tọa độ $x$ và trục tọa độ $y$. Chúng tôi thường kết hợp `breaks` với tham số `labels` để kiểm soát đồng thời vị trí và cách hiển thị trên các trục số. Ví dụ như trong hình so sánh đồ thị mô tả hai biến $fertility$ và $life\_expectancy$ của các năm 1960 và 2010, chúng ta muốn giá trị xuất hiện trên trục $x$ là các số 2, 4, 6, 8 và các số trên trục $y$ xuất hiện tại các vị trí 10, 30, 50, 70, và 90, chúng ta chỉ cần khai báo giá trị cho tham số `breaks` bằng véc-tơ chứa các giá trị mà chúng ta muốn hiển thị. Lưu ý rằng `breaks` có chữ $s$ ở cuối để phân biệt với từ khóa `break`. 

```{r fgggplot30, warning=FALSE, message=FALSE,fig.cap = "Mối liên hệ giữa hai biến tỷ lệ sinh trung bình của mỗi phụ nữ và tuổi thọ trung bình trên cùng một miền giá trị của trục tọa độ. Giá trị trên trục tọa độ được định nghĩa lại bằng các tham số breaks và labels. Hình bên trái: dữ liệu của năm 1960. Hình bên phải: dữ liệu của năm 2011"}
p1<-gapminder%>%filter(year==1960)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 1960")+
  scale_x_continuous(limits = c(1,9),
                     breaks = c(2,4,6,8),
                     labels = paste(c(2,4,6,8),"trẻ em"))+
  scale_y_continuous(limits = c(25,85),
                     breaks = c(10,30,50,70,90),
                     labels = paste(c(10,30,50,70,90),"tuổi"))+
  theme_minimal()
p2<-gapminder%>%filter(year==2010)%>%
  ggplot(aes(fertility,life_expectancy))+
  geom_point(size = 2, shape = 21, fill = "grey40", alpha = 0.5,color = "blue")+
  ggtitle("Năm 2010")+
  scale_x_continuous(limits = c(1,9),
                     breaks = c(2,4,6,8),
                     labels = paste(c(2,4,6,8),"trẻ em"))+
  scale_y_continuous(limits = c(25,85),
                     breaks = c(10,30,50,70,90),
                     labels = paste(c(10,30,50,70,90),"tuổi"))+
  theme_minimal()
grid.arrange(p1,p2,nrow=1,ncol=2)
```

Khi một trong hai biến liên tục là biến kiểu thời gian thì hàm số sử dụng để kiểm soát giá trị hiển thị là `scale_x_date()` với hai tham số thường được sử dụng là $date\_break$ và $date\_labels$. Cách sử dụng của các tham số này tương tựng như các tham số `breaks` và `labels`. Chúng ta sẽ mô tả biến số lượng hành khách trung bình từng tháng được lưu trong dữ liệu $\textbf{AirPassengers}$ theo một biến thời gian bắt đầu từ tháng 01 năm 1949.

```{r fgggplot31, warning=FALSE, message=FALSE, fig.cap = "Số lượng hành khách trung bình theo tháng dữ liệu AirPassenger. Hình bên trái: không sử dụng scale_x_date. Hình bên phải: sử dụng scale_x_date để hiển thị tốt hơn giá trị ngày tháng trên trục x"}
dat0<-data.frame(Number_Passengers = AirPassengers,
                Month = seq(as.Date("1949-01-01"), by = "month", length.out = 144))
p1<-dat0%>%ggplot(aes(x = Month, y = Number_Passengers))+
  geom_line() + ggtitle("Không sử dụng scale")+
  theme_minimal()
p2<-dat0%>%ggplot(aes(x = Month, y = Number_Passengers))+
  geom_line()+ ggtitle("Sử dụng scale_x_date()")+
  scale_x_date(date_break = "2 years", date_labels = "%b\n%Y" )+
  scale_y_continuous(breaks = seq(100,600,length=6))+
  theme_minimal()

grid.arrange(p1,p2,nrow=1,ncol=2)
```

Khi giá trị trên trục $x$ hoặc trục $y$ là các giá trị rời rạc, các hàm số sử dụng để kiểm soát ánh xạ thẩm mỹ từ các biến đến các trục tọa độ là các hàm `scale_x_discrete()` và `scale_y_discrete()`. Các tham số thường sử dụng bao gồm `limits` và `labels`. Tham số `limits` được sử dụng để cho biết các giá trị nào của biến rời rạc xuất hiện trên đồ thị, trong khi tham số `labels` cho biết từng giá trị của biến rời rạc xuất hiện như thế nào

```{r fgggplot32, warning=FALSE, message=FALSE, fig.cap = "Phân phối của biến tỷ lệ số vụ xả súng trên một triệu người dân theo vùng vào năm 2010 tại Mỹ. Hình bên trái: không sử dụng scale. Hình bên phải: sử dụng limits trên trục y và labels trên trục x cho hiển thị tốt hơn"}
# Không sử dụng scale
p1<-murders%>%mutate(rate = total/population*10^6)%>%
  ggplot(aes(reorder(region,rate),rate))+
  geom_boxplot(fill = "grey40", color = "blue", alpha = 0.5)+
  ggtitle("Không sử dụng scale")+
  theme_minimal()+xlab("")

# Sử dụng tham số labels cho trục x
# và sử dụng limits cho trục y
p2<-murders%>%mutate(rate = total/population*10^6)%>%
  ggplot(aes(reorder(region,rate),rate))+
  geom_boxplot(fill = "grey40", color = "blue",alpha = 0.5)+
  scale_y_continuous(limits = c(0,50))+
  # Thay thế giá trị hiển thị trên trục số bằng labels
  scale_x_discrete(labels = c("Northeast" = "Đông Bắc",
                              "West" = "Miền Tây",
                              "South" = "Miền Nam",
                              "North Central" = "Miền Bắc"))+
  ggtitle("Sử dụng limits và labels")+
  theme_minimal()+xlab("")
grid.arrange(p1,p2,nrow=1,ncol=2)
```


### Màu sắc hiển thị
Thuộc tính thẩm mỹ được sử dụng phổ biến nhất là màu sắc. Có nhiều cách để ánh xạ giá trị của biến tới màu sắc trong thư viện $\textbf{ggplot2}$. Vì màu sắc là một chủ đề phức tạp nên chúng tôi sẽ bắt đầu bằng thảo luận sơ lược về lý thuyết màu sắc. Sau đó chúng tôi sẽ giới thiệu đến bạn đọc về thang màu liên tục, thang màu rời rạc và thang màu tổng hợp được sử dụng để ánh xạ đến các biến rời rạc, biến liên tục trong trực quan hóa dữ liệu. Chúng tôi cũng sẽ đề cập đến cả các thang màu dành cho biến kiểu thời gian, kiểu ngày tháng, độ trong của các màu sắc hiển thị và nguyên tắc chú giải cho màu sắc được thiết lập trong các đồ thị $\textbf{ggplot2}$.

#### Cảm nhận của con người về màu sắc
Trong vật lý, màu sắc được tạo ra bởi hỗn hợp các bước sóng ánh sáng. Để mô tả đầy đủ về một màu sắc, chúng ta cần biết sự kết hợp chính xác của các bước sóng. Sự thật thì mắt con người chỉ có ba cơ quan cảm nhận màu sắc khác nhau, và vì vậy chúng ta có thể tóm tắt khả năng cảm nhận về bất kỳ màu nào chỉ bằng ba con số. Một không gian màu quen thuộc với bạn đọc là không gian màu RGB, không gian mà mọi màu sắc được xác định theo cường độ ánh sáng đỏ, xanh da trời và xanh lá cây để tạo ra màu đó. Ưu điểm của không gian màu này là sự đơn giản do mỗi màu sắc đều được mô tả bằng ba con số từ 0 đến 255 hoàn toàn độc lập với nhau. Một vấn đề với không gian này là các dải màu liên tục nhận được bằng cách tăng giảm các cường độ màu đỏ, xanh lá cây, xanh dương lại không giống như cách nhận thức về màu sắc của còn người. Khi nhìn vào một màu cụ thể, chúng ta không thể ước tính được cường độ mỗi màu là bao nhiêu, điều này có thể gây khó khăn cho việc tạo ánh xạ từ một biến liên tục sang một dải màu.

Mỗi khi hiển thị một giá trị màu sắc trong không gian RGB, R thường sử dụng ký tự có 6 chữ số trong hệ 16 (từ 0 đến F) và bắt đầu bằng một dấu '#' thay vì một véc-tơ ba chiều đại diện cho 3 sắc đỏ, xanh lá cây, và  xanh dương. Hai chữ số đầu đại diện cho sắc đỏ, 2 chữ số tiếp theo đại diện cho màu xanh lá cây và 2 chữ số cuối đại diện cho màu xanh dương. Chẳng hạn như "#FF0000" sẽ là màu đỏ, "#00FF00" là màu xanh lá cây và "#0000FF" là màu xanh dương.

Một không gian màu được chuyển đổi từ không gian RGB là không gian Lab trong đó L đại diện cho độ tương phản sáng-tối của màu sắc, trục tọa độ a và b cho biết các vị trí của màu trên hai trục: trục từ đỏ đến xanh dương và trục từ vàng đến xanh lá. Cải tiến từ không gian RGB sang không gian Lab giúp cho các dải màu sắc tương ứng hơn với khả năng nhận biết màu sắc của con người, tuy nhiên vẫn còn khoảng cách giữa không gian Lab với nhận thức màu sắc. Không gian Lab cũng có các ưu điểm riêng, do đó $\textbf{ggplot2}$ mặc định sử dụng không gian Lab khi nội suy tuyến tính các màu sắc nằm giữa hai màu bất kỳ khi chúng ta ánh xạ một biến liên tục lên thuộc tính thẩm mỹ màu sắc.

Một không gian màu khác có thể hạn chế vấn đề của không gian RGB là không gian màu HCL với ba thành phần màu: màu sắc (Hue), sắc độ (Chroma) và độ chói (Luminance):

- Màu sắc (Hue) nằm trong khoảng từ 0 đến 360 (một góc) và cho biết màu muốn hiển thị.

- Sắc độ là “độ tinh khiết” của một màu, nằm trong khoảng từ 0 (xám) đến mức tối đa thay đổi theo độ sáng.

- Độ sáng là độ sáng của màu, dao động từ 0 (đen) đến 1 (trắng).

Ba chiều có những đặc tính khác nhau. Tương tự như không gian màu Lab, màu sắc trong HCL được sắp xếp xung quanh một hình tròn và không được coi là có trật tự; ví dụ: màu xanh lá dường như không lớn hơn hay nhỏ hơn màu đỏ và màu xanh dương dường như không lớn hơn hay nhỏ hơn màu xanh lá. Ngược lại, cả sắc độ và độ sáng đều được coi là có trật tự: màu hồng được coi là nằm giữa màu đỏ và trắng, và màu xám được coi là nằm giữa màu đen và trắng. Tạo các thang màu sắc từ không gian HCL thường được dựa trên nguyên tắc cố định 2 tham số và thay đổi tham số còn lại. Do không gian màu HCL gần với nhận thức màu sắc của con người hơn nên các dải màu được tạo ra sẽ "cách đều" nhau hơn theo cách mà chúng ta nhận thức.

Xin được nhắc lại rằng màu sắc là một chủ để phức tạp mà phạm vi của nó vượt rất xa những gì mà chúng tôi đề cập ở trên. Bạn đọc nên tham khảo thêm các tài liệu chuyên ngành khoa học máy tính để có thể sử dụng màu sắc một cách hiệu quả nhất.

#### Dải màu liên tục
Dải màu liên tục được sử dụng để hiển thị giá trị của một biến liên tục trên bề mặt phẳng. Để kiểm soát màu sắc trong thư viện $\textbf{ggplot2}$, chúng ta sử dụng các hàm `scale_color_*()`. Lưu ý rằng các thuộc tính thẩm mỹ `color` và `fill` có thể được sử dụng song song với đa số các hình dạng đồ họa, do đó bất kỳ hàm `scale_color_*()` cũng có hàm `scale_fill_*()` tương ứng.

Dải màu liên tục thường được sử dụng cùng với các geom có hình dạng đồ họa cần màu sắc để phân biệt trên trên mặt phẳng như `geom_polygon()`, `geom_tile()` (hoặc `geom_raster()`), và `geom_bin2d()`. Mỗi khi chúng ta cho một biến liên tục ánh xạ đến thuộc tính thẩm mỹ màu sắc, thư viện $\textbf{ggplot2}$ sẽ tự động hiểu rằng chúng ta sử dụng dải màu liên tục để mô tả biến đó. 

Chúng ta sẽ làm quen với các dải màu liên tục thông qua trực quan hóa hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều với trung bình 0, phương sai 1 và hệ số tương quan $\rho = 0.8$. Lưu ý rằng hàm mật độ của hai biến ngẫu nhiên phân phối chuẩn $\mathcal{N}(0,1)$ với hệ số tương quan $\rho = 0.8$ được tính như sau
\begin{align}
f(x,y) = \cfrac{1}{2 \pi \sqrt{1-\rho^2}} \ \exp \left(- \cfrac{x^2 + y^2 - 2\rho x y}{1-\rho^2}  \right)
\end{align}

Đồ thị hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều được lưu trong đối tượng có tên `p` như dưới đây:
```{r, warning=FALSE,message=FALSE}
# tạo lưới điểm trên hình vuông [-2,2] * [2-,2]
n<-100
x<-rep(1:n,n)/n*4-2
y<-sort(x, decreasing = FALSE)
rho<-0.8
dat0<-data.frame(x=x,y=y,
                dens = 1/(2*pi*sqrt(1-rho^2)) * 
                  exp(-(x^2+y^2-2*rho*x*y)/(1-rho^2)))
p<-dat0%>%ggplot(aes(x,y,fill=dens))+geom_raster()+
  theme_minimal()
```

Phương pháp đơn giản nhất để kiểm soát ánh xạ thẩm mỹ từ một biến liên tục đến màu sắc là lựa chọn các dải màu liên tục có sẵn trong của thư viện $\textbf{ggplot2}$ hoặc có trong các thư viện bổ sung. Các dải màu có sẵn này đều được xây dựng để ngay cả những người gặp khó khăn trong phân biệt màu sắc cũng có thể cảm nhận được. Trong Hình \@ref(fig:fgggplot32) vẽ chúng tôi lựa chọn các dải màu sau: 1. Dải màu liên tục mặc định của thư viện $\textbf{ggplot2}$, 2. Dải màu liên tục viridis, 3. Dải màu liên tục distiller; và 4. Dải màu liên tục fermenter. Mỗi dải màu đều có tham số `palette` để lựa chọn dải các dải màu sắc phù hơpj

```{r fgggplot33, warning=FALSE,message=FALSE, fig.cap = "Hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều với hệ số tương quan bằng 0.8. Hình góc trên bên trái: dải màu liên tục mặc định của ggplot2. Hình góc trên bên phải: dải màu viridis với option = 'A'. Hình góc dưới bên trái: dải màu liên tục distiller với dải màu số 3. Hình góc dưới bên phải: dải màu liên tục fermenter với dải màu liên tục số 2"}
# tạo lưới điểm trên hình vuông [-2,2] * [2-,2]
p1<-p + scale_fill_continuous()+
  ggtitle("Màu mặc định") # sử dụng dải màu mặc định
p2<-p + scale_fill_viridis_c(option = "A")+ # Dải màu viridis liên tục
  ggtitle("Dải màu viridis")
p3<-p + scale_fill_distiller(palette = 3)+ # Dải màu distiller
  ggtitle("Dải màu distiller")
p4<-p + scale_fill_fermenter(palette = 2)+ # Dải màu fermenter
  ggtitle("Dải màu fermenter")
grid.arrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Để dải màu sắc liên tục có tính cá nhân hóa cao hơn, bạn đọc cần chỉ định thang màu sắc thay vì sử dụng các thang màu có sẵn như Hình \@ref(fig:fgggplot33). Các hàm `scale_*_gradient()` là một công cụ mạnh mẽ giúp bạn đọc thực hiện việc này. Bạn cần cung cấp các giá trị màu sắc tương ứng với giá trị bắt đầu của dải màu, giá trị kết thúc của dải màu, và có thể thêm một vài giá trị trung gian, thư viện $\textbf{ggplot2}$ sẽ nội suy tuyến tính ra các màu sắc thành một dải màu tương ứng với các giá trị mà bạn khai báo. Các hàm số có thể sử dụng để tạo dải màu liên tục bao gồm:

- `scale_fill_gradient()` tạo một thang màu liên tục giữa hai màu sắc mà bạn khai báo. Hai tham số được sử dụng để khai báo là giá trị bắt đầu và giá trị kết thúc của dải màu là tham số `low` và tham số `high`. Đây cũng chính là cách tạo dải màu liên tục mặc định của thư viện $\textbf{ggplot2}$: mỗi khi chúng ta sử dụng ánh xạ thẩm mỹ từ một biến liên tục đến thuộc tính màu sắc, thư viện $\textbf{ggplot2}$ sử dụng dải màu liên tục theo hàm số `scale_fill_gradient()` với giá trị tham số `low` là $"#132B43"$ và giá trị tham số `high` là $"#56B1F7"$. Không gian nội suy tuyến tính dải màu là không gian màu Lab.

- Một hàm số khác cũng được dùng để tạo một dải màu liên tục là `scale_fill_gradient2()`. Ngoài hai tham số `low` và `high` tương ứng với là hai điểm bắt đầu và kết thúc của thang màu, chúng ta cần khai báo thêm một màu ở giữa bằng tham số `mid`. Ngoài ra, chúng ta cần khai báo tham số `midpoint` để cho biết giá trị nào của biến liên tục tương ứng với màu được khai báo với tham số $mid$. Nếu không khai báo, tham số `midpoint` sẽ nhận giá trị mặc định là 0.

- Sau cùng, hàm `scale_fill_gradientn()` tạo một thang màu liên tục từ một véc-tơ chứa các màu sắc mà bạn đọc khai báo. Dải màu này bắt đầu từ màu sắc có vị trí đầu tiên trong véc-tơ, đi qua lần lượt các màu sắc được khai báo, và kết thúc ở màu sắc tương ứng với giá trị cuối cùng của véc-tơ.

```{r fgggplot34, warning=FALSE,message=FALSE, fig.cap = "Hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều với hệ số tương quan bằng 0.8. Hình góc trên bên trái: dải màu liên tục mặc định của ggplot2. Hình góc trên bên phải: dải màu liên tục bắt đầu từ xanh dương kết thúc ở đỏ. Hình góc dưới bên trái: dải màu liên tục bắt đầu tư xanh dương đi qua màu trắng và kết thúc ở màu đỏ. Hình góc dưới bên phải: dải màu liên tục bắt đầu từ xanh lá cây đi qua trắng, xanh dương và kết thúc ở màu vàng"}
p1<-p + ggtitle("Màu mặc định") # sử dụng dải màu mặc định
p2<-p + scale_fill_gradient(low = "blue", high = "red")+
  ggtitle("Dải màu từ xanh lam đến đỏ") # sử dụng dải màu từ xanh lam đến đỏ
p3<-p + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0.12)+
  ggtitle("Dải màu từ xanh lam đến đỏ điểm giữa là trắng")
p4<-p +  scale_fill_gradientn(colours = c("#00FF00","#FFFFFF","#0000FF", "#FFFF00"))+
  ggtitle("Dải màu đi qua nhiều điểm màu")
grid.arrange(p1,p2,p3,p4,nrow=2,ncol=2)
```

Cả ba hàm số kể trên đều nội suy tuyến tính trong không gian màu Lab để tạo ra các giải màu liên tục. Khi nói đến nội suy tuyến tính giữa hai màu sắc, sẽ dễ hiểu nếu chúng ta sử dụng không gian RGB mà tất cả các màu đều nằm trong một hình lập phương với điểm (0,0,0) là màu đen, (1,1,1) là màu trắng... Bạn đọc có thể hiểu như sau: trong mỗi không gian mỗi màu sắc hiển thị có ba thành phần là cường độ màu đỏ (r), cường độ màu xanh lá (g) cường độ màu xanh lam (b) ... Một dải màu bao gồm $n$ màu, bắt đầu từ màu $m_1$ bao gồm các thành phần $(r_1, g_1, b_1)$, đến màu $m_n$ với thành phần $(r_n, g_n, b_n)$ sẽ là các màu $m_i$ có các thành phần tương ứng
\begin{align}
r_i = \left[r_1 + (i-1) * \cfrac{r_n - r_1}{(n-1)} \right] \\
g_i = \left[g_1 + (i-1) * \cfrac{g_n - g_1}{(n-1)} \right] \\
b_i = \left[b_1 + (i-1) * \cfrac{b_n - b_1}{(n-1)} \right]
\end{align}

Đáng tiếc là trong không gian Lab việc nội suy màu sắc không đơn giản như vậy. Việc nội suy dựa trên các tính toán phức tạp và kết quả cuối cùng là các công thức gần đúng. Ưu điểm của nội suy màu sắc trong không gian Lab so với không gian RGB sự chuyển đổi màu sắc giữa các điểm mượt mà hơn rất nhiều trong cách nhận biết màu sắc của con người.

Hàm số để nội suy một véc-tơ màu rời rạc từ hai màu sắc bất kỳ trên không gian RGB hoặc không gian Lab là hàm `colorRampPalette()` của thư viện $\textbf{grDevices}$. Ví dụ, chúng ta nội suy một véc-tơ màu bắt đầu từ màu xanh dương và kết thúc ở màu cam như sau
```{r, warning=FALSE,message=FALSE}
n<-200
my_rgb_palette<-colorRampPalette(c("blue", "orange"),space = "rgb")(n+1)
my_lab_palette<-colorRampPalette(c("blue", "orange"),space = "Lab")(n+1)
```

Để so sánh cách nội suy dải màu trên không gian RGB và không gian Lab, chúng ta sẽ sử dụng hai dải màu kể trên mô tả hàm mật độ xác suất của biến phân phối chuẩn hai chiều. Do các hàm `scale_fill_gradient()` luôn nội suy trên không gian Lab nên để hiển thị dải màu RGB, chúng tôi rời rạc hóa giá trị mật độ hàm mật độ trước khi ánh xạ đến dải màu rời rạc được tạo ra từ hàm `colorRampPalette()`

```{r fgggplot35, warning=FALSE,message=FALSE, fig.cap = "Hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều với hệ số tương quan bằng 0.8. Hình bên trái: dải màu nội suy trên không gian RGB. Hình bên phải: dải màu nội suy trên không gian Lab"}

x<-rep(1:n,n)/n*4-2
y<-sort(x, decreasing = FALSE)
rho<-0.8
dat0<-data.frame(x=x,y=y,dens = 1/(2*pi*sqrt(1-rho^2)) * exp(-(x^2+y^2-2*rho*x*y)/(1-rho^2)))
h<-(max(dat0$dens)-min(dat0$dens))/n
dat0<-mutate(dat0,dens.d = round((dens - min(dat0$dens))/h))
dat0$dens.d<-as.factor(dat0$dens.d)

mycol<-colorRampPalette(c("blue", "orange"),space = "rgb")(n+1)
p1<-dat0%>%ggplot(aes(x,y,fill=dens.d))+geom_raster()+theme_minimal()+
  scale_fill_manual(values= mycol)+
  theme(legend.position = "none")+
  ggtitle("Nội suy trên RGB")

mycol<-colorRampPalette(c("blue", "orange"),space = "Lab")(n+1)
p2<-dat0%>%ggplot(aes(x,y,fill=dens.d))+geom_raster()+theme_minimal()+
  scale_fill_manual(values= mycol)+
  theme(legend.position = "none")+
  ggtitle("Nội suy trên Lab")
grid.arrange(p1,p2,ncol=2,nrow=1)
```

Cả hai hình đều sử dụng dải màu liên tục từ xanh dương đến cam để mô tả mật độ của phân phối chuẩn hai chiều có hệ số tương quan $\rho=0.8$. Bạn đọc có thể thấy rằng việc chuyển hóa màu sắc trên không gian màu Lab tự nhiên với mắt quan sát hơn so với không gian RGB. Đây là lý do tại sao các dải màu liên tục của thư viện $\textbf{ggplot2}$ luôn sử dụng không gian Lab để nội suy màu sắc.

Các tham số `limits`, `breaks`, và `label` cũng có thể được sử dụng trong các hàm `scale_fill_*()` và `scale_color_*()` để kiểm soát các thang màu liên tục. Tham số `limits` nhận giá trị là một véc-tơ hai phần tử, phần tử thứ nhất cho biết màu sắc bắt đầu trong thang màu tương ứng với giá trị nào trong biến liên tục và phần tử thứ hai cho biết màu sắc kết thúc của thang màu ứng với giá trị nào của biến liên tục. Trong khi các tham số `breaks` và `labels` được sử dụng để thay đổi giá trị trên thang màu của chú giải.

```{r fgggplot36, warning=FALSE,message=FALSE, fig.cap = "Hàm mật độ của biến ngẫu nhiên phân phối chuẩn hai chiều với hệ số tương quan bằng 0.8. Hình bên trái: sử dụng tham số limits trong scale_fill_gradient. Hình bên phải: sử dụng limits, breaks và labels trong scale_fill_gradient"}
# limits cho biết hai giá trị tương ứng với điểm đầu và cuối của dải màu
p1<-p + scale_fill_gradient(low = "blue", high = "orange",
                            limits = c(0,0.8))+
  ggtitle("Tham số limits")
# breaks cho biết các giá trị nào xuất hiện trên chú giải
# labels cho biết giá trị hiển thị trong chú giải
p2<-p + scale_fill_gradient(low = "blue", high = "orange",
                            limits = c(0,0.3),
                            breaks = c(0.1,0.15,0.25),
                            labels = paste("Density at", c(0.1,0.15,0.25)))+
  ggtitle("Tham số breaks và labels")
grid.arrange(p1,p2,nrow=1,ncol=2)
```

Đồ thị bên trái của Hình \@ref(fig:fgggplot36) sử dụng giá trị của tham số `limits` là từ 0 đến 0.8 trong khi giá trị lớn nhất của các hàm mật độ chỉ khoảng 0.3. Màu bắt đầu của dải màu là màu xanh dương tương ứng với giá trị thứ nhất của tham số `limits` là 0 và màu kết thúc của dải màu là màu cam tương ứng với giá trị thứ hai của tham số limit là 0.8. Điều này giải thích tại sao cả các giá trị nằm trong tâm của hình ellipse màu sắc cũng chưa chuyển thành màu cam. Đồ thị bên phải của Hình \@ref(fig:fgggplot36) sử dụng tham số `limits` từ 0 đến 0.3 nên các giá trị càng nằm gần tâm đường ellipse càng chuyển sang màu cam. Tham số `breaks` thay đổi các vị trí giải thích thang màu trên chú giải của thuộc tính màu sắc, trong khi tham số `labels` kiểm soát cách hiển thị tại các vị trí trên thang màu.

#### Dải màu rời rạc
Dải màu rời rạc dùng để mô tả thuộc tính thẩm mỹ màu sắc khi ánh xạ đến các biến rời rạc. Hàm số dùng để kiểm soát màu sắc rời rạc của thư viện $\textbf{ggplot2}$ là các hàm `scale_fill_discrete()` và `scale_color_discrete()`. Mỗi khi sử dụng các hàm số kể trên, thư viện $\textbf{ggplot2}$ sẽ mặc định sử dụng dải màu rời rạc cách đều nhau trong không gian màu HCL. Dải màu mặc định này có cùng sắc độ (Chromes hay còn gọi là tham số $c$), độ sáng (Luminance hay còn gọi là tham số $l$) và giá trị $h$ cách đều nhau từ góc 15 độ ($h$ nhận giá trị từ 0 đến 360 độ). Bạn đọc muốn sử dụng các dải màu rời rạc trong không gian HCL để ánh xạ tới biến rời rạc thì có thể sử dụng các hàm `scale_fill_hue()` và `scale_color_hue()` thay thể cho `scale_fill_discrete()` và `scale_color_discrete()`.

```{r fgggplot37, warning=FALSE,message=FALSE, fig.cap = "Mô tả phân phối của biến continent trong dữ liệu Gapminder năm 2011. Hình bên trái: Sử dụng dải màu rời rạc mặc định. Hình ở giữa: sử dụng dải màu rời rạc trong không gian HCL với tham số h thay đổi. Hình bên phải: sử dụng dải màu rời rạc trong không gian HCL với tham số c thay đổi"}
p1<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+
  geom_bar()+ggtitle("Màu rời rạc mặc định")+
  theme_minimal()
p2<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_hue(h=c(0,360)+15+360/5)+
  ggtitle("Thay đổi tham số h")+theme_minimal()
p3<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_hue(c=30)+ggtitle("Thay đổi tham số c")+theme_minimal()
grid.arrange(p1,p2,p3,nrow=1,ncol=3)
```

Dải màu mặc định đối với biến rời rạc sử dụng tham số $c$ bằng 100 và tham số $l$ bằng 65 trong khi tham số $h$ nhận các giá trị cách đều nhau, bắt đầu từ $h = 15$ (độ). Lưu ý rằng $h$ nhận giá trị từ 0 độ đến 360 độ nên trong trường hợp biến rời rạc có năm giá trị, các màu sắc sẽ lần lượt nhận các giá trị $h = 15$, $15 + 360/5$, $15 + 2 \times 360/5$, $15 + 3 \times 360/5$ và $15 + 4 \times 360/5$. Đó là màu sắc của các thanh trong đồ thị bên trái của Hình \@ref(fig:fgggplot37) theo thứ tự từ trái qua phải. Trong đồ thị ở giữa, khi chúng ta sử dụng tịnh tiến giá trị $h$ thêm 360/5 (độ), chúng ta có thể thấy các màu sắc bắt đầu từ $h = 15 + 360/5$ và kết thúc ở $h = 15$. Nghĩa là màu sắc thứ nhất trong đồ thị bên trái đã trở thành màu thứ năm trong đồ thi ở giữa. Trong đồ thị bên phải, chúng tôi giảm độ chói (tham số $c$) xuống còn 40. Chúng ta có thể thấy dải màu vẫn tương tự như hai đồ thị còn lại nhưng không đạt được độ sáng như vậy.

Bạn đọc cũng có thể sử dụng các dải màu rời rạc được thiết kế sẵn cho mục đích trực quan hóa các biến rời rạc. Dải màu rời rạc mà chúng tôi thường sử dụng là dải màu brewer. Những dải màu này được thiết kế để hoạt động tốt trong nhiều tình huống khác nhau kể cả đối với những người khó khăn khi nhận biết màu sắc hay khi sử dụng để hiển thị trên những bề mặt lớn. Hàm số để kiểm soát ánh xạ thẩm mỹ màu sắc sử dụng dải màu brewer là `scale_color_brewer()` và `scale_fill_brewer()`. Bạn đọc cần cài đặt thư viện $\textbf{RColorBrewer}$ để sử dụng được các hàm này. Để xem các dải màu có sẵn trong thư viện này, bạn đọc sử dụng câu lệnh sau
```{r, warning=FALSE, message=FALSE, eval=FALSE}
display.brewer.all()
```

Tham số `palette` trong hàm `scale_color_brewer()` được sử dụng để lựa chọn dải màu:
```{r fgggplot38, warning=FALSE,message=FALSE, fig.cap = "Mô tả phân phối của biến continent trong dữ liệu Gapminder năm 2011 sử dụng dải màu brewer. Hình bên trái: sử dụng dải màu Dark2. Hình ở giữa: sử dụng dải màu Set1. Hình bên phải: sử dụng dải màu Spectral"}
p1<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_brewer(palette = "Dark2")+
  ggtitle("Sử dụng dải màu Dark2")+
  theme_minimal()
p2<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_brewer(palette = "Set1")+
  ggtitle("Sử dụng dải màu Set1")+
  theme_minimal()
p3<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_brewer(palette = "Spectral")+
  ggtitle("Sử dụng dải màu Spectral")+
  theme_minimal()
grid.arrange(p1,p2,p3,nrow=1,ncol=3)
```

Để tạo ra dải màu rời rạc theo ý muốn bạn đọc sử dụng các hàm `scale_fill_manual()` và `scale_color_manual()`. Tham số `values` được sử dụng để nhận giá trị là véc-tơ chứa màu sắc mà bạn đọc tự tạo. Số lượng phần tử trong véc-tơ phải tương ứng với số lượng phần tử trong biến rời rạc.

Như chúng tôi đã giới thiệu trong phần dải màu sắc liên tục, hàm số `colorRampPalette()` của thư viện $\textbf{grDevices}$ có thể được sử dụng để nội suy ra một véc-tơ màu rời rạc giữa hai giá trị màu cho trước. Ví dụ, để tạo ra một véc-tơ có độ dài 5, mỗi giá trị là một màu sắc được nội suy tuyến tính từ màu xanh dương đến màu cam chúng ta sử dụng `colorRampPalette()` như sau:
```{r, warning=FALSE, message=FALSE}
# nội suy trong RGB
mypalette1<-colorRampPalette(c("blue","orange"), space = "rgb")(5)
# nội suy trong Lab
mypalette2<-colorRampPalette(c("blue","orange"), space = "Lab")(5)
```

Các đồ thị trong Hình sử dụng các véc-tơ màu sắc rời rạc tự định nghĩa bằng cách liệt kê các màu sắc trong `scale_fill_manual()` và bằng nội suy tuyến tính trong không gian RGB và không gian Lab.
```{r fgggplot39, warning=FALSE,message=FALSE, fig.cap = "Mô tả phân phối của biến continent trong dữ liệu Gapminder năm 2011 sử dụng dải màu tự định nghĩa. Hình bên trái: dải màu tự định nghĩa bằng cách liệt kê tên các màu sắc. Hình ở giữa: nội suy trong không gian RGB giữa xanh dương và cam. Hình bên phải: nội suy trong không gian Lab giữa xanh dương và cam"}
p1<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_manual(values = c("blue","green","grey","yellow","orange"))+
  ggtitle("Màu tự định nghĩa")+
  theme_minimal()
p2<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_manual(values = mypalette1)+
  ggtitle("Màu nội suy trong RGB")+
  theme_minimal()
p3<-gapminder%>%filter(year==2011)%>%
  ggplot(aes(continent,fill=continent))+geom_bar()+
  scale_fill_manual(values = mypalette2)+
  ggtitle("Màu nội suy trong Lab")+
  theme_minimal()
grid.arrange(p1,p2,p3,nrow=1,ncol=3)
```

Cách sử dụng tham số `limits`, `breaks`, và `label` trong các hàm `scale_fill_manual()` và `scale_color_manual()` cũng tương tự như đối với dải màu liên tục.

- Tham số `limits` cho biết các giá trị nào trong biến rời rạc được ánh xạ tới dải màu sắc. 

- Tham số `breaks` cho biết các giá trị nào không được sử dụng trong ánh xạ thẩm mỹ. 

- Tham số `label` cho biết cách các màu sắc hiển thị trong phần chú giải. 

Theo kinh nghiệm của chúng tôi thì tham số `breaks` không có nhiều ý nghĩa khi sử dụng đối với dải màu sắc rời rạc, trong khi tham số `limits` có ý nghĩa quan trọng khi bạn đọc cần cố định ánh xạ màu sắc lên biến rời rạc khi vẽ nhiều biểu đồ khác nhau và để kiểm soát thứ tự xuất hiện của biến liên tục trên đồ thị. 

```{r fgggplot40, warning=FALSE, message=FALSE, fig.cap = "Dân số của ba nước Philippines, Việt Nam, và Indonesia trong top 10 nước đông dân nhất châu Á. Hình bên trái: Dữ liệu năm 1960. Hình bên phải: Dữ liệu năm 2011"}
p1<-gapminder%>%filter(year==1960, continent == "Asia")%>%
  arrange(-population)%>%head(10)%>%
  ggplot(aes(fill=country))+
  geom_bar(aes(x = population, y = reorder(country,population)),
           stat="identity",col="blue", alpha = 0.7)+
  ylab("")+ggtitle("Năm 1960")+theme_minimal()+
  theme(legend.position = "top")+
  scale_x_continuous(labels = scales::comma)+
  scale_fill_manual(values = c("blue","red","yellow"), limits = c("Philippines","Vietnam", "Indonesia"))
p2<-gapminder%>%filter(year==2011, continent == "Asia")%>%
  arrange(-population)%>%head(10)%>%
  ggplot(aes(fill=country))+
  geom_bar(aes(x = population, y = reorder(country,population)),
           stat="identity",col="blue", alpha = 0.7)+
  ylab("")+ggtitle("Năm 2010")+theme_minimal()+theme(legend.position = "top")+
  scale_x_continuous(labels = scales::comma)+
  scale_fill_manual(values = c("blue","red","yellow"), limits = c("Philippines","Vietnam", "Indonesia"))

grid.arrange(p1,p2,nrow=1,ncol=2)
```

Chúng ta sử dụng tham số `limits` để cố định màu sắc tương ứng với các giá trị của biến rời rạc như trong Hình \@ref(fig:fgggplot40). Bạn đọc có thể dễ dàng nhận ra sự thay đổi về thứ hạng về quy mô dân số của ba 3 quốc gia Philippines, Việt Nam, và Indonesia trong nhóm 10 nước có dân số lớn nhất châu Á trong các năm 1960 và 2010.

### Các thuộc tính thẩm mỹ khác
Ngoài vị trí trên các trục tọa độ và màu sắc, còn có một số thuộc tính thẩm mỹ khác mà thư viện $\textbf{ggplot2}$ có thể sử dụng để mô tả dữ liệu. Trong phần này, chúng ta sẽ xem xét thuộc tính kích thước (size), hình dạng (shape), chiều rộng của line và kiểu line, sử dụng cùng với các thuộc tính vị trí và màu sắc để thể hiện tốt nhất các biến trong dữ liệu. Ngoài đề cập đến các giá trị mặc định, chúng tôi cũng sẽ thảo luận về các hàm số để bạn đọc có thể sử dụng để kiểm soát tốt các thuộc tính này.

#### Thuộc tính thẩm mỹ kích thước
Thuộc tính thẩm mỹ kích thước thường được sử dụng để mô tả hình dạng đồ họa kiểu điểm hoặc ký tự. Như chúng tôi đã đề cập trong phần giới thiệu, thuộc tính kích thước thường được sử dụng với biến liên tục. Nếu không có hàm kiểm soát ánh xạ thẩm mỹ, bán kính của điểm tương ứng với giá trị nhỏ nhất luôn là 1 và bán kính của điểm có giá trị lớn nhất luôn là 6, nghĩa là có bán kính gấp 6 lần bán kính của điểm nhỏ nhất. Khi nội suy ra kích thước của các điểm khác, thư viện $\textbf{ggplot2}$ mặc định cho kích thước của điểm là diện tích của hình tròn mô tả điểm đó chứ không phải đường kính của hình tròn. Kích thước của điểm sẽ phụ thuộc vào thứ hạng (rank) của giá trị đó trong biến liên tục chứ không được tính bằng giá trị thực của điểm đó. Nếu $area_m$ là diện tích của hình tròn tương ứng với giá trị nhỏ nhất và $area_M$ tương ứng với diện tích của hình tròn tương ứng với giá trị lớn nhất thì diện tích của hình tròn tương ứng với giá trị có thứ hạng $k$ trong tổng số $n$ giá trị của biến liên tục là
\begin{align}
area = area_m + (k-1) \times \cfrac{area_M - area_m}{n - 1}
\end{align}

Để hiểu về cách thư viện $\textbf{ggplot2}$ ánh xạ kích thước đến giá trị các biến, bạn đọc có thể quan sát kích thước của các hình tròn trong Hình \@ref(fig:fgggplot41)
```{r fgggplot41, warning=FALSE, message=FALSE, fig.cap = "Ánh xạ các số tự nhiên đến thuộc tính thẩm mỹ kích thước. Hình bên trái: ánh xạ các số 1, 2, 3 đến kích thước ba hình tròn. Hình ở giữa: ánh xạ bình phương của 1, 2, 3 đến kích thước các hình tròn. Hình bên phải: ánh xạ hai số 2 và 3 đến kích thước của hai hình tròn."}
dat0<-data.frame(x=1:3,y=1:3,z=1:3)
# Hình bên trái
p1<-dat0%>%ggplot(aes(x,y,size=z))+geom_point(shape=21,fill= "blue",alpha = 0.5)+
  theme(legend.position = "none")
# Hình ở giữa
p2<-dat0%>%ggplot(aes(x,y,size=z^2))+geom_point(shape=21,fill= "blue",alpha = 0.5)+
  theme(legend.position = "none")
# Hình bên phải
p3<-dat0%>%filter(z>1)%>%ggplot(aes(x,y,size=z))+geom_point(shape=21,fill= "blue",alpha = 0.5)+
  theme(legend.position = "none")
grid.arrange(p1,p2,p3,ncol=3,nrow=1)
```

Từ Hình \@ref(fig:fgggplot41) có thể thấy rằng:

- Đồ thị bên trái: kích thước của các hình tròn ở các tọa độ (1,1), (2,2), và (3,3) được ánh xạ đến các giá trị số 1, 2, và 3. Tham số mặc định của hàm `scale_size_*()` là `range = c(1,6)` nên hình tròn tại vị trí (1,1) có bán kính là 1 trong khi hình tròn ở vị trí (3,3) có bán kính là 6.  Diện tích của hình tròn nằm ở tọa độ (2,2) bằng trung bình cộng diện tích của hình tròn nằm ở vị trí (1,1) và (3,3). Do diện tích của hình tròn nằm ở vị trí (3,3) bằng $6^2 = 36$ lần diện tích của hình tròn tại vị trí $(1,1)$ nên diện tích của hình tròn tại (2,2) bằng $\cfrac{36+1}{2} = 18,5 \textit{(lần)}$ diện tích hình tròn tại tọa độ (1,1), hay nói cách khác đường kính của hình tròn tại vị trí (2,2) bằng $\sqrt{18,5} \sim 4,3 \text{ (lần)}$ đường kính của hình tròn tại vị trí (1,1). 

- Đồ thị ở giữa: chúng ta ánh xạ thuộc tính thẩm mỹ kích thước với $z^2$, nghĩa là $1^2$, $2^2$, và $3^2$ thì kích thước các hình tròn xuất hiện vẫn không hề thay đổi so với hình bên trái. Nguyên nhân là thư viện $\textbf{ggplot2}$ sử dụng thứ hạng của các giá trị trong véc-tơ số chứ không sử dụng giá trị thực. Thứ hạng của $1^2$, $2^2$, và $3^2$ vẫn là 1, 2, và 3 nên kích thước của các hình xuất hiện vẫn không thay đổi

- Đồ thị bên phải: khi chúng ta chỉ vẽ hai điểm tại vị trí (2,2) và (3,3) với kích thước được ánh xạ vào hai số là 2 và 3 thì diện tích hình tròn nhỏ nhất và hình tròn lớn nhất vẫn không thay đổi.

Hàm số dùng để kiểm soát giá trị của ánh xạ thẩm mỹ kích thước là hàm `scale_size()`. Để thay đổi miền giá trị của thuộc tính kích thước, chúng ta sử dụng tham số `range`.

```{r fgggplot42, warning=FALSE, message=FALSE, fig.cap = "Ánh xạ các số tự nhiên đến thuộc tính thẩm mỹ kích thước. Hình bên trái: ánh xạ các số 1, 2, 3 đến kích thước ba hình tròn. Hình bên phải: sử dụng scale_size để hình nhỏ nhất có bán kính bằng 6 và hình lớn nhất có bán kính bằng 24."}
dat0<-data.frame(x=1:3,y=1:3,z=1:3)
# Hình bên trái
p1<-dat0%>%ggplot(aes(x,y,size=z))+
  geom_point(shape=21,fill= "blue",alpha = 0.5)+
  theme(legend.position = "none")+
  theme_minimal()+ggtitle("Không sử dụng scale_size")
# Hình bên phải
p2<-dat0%>%ggplot(aes(x,y,size=z))+
  geom_point(shape=21,fill= "blue",alpha = 0.5)+
  scale_size(range=c(6,24))+
  theme(legend.position = "none")+
  theme_minimal()+ggtitle("Sử dụng scale_size với range = (6,24)")
grid.arrange(p1,p2,ncol=2,nrow=1)
```

Hình \@ref(fig:fgggplot42) mô tả cách sử dụng tham số `range` trong hàm `scale_size()`. 

- Đồ thị bên trái: bán kính của hình nhỏ nhất là 1, của hình lớn nhất là 6. 

- Đồ thị bên phải: bán kính của hình nhỏ nhất là 6 bằng với kích thước của hình lớn nhất của đồ thị bên trái. Và bán kính của hình lớn nhất là 24. Mặc dù tham số khai báo với `range` là bán kính của các hình, nhưng khi nội suy kích thước các hình có kích thước nằm giữa hình nhỏ nhất và hình lớn nhất, `scale_size()` lại luôn nội suy theo diện tích của các hình.

Trong trường hợp bạn đọc muốn sử dụng nội suy theo bán kính của điểm thay vì diện tích, hãy sử dụng hàm `scale_radius()` thay thế cho `scale_size()`. Hình \@ref(fig:fgggplot43) mô tả sự khác nhau khi sử dụng `scale_size()` và `scale_radius()`:

```{r fgggplot43, warning=FALSE, message=FALSE, fig.cap = "Sự khác nhau giữa ánh xạ kích thước bằng scale_size và scale_radius. Hình bên trái: sử dụng scale_size với range = c(1,7). Hình ở giữa: sử dụng scale_radius với range = c(1,7). Hình bên phải: sử dụng scale_size với range = c(4,10)"}
dat0<-data.frame(x=1:3,y=1:3,z=1:3)
# Hình bên trái
p1<-dat0%>%ggplot(aes(x,y,size=z))+
  geom_point(shape=21,fill= "blue",alpha = 0.5)+
  theme(legend.position = "none")+
  scale_size(range = c(1,7))

p2<-dat0%>%ggplot(aes(x,y,size=z))+
  geom_point(shape=21,fill= "blue",alpha = 0.5)+
  scale_radius(range=c(1,7))+
  theme(legend.position = "none")
# Hình bên phải
p3<-dat0%>%ggplot(aes(x,y,size=z))+
  geom_point(shape=21,fill= "blue",alpha = 0.5)+
  scale_radius(range=c(4,10))+
  theme(legend.position = "none")
grid.arrange(p1,p2,p3,ncol=3,nrow=1)
```

- Đồ thị bên trái sử dụng scale theo diện tích và bán kính hình tròn lớn nhất bằng 7 lần đường tròn nhỏ; hình tròn ở giữa có bán kính bằng $\sqrt{\cfrac{7^2+1^2}{2}} = 5 \text{ (lần)}$ bán kính hình tròn nhỏ nhất. 

- Đồ thị ở giữa, do scale theo bán kính hình tròn nên hình ở giữa có bán kính bằng $\cfrac{7+1}{2} = 4 \textit{ (lần)}$ bán kính hình tròn nhỏ. Bạn đọc có thể thấy rằng kích thước của hình tròn ở vị trí (2,2) trong đồ thị ở giữa nhỏ hơn hình tròn ở vị trí tương ứng trong hình bên trái.

- Trong đồ thị bên phải, bán kính của hình nhỏ nhất là 4, của hình tròn lớn nhất là 10, nên bán kính hình ở giữa là $\cfrac{4+10}{2} = 7$ do nội suy bằng hàm `scale_radius()`. Bạn đọc có thể thấy rằng kích thước của hình ở vị trí (2,2) của đồ thị này bằng với kích thước của hình tròn ở vị trí (3,3) của hình ở giữa.

Các tham số `limits`, `breaks`, và `label` được sử dụng tương tự như thuộc tính thẩm mỹ màu sắc:

- Tham số `limits` cho biết miền giá trị nào của biến được ánh xạ đến thuộc tính thẩm mỹ size. 

- Tham số `breaks` cho biết các giá trị nào của kích thước nào xuất hiện trên chú giải.

- Tham số `labels` mô tả thuộc tính thẩm mỹ kích thước trên chú giải của đồ thị.

```{r fgggplot44, warning=FALSE, message=FALSE, fig.cap = "Tuổi thọ trung bình và tỷ lệ trẻ sơ sinh tử vong của các quốc gia trên thế giới năm 2011"}
dat%>%
  ggplot(aes(infant_mortality,life_expectancy, size = population))+
  geom_point(shape = 21, fill = "blue",alpha = 0.5)+
  scale_size(range = c(1,12),
             limits = c(10^7,max(gapminder$population)),
             breaks = c(10^8,2*10^8,5*10^8,10^9),
             labels = c(paste(c(10^8,2*10^8,5*10^8)/10^6,"triệu"), "Một tỷ"))
```
Hình \@ref(fig:fgggplot44) mô tả ba biến liên tục là tuổi thọ trung bình, tỷ lệ trẻ sơ sinh tử vong và dân số của các quốc gia trên thế giới vào năm 2011. Biến dân số được ánh xạ đến thuộc tính thẩm mỹ kích thước của các điểm. Ánh xạ này được điều chỉnh bằng hàm `scale_size()` như sau

- Tham số `range = c(1,12)` cho biết bán kính của hình tròn tương ứng với nước có dân số nhỏ nhất bằng 1 và bán kính của hình tròn tương ứng với nước có dân số lớn nhất là 12.

- Tham số `limits` cho biết chỉ các nước có dân số 10 triệu trở lên được đưa vào trong đồ thị.

- Tham số `breaks` cho biết các giá trị xuất hiện trên chú giải là các giá trị 100 triệu, 200 triệu, 500 triệu và 1 tỷ.

- Tham số `labels` cho biết các số viết trên chú giải sử dụng cách viết giá trị lên chú giải là theo đơn vị triệu.


#### Thuộc tính thẩm mỹ hình dạng
Hình dạng thường được sử dụng để mô tả một biến rời rạc có không quá nhiều giá trị riêng biệt. Theo kinh nghiệm của chúng tôi thì hình dạng chỉ nên sử dụng với các biến có nhỏ hơn năm giá trị riêng biệt. Mặc dù thư viện $\textbf{ggplot2}$ cho phép sử dụng lên đến hơn 20 hình dạng khác nhau, nhưng sử dụng nhiều hơn hoặc bằng năm hình dạng trong một đồ thị sẽ làm cho đồ thị trở nên rắc rối và khó khăn khi nhận diện. Tại phiên bản $\textbf{ggplot2}$ mà chúng tôi đang sử dụng, có 25 hình dạng khác nhau có thể dùng để mô tả biến rời rạc. Các hình dạng này được hiển thị bằng cách thiết lập tham số tương ứng với 25 số tự nhiên từ 1 đến 25 được mô tả trong Hình \@ref(fig:fgggplot45)

```{r fgggplot45, warning=FALSE, message=FALSE, fig.cap = "Các hình dạng có thể được sử dụng trong trực quan hóa dữ liệu của thư viện ggplot2"}
dat0<-data.frame(x=c(rep(1:10,2),1:5),y = c(rep(3,10),rep(2,10),rep(1,5)), z = 1:25)
dat0%>%ggplot(aes(x,y,shape=as.factor(z)))+geom_point(size=3)+
  scale_shape_manual(values = 1:25)+theme_classic()+geom_text(aes(label=z),vjust=-1)+
  theme(legend.position = "none")+
  theme_void()
```

Bạn đọc cần lưu ý rằng có một số hình dạng trông giống nhau nhưng lại có thuộc tính thẩm mỹ khác nhau. Chẳng hạn như hình dạng tương ứng với số 1 là một điểm hình tròn với thuộc tính thẩm mỹ `color` là màu sắc của toàn bộ hình tròn đó, trong khi hình dạng tương ứng với số 21 có thuộc tính thẩm mỹ `color` là màu viền bên ngoài của hình tròn và thuộc tính thẩm mỹ `fill` mới là màu sắc bên trong hình tròn.

Để kiểm soát ánh xạ thẩm mỹ đến thuộc tính hình dạng, bạn đọc sử dụng hàm `scale_shape_manual()`. Cách sử dụng hàm này như sau:
```{r fgggplot46,warning=FALSE, message=FALSE, fig.cap = "Thu nhập bình quân đầu người và tuổi thọ trung bình của các quốc gia châu Á vào năm 2011"}
gapminder%>%filter(year==2011, continent == "Asia")%>%
  ggplot(aes(gdp/population,life_expectancy, shape = region))+
  geom_point()+
  scale_x_continuous(trans="log10")+
  scale_shape_manual(values=c(21:24,8) )+
  theme_minimal()
```

Tham số được sử dụng để gán giá trị cho biến rời rạc đến hình dạng cụ thể là tham số `values` trong hàm  `scale_shape_manual()`. Nhìn chung, ánh xạ biến rời rạc đến thuộc tính thẩm mỹ hình dạng chỉ cho hiệu quả tốt khi dữ liệu không có quá nhiều quan sát và số lượng nhóm nhỏ. Trong trường hợp dữ liệu có nhiều quan sát và biến rời rạc nhận nhiều hơn năm giá trị khác nhau, bạn đọc nên thận trọng khi sử dụng thuộc tính thẩm mỹ này.

#### Kích thước và hình dạng của các đường
Đối với hình dạng đồ họa là các đường được vẽ bằng các hàm như `geom_line()`, `geom_path()` hay `geom_segment()`, chúng ta có thể ánh xạ các biến rời rạc vào độ rộng hoặc hình dạng của đường. Hình dạng và kích thước của các đường được sử dụng tương đương như hình dạng và kích thước của các điểm nên không có nhiều kiến thức để thảo luận trong phần này.

Hình \@ref(fig:fgggplot47) mô tả sự thay đổi của biến tổng thu nhập quốc dân ($gdp$) của ba quốc gia bao gồm Mỹ, Trung Quốc và Nhật Bản theo thời gian từ năm 1960 đến năm 2011 từ dữ liệu $\textbf{gapminder}$ bằng cách sử dụng ba kiểu vẽ đường khác nhau:

```{r fgggplot47,warning=FALSE, message=FALSE, fig.cap = "Tổng thu nhập quốc dân của Mỹ, Trung Quốc, và Nhật Bản từ năm 1960 đến 2011"}
gapminder%>%filter(country %in% c("United States", "China", "Japan"), year <= 2011)%>%
  ggplot(aes(x = year,y = gdp/10^9))+
  geom_line(aes(linetype = country))+
  theme_minimal()+
  ylab("GDP in Billion USD")+
  scale_x_continuous(breaks = seq(1960,2010,10))+
  scale_y_continuous(labels = scales::label_comma())
```

Hàm số dùng để kiểm soát ánh xạ thẩm mỹ vào hình dạng của các đường là `scale_linetype_manual()`. Thư viện $\textbf{ggplot2}$ có 13 hình dạng cho các đường được đánh số từ 1 đến 13 như Hình \@ref(fig:fgggplot48) dưới đây

```{r fgggplot48,warning=FALSE, message=FALSE, echo = FALSE, fig.cap = "Hình dạng của các đường có thể sử dụng để trực quan hóa dữ liệu trong thư viện ggplot2"}
df <- data.frame(value = as.factor(1:13))
p <- df%>%ggplot()+
  geom_segment(aes(x = 0, xend = 1, y = value, yend = value,linetype = value),show.legend = FALSE)+
  geom_label(aes(x = 0.5 ,y = value,label = value))+
  scale_linetype_manual(values = 1:13)+
  theme_void()+
  scale_y_discrete(limits = 13:1)
p
```

Để các đường có hình dạng như mong muốn, chúng ta gán giá trị tham số `values` trong hàm `scale_linetype_manual()` cho một véc-tơ chứa các số nhận giá trị từ 1 đến 13 tương ứng với hình dạng mà bạn lựa chọn.

```{r fgggplot49,warning=FALSE, message=FALSE, fig.cap = "Tổng thu nhập quốc dân của Mỹ, Trung Quốc, và Nhật Bản từ năm 1960 đến 2011"}
gapminder%>%filter(country %in% c("United States", "China", "Japan"), year <= 2011)%>%
  ggplot(aes(x = year,y = gdp/10^9))+
  geom_line(aes(linetype = country))+
  theme_minimal()+
  ylab("GDP in $B")+
  scale_x_continuous(breaks = seq(1960,2010,10))+
  scale_y_continuous(labels = scales::label_comma())+
  scale_linetype_manual(values = c(4,7,12))
```

## Tùy chỉnh chú giải của ánh xạ thẩm mỹ
Về mặt hình thức, nếu coi các hàm `scale_*()` như các ánh xạ từ tập hợp các giá trị của biến đến tập hợp các giá trị của thuộc tính thẩm mỹ thì chú giải là ánh xạ ngược từ thuộc tính thẩm mỹ đến miền giá trị của biến. Chú giải cho phép bạn chuyển đổi các thuộc tính trực quan trở lại giá trị của dữ liệu. Giá trị xuất hiện trên các trục tọa độ và các chú giải có cách hiển thị khác nhau nhưng về bản chất lại có cùng một mục đích là cho phép người tiếp nhận quan sát các hình ảnh đồ họa trực quan và ánh xạ chúng trở lại giá trị của dữ liệu. Các cấu phần khác nhau của chú giải được mô tả trong Hình \@ref(fig:fgggplot50)

```{r fgggplot50, warning=FALSE, message=FALSE, echo = FALSE, fig.cap = "Các thành phần và tên gọi của chú giải"}
knitr::include_graphics("../KHDL_KTKD Final/Image/Rplot01.PNG")
```

Chú giải có khả năng giải thích tốt hơn giá trị xuất hiện trên các trục tọa độ bởi các nguyên nhân sau

- Chú giải có thể giải thích nhiều biến cùng lúc trong khi giá trị trên trục tọa độ chỉ cho phép một biến.

- Chú giải có thể tùy biến dễ hơn: có thể xuất hiện ở các vị trí theo ý muốn của người xây dựng đồ thị, có thể xuất hiện theo bất kỳ hướng nào.

Bạn đọc hãy lưu ý rằng dù chúng ta không gọi bất kỳ hàm `scale_*()` nào trong các câu lệnh thì mỗi khi vẽ đồ thị, thư viện $\textbf{ggplot2}$ vẫn luôn luôn sử dụng một nhóm hàm `scale_*()` mặc định để ánh xạ từ giá trị của biến đến giá trị của thuộc tính thẩm mỹ. Mỗi khi bạn gọi hàm `scale_*()` để kiểm soát ánh xạ thẩm mỹ, các giá trị mà bạn khai báo sẽ thay thế cho các giá trị mặc định. Trong trường hợp bạn gọi nhiều hàm `scale_*()` tác động đến một thuộc tính thẩm mỹ thì chỉ có hàm `scale_*()` bạn gọi ra sau cùng được sử dụng.

```{r fgggplot51, warning=FALSE, message=FALSE, fig.cap = "Thu nhập bình quân đầu người của các quốc gia Đông Nam Á năm 2011"}
p<-gapminder%>%filter(year==2011,region=="South-Eastern Asia")%>%
  mutate(gdp_per_capita = gdp/population)%>%
  ggplot(aes(reorder(country,gdp_per_capita),gdp_per_capita,fill = country))+
  geom_bar(stat="identity")+
  theme_minimal()
p+scale_y_continuous(name = "Thu nhập bình quân đầu người", labels = scales::label_comma())+
  scale_x_discrete(name = "Country")+
  scale_y_continuous(trans = "sqrt")+
  scale_x_discrete(name = "Quốc gia", labels = c(
    "Vietnam" = "VN",
    "Thailand" = "TL",
    "Timor-Leste" = "Đông Timor"))+
  scale_y_continuous(name = "Thu nhập bình quân đầu người", labels = scales::label_dollar())
```

Đồ thị trong Hình \@ref(fig:fgggplot51) được vẽ bằng các câu lệnh có các hàm `scale_x_continuous()` được lặp lại 2 lần và `scale_y_continuous()` được lặp lại 3 lần. Quan sát kết quả, bạn đọc có thể thấy rằng chỉ có câu lệnh sau cùng được chấp nhận. Ngoài ra, khi thực thi đoạn lệnh ở trên, thư viện $\textbf{ggplot2}$ đưa ra các cảnh báo về các hàm `scale_*()` đã xuất hiện và sẽ bị thay thế bằng các hàm cùng tên.

Để kiểm soát chú giải của các ánh xạ thẩm mỹ, bạn đọc sử dụng tham số `guide` trong các hàm `scale_*()` tương ứng. Giá trị gán cho tham số `guide` là một trong các hàm số sau đây:

- Hàm `guide_axis()` là hàm số dùng để gán cho tham số `guide` khi chúng ta sử dụng các hàm `scale_*()` nhằm kiểm soát ánh xạ thẩm mỹ đến các trục tọa độ.

```{r fgggplot52, warning=FALSE, message=FALSE, fig.cap = "Thu nhập bình quân đầu người của các quốc gia Tây Âu năm 2011. Hàm guide_axis được sử dụng để kiểm soát chú giải cho các trục tọa độ x và y"}
gapminder%>%filter(year==2011,region=="Western Europe")%>%
  mutate(gdp_per_capita = gdp/population)%>%
  filter(!is.na(gdp_per_capita))%>%
  ggplot(aes(reorder(country,gdp_per_capita),gdp_per_capita,fill = country))+
  geom_bar(stat="identity")+
  theme_minimal()+
  scale_x_discrete(name = "Country",
                   guide = guide_axis(title = "Quốc gia",
                                      angle = 90))+
  scale_y_continuous(name = "GDP per capita", labels = scales::label_dollar(),
                     guide = guide_axis(title = "Thu nhập bình quân đầu người"))
```

Bạn đọc có thể thấy rằng tham số `title` trong hàm `guide_axis()` đã thay thế cho tham số `name` trong các hàm `scale_()`. Tham số `angle` cho biết hướng các giá trị xuất hiện trên trục tọa độ. Trong Hình \@ref(fig:fgggplot52), tên các quốc gia trên trục tọa độ x đã được xoay một góc 90 độ. Bạn đọc tham khảo hướng dẫn sử dụng hàm `guide_axis()` để hiểu về các tham số khác như `n.dodge`, `order`, hay `position`.

- Hàm `guide_legend()` là hàm số dùng để gán cho tham số `guide` khi gọi các hàm `scale_*()` kiểm soát ánh xạ từ các biến rời rạc đến màu sắc. Có rất nhiều tham số có thể sử dụng trong hàm số này. Bạn đọc tham khảo hướng dẫn sử dụng hàm để biết đầy đủ các tham số.

```{r fgggplot53, warning=FALSE, message=FALSE,fig.cap = "Thu nhập bình quân đầu người của các quốc gia Nam Mỹ năm 2011. Hàm guide_legend được sử dụng để kiểm soát chú giải cho ánh xạ thẩm mỹ màu sắc"}
gapminder%>%filter(year==2011,region=="South America")%>%
  mutate(gdp_per_capita = gdp/population)%>%
  filter(!is.na(gdp_per_capita))%>%
  ggplot(aes(reorder(country,gdp_per_capita),gdp_per_capita,fill = country))+
  geom_bar(stat="identity")+
  theme_minimal()+
  scale_x_discrete(guide = guide_axis(title = "Quốc gia",angle = 90))+
  scale_y_continuous(labels = scales::label_dollar(),
                     guide = guide_axis(title = "Thu nhập bình quân đầu người"))+
  scale_fill_brewer(palette = "Paired",
                    guide = guide_legend(title = "Quốc gia",title.position = "top",ncol = 2))
```

- `guide_colorbar()` được dùng khi chú giải cho các ánh xạ từ biến liên tục đến dải màu liên tục

- `guide_bin()` được dùng khi chú giải cho các ánh xạ từ biến liên tục đến thuộc tính thẩm mỹ kích thước (size).

<!-- ## Các kiểu trục tọa độ -->

## Chủ đề và ngữ cảnh của đồ thị
Ngữ cảnh cho phép bạn đọc kiểm soát tốt các cấu phần không ánh xạ đến dữ liệu trong đồ thị như phông chữ, hình nền, vị trí chú giải, ... Sự phân tách giữa các thành các phần có ánh xạ đến dữ liệu và thành phần không ánh xạ đến dữ liệu trong thư viện $\textbf{ggplot2}$ là điểm khác biệt so với đồ họa cơ sở. Trong đồ họa cơ sở hầu hết các hàm đều có một số lượng lớn các tham số số chỉ định cả hình thức dữ liệu và phần không liên quan đến dữ liệu, điều này làm cho các hàm trong đồ thị cơ sở trở nên phức tạp. Thư viện $\textbf{ggplot2}$ tiếp cận theo cách khác: khi tạo đồ thị, bạn xác định cách hiển thị dữ liệu trước, sau đó bạn có thể chỉnh sửa mọi chi tiết không liên quan đến dữ liệu bằng các hàm kiểm soát chủ đề và ngữ cảnh. Để kiểm soát chủ đề và ngữ cảnh của đồ thị, bạn đọc cần nắm vững các nội dung sau:

- Các chủ đề và ngữ cảnh đã được hoàn chỉnh và sẵn có trong thư viện $\textbf{ggplot2}$ và trong các thư viện cài đặt bổ sung, chẳng hạn như $\textbf{ggthemes}$.

- Cách kiểm soát các thành phần của chủ đề và ngữ cảnh như: tiêu đề của đồ thị (kiểu chữ, kích thước, vị trí), cách hiển thị các số trên các trục, cách hiển thị các hình dạng đồ họa trên chú giải, kiểu chữ, kích thước hay vị trí của chú giải...

- Kiểm soát các tùy biến của các hàm dùng để gán giá trị cho các thành phần của chủ đề. Ví dụ như hàm `element_text()` có thể dùng để chỉnh kích thước phông chữ, màu sắc và giao diện của các thành phần văn bản.

- Cách sử dụng hàm `theme()` với một danh sách dài các tùy biến cho phép bạn sao chép lên các thành phần của chủ đề và ngữ cảnh mặc định.

## Tạo đồ thị tương tác

Các đồ thị được vẽ bằng thư viện $\textbf{ggplot2}$ đều là các đồ thị tĩnh. Các đồ thị động hay đồ thị tương tác có lợi thế hơn đồ thị tĩnh ở việc thu hút thị giác của người tiếp nhận và có khả năng mô tả dữ liệu một cách đầy đủ thông tin hơn:

- Các đồ thị dạng động đặc biệt hiệu quả trong việc mô tả sự thay đổi dữ liệu theo thời gian.

- Các đồ thị tương tác cho phép hiển thị thông tin bằng con trỏ, hoặc phóng to, thu nhỏ từng phần của đồ thị. Bạn đọc tránh phải hiển thị quá nhiều thông tin lên đồ thị cùng lúc.

Khuyết điểm lớn nhất của các đồ thị tương tác và các đồ thị động đó là không thể biểu diễn trên các bản in cứng!

Trong phần này của chương sách, chúng tôi sẽ thảo luận về hai thư viện dùng để tạo đồ thị tương tác và đồ thị dạng động là $\textbf{ggiraph}$ và $\textbf{plotly}$. Nếu như $\textbf{ggiraph}$ là thư viện bổ sung cho $\textbf{ggplot2}$ và được xây dựng dựa trên cấu trúc ngữ pháp đồ thị thì $plotly$ là một thư viện độc lập với $\textbf{ggplot2}$ và chuyên được sử dụng để tạo đồ thị dạng động và tương tác.

### Tạo đồ thị tương tác với $\textbf{ggiraph}$
Ưu điểm lớn nhất của thư viện $\textbf{ggiraph}$ đó là các câu lệnh tạo đồ thị cũng được dựa trên ngữ pháp của đồ thị, nghĩa là hoàn toàn tương đồng với các câu lệnh trong thư viện $\textbf{ggplot2}$. Để tạo một đồ thị trong $\textbf{ggiraph}$, bạn đọc chỉ cần thêm các thuộc tính thẩm mỹ của đồ thị tương tác và đồ thị động cùng với các thuộc tính của đồ thị tĩnh mà chúng ta đã làm quen trong thư viện $\textbf{ggplot2}$. Tại thời điểm chúng tôi viết chương sách này, thư viện $\textbf{ggiraph}$ đang ở phiên bản 0.8.7 và hướng dẫn sử dụng ở trong link dưới đây

https://cloud.r-project.org/web/packages/ggiraph/ggiraph.pdf

Trong danh sách các hàm số trong thư viện $\textbf{ggiraph}$, bạn đọc có thể thấy rằng đa số các hàm `geom_*()` của thư viện $\textbf{ggplot2}$ đều có một hàm tương ứng để tạo đồ thị tương tác là `geom_*_interactive()`. Chẳng hạn như hàm `geom_point()` của thư viện $\textbf{ggplot2}$ sẽ có hàm tương ứng trong thư viện $\textbf{ggiraph}$ là `geom_point_interactive()`. Hai cấu phần thẩm mỹ để tạo đồ thị tương tác là $tooltip$ và $data_id$. Tuy nhiên, hàm `geom_point_interactive()` không trực tiếp tạo ra đồ thị tương tác, mà bạn đọc cần lưu đối tượng được tạo bằng hàm số này sau đó thực hiện câu lệnh tạo đồ thị tương tác bằng hàm `girafe()`.

Hình \@ref(fig:fgggplot54) là đồ thị tương tác được vẽ bằng thư viện $\textbf{ggiraph}$ mô tả số vụ sát nhân bằng súng tại Mỹ năm 2010 từ dữ liệu $\textbf{murders}$.

```{r fgggplot54, warning=FALSE, message=FALSE, fig.cap = "Đồ thị tương tác mô tả số vụ sát nhân bằng súng tại 51 bang của Mỹ vào năm 2010"}
p<-murders %>% ggplot(aes(y = total, x = population)) +
  geom_point_interactive(aes(fill=region,
                             tooltip = paste0("Bang: ", state, "\n Vùng: ", region, "\n Dân số: ", round(population/1000,0)*1000 ),
                             data_id = region),
                         size = 4, shape=21, alpha = 0.8, color = "black") +
  geom_smooth(method = "lm", se = FALSE, linetype = 2, color="grey")+
  scale_x_continuous(trans = "log10", labels = scales::label_comma()) +
  scale_y_log10() +
  scale_fill_brewer(palette = "Dark2",
                    guide = guide_legend(title = "Vùng"))+
  theme_minimal()+
  ggtitle("Số vụ sát nhân bằng súng tại các bang năm 2010")+
  xlab("Dân số")+ylab("Số vụ sát nhân bằng súng")
girafe(ggobj = p)
```

- Thuộc tính thẩm mỹ `tooltip` cho biết thông tin hiển thị của các điểm trên đồ thị khi sử dụng con trỏ. Trong Hình \@ref(fig:fgggplot54) chúng tôi ánh xạ thuộc tính này đến các biến $state$, $region$ và $population$. Các biến này chỉ hiển thị khi bạn đọc sử dụng con trỏ di chuyển đến một điểm trên đồ thị.

- Thuộc tính thẩm mỹ `data_id` khi được ánh xạ đến một biến sẽ cho biết các quan sát có cùng giá trị trên biến đó. Bạn đọc có thể sử dụng con trỏ di chuyển đến từng các điểm trên đồ thị trong Hình \@ref(fig:fgggplot54) để xem kết quả của ánh xạ đến thuộc tính `tooltip` và `data_id`.

Cách sử dụng các thuộc tính thẩm mỹ `tooltip` và `data_id` hoàn toàn tương tự trong các đồ thị cơ bản khác.

1. Hình \@ref(fig:fgggplot55) mô tả đồ thị bong bóng dạng tương tác. Do mắt quan sát không dễ dàng đánh giá được kích thước của các hình tròn, kể cả khi sử dụng chú giải cho kích thước, việc sử dụng đồ thị tương tác để hiển thị số lượng điểm tại mỗi hình tròn giúp cho dữ liệu càng trở nên sinh động và trực quan hơn. 
```{r fgggplot55, warning=FALSE, message=FALSE, fig.cap = "Đồ thị tương tác dạng bong bóng mô tả số lượng viên kim cương theo màu sắc (color) và giác cắt (cut)"}
p<-diamonds%>%group_by(cut,color)%>%mutate(ave_price = mean(price))%>%ungroup()%>%
  as.data.frame()%>%
  ggplot(aes(cut,color))+
  geom_count_interactive(aes(tooltip = paste0("Số lượng: ", after_stat(n))), 
                         alpha = 0.5, color = "blue",shape = 21, fill = "grey40")+
  scale_size(range=c(1,12))+
  theme_minimal()+
  theme(legend.position = "none")+xlab("Giác cắt")+ylab("Màu sắc")
girafe(ggobj = p)
```

2. Hình \@ref(fig:fgggplot56) sử dụng đồ thị dạng đường và đồ thị dạng hình hộp chữ nhật có tương tác
```{r fgggplot56, warning=FALSE, message=FALSE, fig.cap = "Đồ thị tương tác mô tả tỷ lệ thất nghiệp của nước Mỹ qua các thời kỳ Tổng thống và các Đảng cầm quyền"}
dat1<-presidential[3:11,]
p<-economics%>%mutate(unemploy_rate = unemploy/pop)%>%
  ggplot()+
  geom_rect_interactive(data=dat1,
            aes(xmin = start, xmax = end,
                ymin = 0.01, ymax = 0.052,
                tooltip = paste("Tổng thống: ", name),
                data_id = name,
                fill = party),color = "grey40",size=0.1,alpha=0.5)+
  scale_fill_manual(values=c("blue","red"),labels = c("Democratic" = "Dân chủ","Republican" = "Cộng hòa"),
                    guide = guide_legend(title = "Đảng cầm quyền"))+
  geom_line(aes(x = date, y = unemploy_rate),size = 0.5)+
  geom_point_interactive(aes(x = date, y = unemploy_rate, 
                             tooltip = paste(round(unemploy_rate*100,2),"%")), size = 0.5, alpha = 0.5)+
  scale_y_continuous(limits = c(0.01,0.052),labels = scales::label_percent())+
  theme_minimal()+
  xlab("Năm") + ylab("Tỷ lệ thất nghiệp")
girafe(ggobj = p)
```

ĐỒ thị trong Hình \@ref(fig:fgggplot56) được tạo từ hai dữ liệu, trong đó dữ liệu chính là dữ liệu $\textbf{economics}$ với biến $unemploy$ cho biết số lượng người thất nghiệp tại Mỹ quan sát theo tháng từ năm 1967 đến năm 2015, dữ liệu thứ hai là dữ liệu về các nhiệm kỳ của các tổng thống Mỹ trong các khoảng thời gian tương ứng. Bạn đọc có thể nhận thấy sự khác biệt về sự biến động của tỷ lệ thất nghiệp qua các thời kỳ cầm quyền của các đảng cầm quyền: tỷ lệ thất nghiệp luôn có xu thế giảm trong giai đoạn đảng Dân chủ nắm quyền, trong khi lại có xu thế tăng trong giai đoạn đảng Cộng hòa nắm chính quyền.

3. Hình \@ref(fig:fgggplot57) sử dụng các đồ thị dạng thanh tương tác để mô tả thu nhập bình quân đầu người của các quốc gia vùng Đông Á
```{r fgggplot57, warning=FALSE, message=FALSE,fig.cap = "Thu nhập bình quân đầu người của các quốc gia vùng Đông Á năm 2011"}
p<-gapminder%>%filter(year==2011,region=="Eastern Asia")%>%
  mutate(gdp_per_capita = gdp/population)%>%
  filter(!is.na(gdp_per_capita))%>%
  ggplot(aes(reorder(country,gdp_per_capita),gdp_per_capita,fill = country))+
  geom_bar_interactive(aes(tooltip = paste0("GDP: ", round(gdp/10^9,2), " tỷ USD \n Dân số: ", round(population/10^6,2), 
                                            " triệu \n Tuổi thọ bình quân: ", life_expectancy)), 
                       stat="identity")+
  theme_minimal()+
  scale_x_discrete(guide = guide_axis(title = "", angle = 90))+
  scale_y_continuous(labels = scales::label_dollar(),
                     guide = guide_axis(title = "Thu nhập bình quân đầu người"))+
  scale_fill_brewer(palette = "Paired",
                    guide = guide_legend(title = "Quốc gia",title.position = "top"))+
  ggtitle("Các nước Đông Á năm 2011")
girafe(ggobj = p)
```

4. Hình \@ref(fig:fgggplot58) sử dụng bản đồ tương tác để mô tả biến tỷ lệ trẻ sơ sinh tử vong của dữ liệu $\textbf{gapminder}$
```{r fgggplot58, warning=FALSE, message=FALSE, fig.cap = "Bản đồ mô tả tỷ lệ trẻ sơ sinh tử vong tại tất cả các quốc gia trên thế giới năm 2011"}
dat_map<-map_data("world")
dat<-filter(gapminder,year == 2011)
dat$country<-as.character(dat$country)
dat$country[dat$country == "Congo, Dem. Rep."]<-"Democratic Republic of the Congo"
dat$country[dat$country == "Congo, Rep."]<-"Republic of Congo"
dat$country[dat$country == "Dominican Republic"]<-"Dominica"
dat$country[dat$country == "Kyrgyz Republic"]<-"Kyrgyzstan"
dat$country[dat$country == "Lao"]<-"Laos"
dat$country[dat$country == "St. Lucia"]<-"Saint Lucia"
dat$country[dat$country == "United States"]<-"USA"
dat$country[dat$country == "United Kingdom"]<-"UK"
dat$country[dat$country == "Trinidad and Tobago"]<-"Trinidad"
dat$country<-as.factor(dat$country)

ind<-match(dat_map$region,dat$country)
dat_map<-dat_map%>%mutate(gdp = dat$gdp[ind],
                 population = dat$population[ind],
                 infant_mortality = dat$infant_mortality[ind])
ind<-is.na(dat_map$infant_mortality)
dat_map$infant_mortality[ind]<-round(mean(dat_map$infant_mortality,na.rm=TRUE),2)

p<-dat_map%>%
  ggplot(aes(x=long,y=lat,group=group,label = region, fill = infant_mortality))+
  geom_polygon_interactive(aes(tooltip = paste0(region, "\n Dân số: ", round(population/10^6,2),
                                                " triệu \n Tỷ lệ tử vong trẻ sơ sinh: ", infant_mortality,"/1000")), 
                           color="black",size = 0.1)+
  scale_x_continuous(expand=c(0,0))+
  scale_fill_gradientn(colors = colorRampPalette(c("lightgreen","red"), space = "Lab")(10))+
  theme_minimal()+xlab("")+ylab("")+ggtitle("Tỷ lệ trẻ sơ sinh tử vong năm 2011")+
  theme(legend.position = "none")
girafe(ggobj = p)
```

Bạn đọc có thể thấy rằng bản đồ tương tác đặc biệt hiệu quả trong hiển thị thông tin thay thế cho chú giải. Màu sắc từ xanh lá cây đến đỏ cho biết vùng quốc gia - vùng lãnh thổ nào có tỷ lệ trẻ sơ sinh tử vong cao và quốc gia - vùng lãnh thổ nào có tỷ lệ trẻ sơ sinh tử vong thấp. Bạn đọc muốn biết thông tin chi tiết về quốc gia đó có thể sử dụng con trỏ để hiển thị thông tin, bao gồm có thông tin về tên nước, dân số, và tỷ lệ trẻ sơ sinh tử vong.

### Tạo đồ thị tương tác bằng thư viện $\textbf{plotly}$
Để tạo một đồ thị tương tác bằng thư viện $\textbf{plotly}$ dễ dàng hơn so với sử dụng thư viện $\textbf{ggiraph}$ vì chúng ta không cần viết các câu lệnh có ngữ pháp. Việc duy nhất bạn đọc cần làm là sử dụng hàm `ggplotly()` trên một đối tượng được tạo bằng hàm `ggplot()`. Đoạn câu lệnh dưới đây mô tả dữ liệu $murders$ dưới dạng đồ thị phân tán tương tác.

```{r fgggplot59, warning=FALSE, message=FALSE, fig.cap = "Đồ thị tương tác mô tả số vụ sát nhân bằng súng tại 51 bang của Mỹ vào năm 2010"}
p<-murders %>% 
  ggplot(aes(x = population/10^6, y = total)) +
  geom_point(aes(group = state, fill = region ), size = 3, shape=21, alpha = 0.8) +
  geom_smooth(method = "lm", se = FALSE, linetype = 2, color="grey80")+
  scale_x_log10() +
  scale_y_log10() +
  scale_fill_brewer(palette = "Dark2",
                    guide = guide_legend(title = "Vùng"))+
  xlab("Dân số của bang (triệu dân)") +
  ylab("Tổng số vụ sát nhân bằng súng") +
  ggtitle("Số vụ sát nhân bằng súng trong năm 2010 tại Mỹ")+
  theme_minimal()
ggplotly(p)
```

Bạn đọc có thể tương tác với đồ thị tạo bằng `ggplotly()` bằng các thao tác như sau:

1. Sử dụng con trỏ chỉ vào các điểm để xem thông tin chính xác về dân số, số vụ sát nhân, tên bang, và tên vùng của mỗi điểm.

2. Sử dụng con trỏ, hoặc các nút phóng to, thu nhỏ để xem từng phần của đồ thị.

3. Sử dụng con trỏ trên chú giải để lựa chọn các vùng nào hiển thị, hoặc không hiển thị trên đồ thị.

4. Sử dụng con trỏ trượt theo đường thẳng tạo bởi `geom_smooth()` để biết giá trị trên trục total và population của mỗi điểm trên đường thẳng. Lưu ý rằng giá trị xuất hiện là giá trị sau khi đã chuyển đổi bằng hàm $log10()$.

Các thông tin bạn đọc muốn hiển thị bằng con trỏ là tất cả các biến dữ liệu đã được ánh xạ vào trong các thuộc tính thẩm mỹ của đồ thị. Đồ thị trong Hình \@ref(fig:fgggplot59) hiển thị thông tin trên các điểm bao gồm giá trị các biến $population$, $total$, $state$, và $region$ là tất cả các biến được sử dụng trong ánh xạ thẩm mỹ của hàm `geom_point()`. Dọc theo đường hồi quy tuyến tính, chúng ta sẽ có thông tin về giá trị của các biến $population$ và $total$ là các biến được sử dụng trong ánh xạ thẩm mỹ của hàm `geom_smooth()`. 

Tham số `tooltip` trong hàm `ggplotly()` được sử dụng để kiểm soát các thuộc tính thẩm mỹ xuất hiện trên đồ thị tương tác. Ví dụ như trong đồ thị phân tán trong Hình \@ref(fig:fgggplot59), nếu chúng ta chỉ muốn hiển thị thông tin về tên của bang và thông tin về vùng. Do tên của bang được ánh xạ tới thuộc tính thẩm mỹ `group` và vùng được ánh xạ tới thuộc tính thẩm mỹ `fill`, nên chúng ta có thể sử dụng tham số `tooltip` như sau

```{r, warning=FALSE, message=FALSE, eval = FALSE}
# Thông tin chỉ bao gồm tên bang và vùng
ggplotly(p, tooltip = c("group","fill"))
```

Hàm số `ggplotly()` có thể được sử dụng để tạo đồ thị tương tác với đa số các đồ thị được tạo bởi $ggplot2$, dưới đây là một số ví dụ

1. Hình \@ref(fig:fgggplot60) vẽ đồ thị kiểu bong bóng tương tác mô tả số lượng và giá trung bình của kim cương khi phân loại theo màu sắc và giác cắt.
```{r fgggplot60, warning=FALSE, message=FALSE, fig.cap = "Số lượng và giá trung bình của kim cương phân loại theo màu sắc và giác cắt"}
p<-diamonds%>%group_by(cut,color)%>%mutate(ave_price = round(mean(price)))%>%ungroup()%>%
  as.data.frame()%>%
  ggplot(aes(cut,color,color = ave_price))+
  geom_count(alpha = 0.9)+
  scale_color_gradientn(colors = colorRampPalette(c("darkblue","orange"), space = "Lab")(10))+
  scale_size(range=c(1,12))+
  theme_minimal()
ggplotly(p, tooltip = c("n", "color"))
```

2. Hình \@ref(fig:fgggplot61) sử dụng đồ thị tương tác dạng đường để mô tả tổng thu nhập quốc dân của năm quốc gia phát triển trên thế giới là Mỹ, Đức, Pháp, Nhật và Trung Quốc từ năm 1970 đến năm 2011.
```{r fgggplot61, warning=FALSE, message=FALSE, fig.cap = "Tổng thu nhập quốc dân của các quốc gia Mỹ, Đức, Pháp, Nhật và Trung Quốc từ năm 1970 đến năm 2011"}
p<-gapminder%>%filter(country %in% c("United States","Japan","Germany","France", "China"),
                   year <= 2011, year >= 1970)%>%mutate(gdp_bil_usd = gdp/10^9)%>%
  ggplot(aes(x = year, y = gdp_bil_usd, color = country))+
  geom_line()+
  scale_y_continuous(labels = scales::label_comma())+
  theme_minimal()
ggplotly(p, tooltip = c("x","y", "color"))
```

3. Hình \@ref(fig:fgggplot62) sử dụng đồ thị tương tác dạng thanh để trực quan hóa hai biến rời rạc là thu nhập bình quân đầu người và châu lục vào năm 2011. Thu nhập bình quân đầu người được phân loại theo ba mức độ: thấp tương ứng với thu nhập bình quân dưới 3000 USD, trung bình tương ứng với thu nhập bình quân từ 3000 USD đến 8000 USD, và cao tương ứng với thu nhập bình quân trên 8000 USD.
```{r fgggplot62, warning=FALSE, message=FALSE, fig.cap = "Tỷ lệ các nước thu nhập thấp, trung bình, và cao tại các châu lục năm 2011"}
p<-gapminder%>%filter(year == 2011)%>%drop_na()%>%
  mutate(gdp_per_capita = gdp/population,
         gdp_levels = ifelse(gdp_per_capita<3000,"Thấp",
                            ifelse(gdp_per_capita<8000,"Trung bình","Cao")),
         gdp_range = factor(gdp_levels, levels = c("Cao","Trung bình","Thấp")))%>%
  ggplot(aes(x = continent,fill = gdp_range))+
  geom_bar(color="grey40",alpha=0.8)+
  scale_fill_manual(values = colorRampPalette(c("orange","grey"))(3))+
  theme_minimal()
ggplotly(p, tooltip = "count")
```

4. Hình \@ref(fig:fgggplot63) sử dụng đồ thị tương tác dạng bản đồ để mô tả tỷ lệ số vụ xả súng tại các bang tại Mỹ năm 2010.
```{r fgggplot63, warning=FALSE, message=FALSE, fig.cap="Tỷ lệ số vụ xả súng trên 1 triệu dân tại các bang của nước Mỹ năm 2010"}
dat<-map_data("state")
dat1<-murders%>%mutate(murder_rate=total/population*10^6,
                       state = tolower(state))

p<-dat%>%mutate(state = region)%>%
  mutate(murder_rate=dat1$murder_rate[match(state,dat1$state)])%>%
  ggplot(aes(x=long,y=lat,group=group,label = state, fill=murder_rate))+
  geom_polygon(color="black",size = 0.1)+
  scale_x_continuous(expand=c(0,0))+
  scale_fill_gradientn(colors = c(rgb(0.95,0.95,0.95),rgb(0.95,0.3,0.3),
                                  rgb(0.95,0.1,0.1)))+
  theme_minimal()+
  theme(legend.position = "bottom")
ggplotly(p)
```

## Đồ thị động
Đồ thị động (dynamic graph) là một phương pháp thường được sử dụng để mô tả dữ liệu biến đổi theo thời gian. Đồ thị dạng động ngoài yếu tố bắt mắt còn giúp cho người tiếp nhận dữ liệu cảm nhận được sự thay đổi của các biến liên tục và rời rạc theo thời gian một cách trực quan nhất. Chúng tôi sẽ giới thiệu đến bạn đọc cách tạo các đồ thị động với thư viện $\textbf{plotly}$ trước và sau đó là thư viện $\textbf{gganimate}$. Để bạn đọc hiểu cách đồ thị động được tạo thành, hãy bắt đầu với một dữ liệu đơn giản bao gồm hai biến liên tục là $x$, $y$ và một biến thời gian:
```{r, warning=FALSE, message=FALSE}
dat<-data.frame(x=1:30,y=(1:30)^2,time=1:30)
```

Để trực quan hóa ba biến kiểu số bao gồm $x$, $y$ và $time$, phương pháp thường được sử dụng là trực quan hóa hai biến $x$ và $y$ bằng một đồ thị phân tán, sau đó ánh xạ biến $time$ vào một thuộc tính thẩm mỹ phù hợp, chẳng hạn như kích thước của các điểm. Đồ thị kiểu như vậy được mô tả trong Hình \@ref(fig:fgggplot64)

```{r fgggplot64, warning=FALSE, message=FALSE, fig.cap = "Mô tả ba biến liên tục sử dụng thuộc tính thẩm mỹ kích thước"}
dat%>%ggplot(aes(x,y,size = time))+
  geom_point(alpha=0.3,shape = 21, color = "blue", fill = "grey40")+
  scale_size(range=c(1,15))+
  theme_minimal()
```

Một phương pháp là sử dụng đồ thị dạng động, là tập hợp của các nhiều đồ thị tĩnh xuất hiện liên tục mà mỗi đồ thị tương ứng với một giá trị của biến $time$. Bạn đọc có thể thực hiện việc này bằng thư viện $\textbf{plotly}$. Thuộc tính thẩm mỹ để tạo đồ thị dạng động là `frame`. Chúng ta chỉ cần khai báo thêm ánh xạ thẩm mỹ từ tham số `frame` đến biến `time` để tạo một đồ thị động trực quan như Hình \@ref(fig:fgggplot65)
```{r fgggplot65, warning=FALSE, message=FALSE, fig.cap = "Đồ thị động mô tả sự chuyển động của một điểm theo biến time của dữ liệu"}
p<-dat%>%ggplot(aes(x=x,y=y,size=time,frame = time))+
  geom_point(alpha=0.5,shape = 21, color = "blue", fill = "grey40")+
  scale_size(range=c(1,15))+
  theme_minimal()
ggplotly(p, tooltip = "size")
```

Đồ thị dạng động sẽ được kích hoạt mỗi khi chúng ta bấm nút play. Bạn đọc có thể thấy rằng cách mô tả sự thay đổi của điểm theo thời gian của đồ thị động trong Hình \@ref(fig:fgggplot65) trực quan và hiệu quả hơn so với Hình \@ref(fig:fgggplot64).

Hàm `ggplotly()` rất hiệu quả khi mô tả các biến liên tục theo thời gian. Quay trở lại với dữ liệu $\textbf{gapminder}$, đồ thị dạng động cho phép chúng ta xây dựng các đồ thị trực quan sinh động. Ví dụ, chúng ta muốn mô tả hai biến tuổi thọ trung bình và tỷ lệ sinh trung bình của một phụ nữ qua các năm, chúng ta có thể ánh xạ hai biến lên hai trục tọa độ, sau đó sử dụng màu sắc để mô tả biến châu lục, sử dụng kích thước để mô tả biến dân số, và sau cùng là sử dụng đồ thị dạng động để mô tả biến thời gian (year).

```{r fgggplot66, warning=FALSE, message=FALSE, fig.cap = "Đồ thị động mô tả sự thay đổi của tuổi thọ trung bình và tỷ lệ sinh trung bình của một phụ nữ từ năm 1960 đến 2011 của tất cả các quốc gia trên thế giới"}
p<-gapminder%>%filter(year %in% 1960:2011)%>%
  ggplot(aes(x = fertility, y = life_expectancy, size = population,
             fill = continent, frame = year))+
  geom_point(alpha = 0.5,shape=21)+
  scale_fill_brewer(palette = "Set1")+
  scale_size(range=c(1,15))+
  theme_minimal()+
  ggtitle("Tuổi thọ và tỷ lệ sinh trung bình 1960 đến 2011")
ggplotly(p, tooltip = c())
```





<!-- Một trong những công việc khó khăn nhất của những người làm việc liên quan đến xây dựng các mô hình toán học phức tạp là giải thích kết quả của mình cho những người ít có kiến thức chuyên môn về lĩnh vực này. Kinh nghiệm của chúng tôi là hãy trực quan hóa kết quả của mình thay vì các công thức phức tạp. Dưới đây là một vài khái niệm toán học phức tạp được giải thích dưới dạng đồ thị động -->

<!-- 1. Chuyển động Brown: chuyển động Brown là một quá trình ngẫu nhiên có ý nghĩa đặc biệt quan trọng trong tài chính, bảo hiểm, và cả các lĩnh vực công nghệ. Không dễ dàng để giải thích cho những người không có nền tảng về toán các khái niệm về chuyển động Brown. Thay vì các công thức toán, chúng ta có thể giải thích về chuyển động Brown thông qua trực quan hóa: -->

<!-- 2. Markov Chain Monte Carlo là một kỹ thuật mô phỏng biến ngẫu nhiên hoặc một véc-tơ ngẫu nhiên có hàm phân phối $F$ mà không thể mô phỏng được một cách trực tiếp. Quá trình tạo ra biến ngẫu nhiên có hàm phân phối $F$ sẽ bắt đầu từ một phân phối $G$ mà chúng ta có thể mô phỏng ra được đi qua các hàm phân phối trung gian và sẽ hội tụ đến phân phối $F$. Hình vẽ dưới đây mô tả quá trình mô phỏng biến ngẫu nhiên phân phối chuẩn $\mathcal{N}(0,1)$ từ một phân phối có hai đinh (2 mode).  -->

<!-- ```{r, warning=FALSE, message=FALSE, echo = FALSE} -->
<!-- # Input -->
<!-- N<-2*10^4 # number of simulation -->
<!-- n<-300 # length of each tranjectory -->
<!-- dt<-0.025 -->

<!-- # pi(x) -->
<!-- pi_x<-function(x){ -->
<!--   return (exp(-(x^2+sin(5*x+5)))) -->
<!-- } -->

<!-- d_log_pi<-function(x) return (-x) -->

<!-- # simulate process Xt -->
<!-- X<-matrix(0,N,n) -->
<!-- ## initial value: mix nornal -->
<!-- X[,1]<- ifelse(runif(N,0,1)<0.5,rnorm(N,-3,1),rnorm(N,3,1)) -->

<!-- # generate Xt -->
<!-- for (j in 2:n){ -->
<!--   dX <- 1/2*d_log_pi(X[,(j-1)])*dt + sqrt(dt)*rnorm(N,0,1) -->
<!--   X[,j]<-X[,(j-1)]+dX -->
<!-- } -->

<!-- # visualization -->
<!-- dat<-data.frame(t = c(1:(N*n)), value = rep(0,N*n)) -->
<!-- for (i in 1:n){ -->
<!--   ind<-((i-1)*N+1):(i*N) -->
<!--   dat$t[ind]<-i -->
<!--   dat$value[ind]<-X[,i] -->
<!-- } -->

<!-- p<-dat%>%ggplot(aes(value,frame=t))+ -->
<!--   geom_density(fill = "yellow")+#GIOI HAN LAI GIA TRI TREN X,Y -->
<!--   xlim(-5,5)+ylim(0,0.5)+ -->
<!--   theme_dark() -->
<!-- ggplotly(p, width = 800, height = 600) %>% -->
<!--   animation_opts(frame = 2) -->
<!-- ``` -->


## Bài tập


## Phụ lục

### Lập trình trong $\textbf{ggplot2}$

### Tạo dashboard bằng thư viện $\textbf{shiny}$









<!-- # REFERENCE -->

<!-- ### Source from thesis -->

<!-- **1.** Chen, Chun-houh, Wolfgang Karl Härdle, and Antony Unwin, eds (2007). *Handbook of data visualization.* \ -->
<!-- **2.** Aparicio, Manuela, and Carlos J. Costa. (2015). *Data visualization - Communication design quarterly review.* \ -->
<!-- **3.** Hadley Wickham. (2010). *A Layered Grammar of Graphics.* \ -->

<!-- ### Souce from website -->

<!-- **4.** [https://www.tableau.com/learn/articles/data-visualization](https://www.tableau.com/learn/articles/data-visualization) \ -->
<!-- **5.** [https://www.r-graph-gallery.com/ggplot2-package.html](https://www.r-graph-gallery.com/ggplot2-package.html) \ -->
<!-- **6.** [http://r-statistics.co/ggplot2-Tutorial-With-R.html](http://r-statistics.co/ggplot2-Tutorial-With-R.html) \ -->
<!-- **7.** [https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf](https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf) \ -->
<!-- **8.** [https://www.kaggle.com/](https://www.kaggle.com/) \ -->
