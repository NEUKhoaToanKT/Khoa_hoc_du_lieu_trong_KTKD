<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chương 1 Mô hình hồi quy tuyến tính | bookdown-demo.knit</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.38 and GitBook 2.6.7" />

  <meta property="og:title" content="Chương 1 Mô hình hồi quy tuyến tính | bookdown-demo.knit" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chương 1 Mô hình hồi quy tuyến tính | bookdown-demo.knit" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>
<link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">KHDL KT&KD</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#mô-hình-hồi-quy-tuyến-tính"><i class="fa fa-check"></i><b>1</b> Mô hình hồi quy tuyến tính</a>
<ul>
<li class="chapter" data-level="1.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#những-nội-dung-cơ-bản-của-mô-hình-quy-tuyến-tính"><i class="fa fa-check"></i><b>1.1</b> Những nội dung cơ bản của mô hình quy tuyến tính</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#mô-hình-hồi-quy-tuyến-tính-đơn-biến"><i class="fa fa-check"></i><b>1.1.1</b> Mô hình hồi quy tuyến tính đơn biến</a></li>
<li class="chapter" data-level="1.1.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#mô-hình-hồi-quy-tuyến-tính-đa-biến"><i class="fa fa-check"></i><b>1.1.2</b> Mô hình hồi quy tuyến tính đa biến</a></li>
<li class="chapter" data-level="1.1.3" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#những-cân-nhắc-khi-xây-dựng-mô-hình-hồi-quy-tuyến-tính"><i class="fa fa-check"></i><b>1.1.3</b> Những cân nhắc khi xây dựng mô hình hồi quy tuyến tính</a></li>
<li class="chapter" data-level="1.1.4" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#những-khiếm-khuyết-của-mô-hình-hồi-quy-tuyến-tính"><i class="fa fa-check"></i><b>1.1.4</b> Những khiếm khuyết của mô hình hồi quy tuyến tính</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#leastsquared"><i class="fa fa-check"></i><b>1.2</b> Mô hình hồi quy tuyến tính và phương pháp bình phương nhỏ nhất</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#ước-lượng-các-hệ-số-tuyến-tính"><i class="fa fa-check"></i><b>1.2.1</b> Ước lượng các hệ số tuyến tính</a></li>
<li class="chapter" data-level="1.2.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#ước-lượng-phương-sai-của-biến-phụ-thuộc."><i class="fa fa-check"></i><b>1.2.2</b> Ước lượng phương sai của biến phụ thuộc.</a></li>
<li class="chapter" data-level="1.2.3" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#kiểm-định-các-hệ-số-ước-lượng."><i class="fa fa-check"></i><b>1.2.3</b> Kiểm định các hệ số ước lượng.</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#linearmodelselection"><i class="fa fa-check"></i><b>1.3</b> Các phương pháp chọn biến trong mô hình hồi quy tuyến tính.</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#phương-pháp-lựa-chọn-tập-hợp-con-tốt-nhất"><i class="fa fa-check"></i><b>1.3.1</b> Phương pháp lựa chọn tập hợp con tốt nhất</a></li>
<li class="chapter" data-level="1.3.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#forward--and-backward-stepwise-selection"><i class="fa fa-check"></i><b>1.3.2</b> Forward- and Backward-Stepwise Selection</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#hồi-quy-tuyến-tính-có-ràng-buộc-tham-số"><i class="fa fa-check"></i><b>1.4</b> Hồi quy tuyến tính có ràng buộc tham số</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#hồi-quy-ridge"><i class="fa fa-check"></i><b>1.4.1</b> Hồi quy ridge</a></li>
<li class="chapter" data-level="1.4.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#phương-pháp-lasso"><i class="fa fa-check"></i><b>1.4.2</b> Phương pháp Lasso</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#thực-hành-xây-dựng-mô-hình-tuyến-tính-trên-dữ-liệu-boston"><i class="fa fa-check"></i><b>1.5</b> Thực hành xây dựng mô hình tuyến tính trên dữ liệu Boston</a>
<ul>
<li class="chapter" data-level="1.5.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#xây-dựng-mô-hình-hồi-quy-đa-biến"><i class="fa fa-check"></i><b>1.5.1</b> Xây dựng mô hình hồi quy đa biến</a></li>
<li class="chapter" data-level="1.5.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#lựa-chọn-biến-trong-mô-hình-hồi-quy-tuyến-tính"><i class="fa fa-check"></i><b>1.5.2</b> Lựa chọn biến trong mô hình hồi quy tuyến tính</a></li>
<li class="chapter" data-level="1.5.3" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#hồi-quy-ridge-và-lasso"><i class="fa fa-check"></i><b>1.5.3</b> Hồi quy ridge và lasso</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#bài-tập"><i class="fa fa-check"></i><b>1.6</b> Bài tập</a>
<ul>
<li class="chapter" data-level="1.6.1" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#bài-tập-lý-thuyết"><i class="fa fa-check"></i><b>1.6.1</b> Bài tập lý thuyết</a></li>
<li class="chapter" data-level="1.6.2" data-path="09-mo-hinh-tuyen-tinh.html"><a href="#bài-tập-thực-hành"><i class="fa fa-check"></i><b>1.6.2</b> Bài tập thực hành</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="mô-hình-hồi-quy-tuyến-tính" class="section level1 hasAnchor" number="1">
<h1><span class="header-section-number">Chương 1</span> Mô hình hồi quy tuyến tính<a href="#mô-hình-hồi-quy-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Chương sách này thảo luận về mô hình hồi quy tuyến tính - phương pháp cơ bản nhất trong các phương pháp xây dựng mô hình học máy có giám sát. Mặc dù đơn giản nhưng mô hình hồi quy tuyến tính lại là một công cụ hữu ích để đưa ra các dự đoán hoặc mô tả sự tác động của các một biến giải thích lên các biến khác. Hồi quy tuyến tính là một chủ đề đã được nghiên cứu từ rất lâu, từ trước khi có máy tính điện tử, đồng thời cũng là chủ đề của vô số sách tham khảo. Trong thời đại ngày nay, mặc dù mô hình này có vẻ hơi nhàm chán hơn so với một số phương pháp học thống kê/học máy hiện đại, nhưng hồi quy tuyến tính vẫn là một phương pháp học thống kê hữu ích và được sử dụng rộng rãi. Hơn nữa, đây còn là điểm khởi đầu tốt cho các phương pháp tiếp cận mới hơn như chúng ta sẽ thấy trong các chương sau. Nhiều phương pháp học máy tiên tiến nhất hiện nay có thể được coi là sự khái quát hóa hoặc mở rộng của hồi quy tuyến tính. Do đó, tầm quan trọng của việc hiểu rõ về hồi quy tuyến tính trước khi nghiên cứu các phương pháp phức tạp hơn là không thể phủ nhận.</p>
<p>Trong phần đầu của chương này, chúng ta xem xét một số ý tưởng chính làm cơ sở cho mô hình hồi quy tuyến tính, cũng như phương pháp bình phương nhỏ nhất được sử dụng phổ biến nhất để ước lượng tham số cho mô hình này. Trong phần sau của chương, chúng ta sẽ thảo luận về các phương pháp lựa chọn mô hình và các phương pháp rút gọn tham số (shrinkage).</p>
<div id="những-nội-dung-cơ-bản-của-mô-hình-quy-tuyến-tính" class="section level2 hasAnchor" number="1.1">
<h2><span class="header-section-number">1.1</span> Những nội dung cơ bản của mô hình quy tuyến tính<a href="#những-nội-dung-cơ-bản-của-mô-hình-quy-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Trước khi đi vào các nội dung cơ bản, hãy lấy một ví dụ đơn giản về một yêu cầu trên dữ liệu mà có thể tìm được lời giải được bằng mô hình hồi quy tuyến tính. Giả sử một công ty thực hiện một chiến dịch quảng cáo sản phẩm cho 55 cửa hàng trên cả nước trong một năm thông qua ba phương thức quảng cáo là 1. qua truyền hình (<span class="math inline">\(TV\)</span>), 2. qua mạng xã hội (<span class="math inline">\(Social\_Media\)</span>) và 3. qua tờ rơi (<span class="math inline">\(Flyers\)</span>). Hình vẽ dưới đây mô tả mối liên hệ giữa doanh số bán hàng (<span class="math inline">\(Sales\)</span>-đơn vị tỷ đồng) với chi phí thực hiện các phương thức quảng cáo ở các cửa hàng (đơn vị triệu đồng)</p>
<p><img src="bookdown-demo_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Giả sử với vai trò là một chuyên gia tư vấn, chúng ta được yêu cầu đưa ra đề xuất trên cơ sở dữ liệu quan sát được, một kế hoạch quảng cáo cho năm tới nhằm mang lại doanh số bán sản phẩm cao. Thông tin nào từ dữ liệu sẽ hữu ích để đưa ra khuyến nghị cho chiến dịch quảng cáo? Dưới đây là một số câu hỏi quan trọng mà chúng ta cần tìm cách giải quyết nhằm đưa ra khuyến nghị</p>
<ol style="list-style-type: decimal">
<li><p>Có mối quan hệ giữa ngân sách chi cho từng hình thức quảng cáo và doanh số bán hàng không? Để trả lời câu hỏi này chúng ta cần xác định xem dữ liệu có cung cấp minh chứng về mối liên hệ tuyến tính giữa chi tiêu cho từng hình thức quảng cáo với doanh số bán hàng. Nếu mối liên hệ là yếu, hoặc thậm chí là mối liên hệ âm thì chúng ta có thể lập luận rằng không nên chi tiền cho quảng cáo!</p></li>
<li><p>Mối liên hệ giữa ngân sách chi cho quảng cáo và doanh thu nếu tồn tại thì mạnh đến mức nào? Nếu mối liên hệ là mạnh, thì với một ngân sách quảng cáo nhất định, liệu chúng ta có thể dự đoán doanh số bán hàng với độ chính xác cao không, hay dự đoán về doanh số bán hàng dựa trên chi tiêu quảng cáo chỉ tốt hơn một chút so với dự đoán ngẫu nhiên?</p></li>
<li><p>Phương tiện truyền thông nào góp phần tăng doanh số bán hàng? Cả ba phương tiện truyền thông TV, mạng xã hội và phát tờ rơi có đóng góp vào doanh số bán hàng hay chỉ một hoặc hai phương tiện quảng cáo có đóng góp? Để trả lời câu hỏi này, chúng ta phải tìm cách tách biệt những tác động riêng lẻ của từng phương tiện khi chúng ta đã chi tiền cho cả ba phương tiện.</p></li>
<li><p>Chúng ta có thể ước tính chính xác tác động của từng phương tiện đến doanh số bán hàng như thế nào? Với đồng chi cho quảng cáo trên một phương tiện cụ thể, doanh số bán hàng sẽ tăng bao nhiêu? Chúng ta có thể dự đoán mức tăng này chính xác đến mức nào?</p></li>
<li><p>Mối liên hệ/tác động của chi cho từng hình thức quảng cáo đến doanh số bán hàng có tuyến tính không? Nếu không, liệu có phương pháp biến đổi biến như thế nào để mối liên hệ vẫn là tuyến tính.</p></li>
<li><p>Có sự tác động qua lại giữa các phương tiện quảng cáo không? Chẳng hạn như nên chi 100 triệu cho quảng cáo trên mạng xã hội và 100 triệu cho quảng cáo tờ rơi liệu có mang lại doanh thu cao hơn việc phân bổ 200 triệu cho riêng từng kênh? Trong tiếp thị quảng cáo, đây được gọi là hiệu ứng tổng hợp.</p></li>
</ol>
<p>Những cơ sở của mô hình hồi quy tuyến tính được thảo luân trong chương này sẽ giúp bạn đọc lần lượt trả lời các câu hỏi của bài toán ở trên.</p>
<div id="mô-hình-hồi-quy-tuyến-tính-đơn-biến" class="section level3 hasAnchor" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Mô hình hồi quy tuyến tính đơn biến<a href="#mô-hình-hồi-quy-tuyến-tính-đơn-biến" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Hồi quy tuyến tính đơn biến, đúng như tên gọi, đó là một cách tiếp cận tuyến tính đơn giản để dự đoán phản ứng định lượng của một biến mục tiêu <span class="math inline">\(Y\)</span> trên cơ sở biến độc lập <span class="math inline">\(X\)</span>. Mô hình giả định rằng có mối quan hệ tuyến tính giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span>. Về mặt toán học, chúng ta có thể viết mối quan hệ tuyến tính này như sau
<span class="math display" id="eq:lm01">\[\begin{align}
Y \sim \beta_0 + \beta_1 \cdot X
\tag{1.1}
\end{align}\]</span>
Bạn có thể hiểu <span class="math inline">\(\sim\)</span> theo nghĩa xấp xỉ hoặc gần đúng. Đôi khi chúng ta sẽ mô tả <a href="#eq:lm01">(1.1)</a> bằng cách nói rằng chúng ta đang hồi quy <span class="math inline">\(Y\)</span> theo <span class="math inline">\(X\)</span>. Trong ví dụ trình bày ở trên <span class="math inline">\(X\)</span> có thể đại diện cho chi phí quảng cáo trên truyền hình (<span class="math inline">\(TV\)</span>) và <span class="math inline">\(Y\)</span> có thể đại diện cho doanh số bán hàng (<span class="math inline">\(Sales\)</span>) tại các cửa hàng. Sau đó, chúng ta có thể hồi quy doanh số bán hàng theo chi phí quảng cáo trên truyền hình theo một mô hình hồi quy tuyến tính đơn biến như sau
<span class="math display" id="eq:lm02">\[\begin{align}
Sales \sim \beta_0 + \beta_1 \cdot TV
\tag{1.2}
\end{align}\]</span></p>
<p>Trong phương trình <a href="#eq:lm02">(1.2)</a>, <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> là hai hằng số chưa biết biểu thị hệ số chặn và hệ số góc của đường thẳng trong mô hình tuyến tính. Cùng với nhau, <span class="math inline">\((\beta_0, \beta_1)\)</span> được gọi là các hệ số tuyến tính hoặc tham số của mô hình. Các hệ số này sẽ được ước lượng dựa trên dữ liệu thu thập được dựa trên các phương pháp do người xây dựng mô hình lựa chọn. Các ước lượng cho hệ số tuyến tính thường được thêm dấu mũ ở trên để phân biệt với tham số của mô hình tuyến tính, nói cách khác chúng ta có <span class="math inline">\(\hat{\beta}_0\)</span> và <span class="math inline">\(\hat{\beta}_1\)</span> là các ước lượng của <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span>. Với <span class="math inline">\(Y\)</span> là biến doanh thu bán hàng và <span class="math inline">\(X\)</span> là biến chi phí quảng cáo trên truyền hình chúng ta sẽ có một dự đoán cho doanh thu bán hàng <span class="math inline">\(\hat{y}\)</span> dựa trên một quan sát của chi phí quảng cáo <span class="math inline">\(X = x\)</span>
<span class="math display" id="eq:lm03">\[\begin{align}
\hat{y} = \hat{\beta}_0 + \hat{\beta}_1 \cdot x
\tag{1.3}
\end{align}\]</span></p>
<p>Lưu ý rằng chúng tôi luôn sử dụng dấu mũ để mô tả một ước lượng cho một tham số, hoặc là giá trị dự đoán cho giá trị không biết.</p>
<div id="ước-lượng-hệ-số-trong-mô-hình-đơn-biến" class="section level4 hasAnchor" number="1.1.1.1">
<h4><span class="header-section-number">1.1.1.1</span> Ước lượng hệ số trong mô hình đơn biến<a href="#ước-lượng-hệ-số-trong-mô-hình-đơn-biến" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Trong mô hình hồi quy tuyến tính đơn biến, <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> là các tham số không biết và cần được ước lượng. Giá sử dữ liệu chúng ta quan sát được bao gồm <span class="math inline">\(n\)</span> cặp <span class="math inline">\((x_i, y_i)\)</span> như sau
<span class="math display">\[\begin{align}
(x_1, y_1), (x_2, y_2), \cdots, (x_n, y_n)
\end{align}\]</span>
trong đó <span class="math inline">\(x_i\)</span> là các giá trị quan sát được của biến <span class="math inline">\(X\)</span> và <span class="math inline">\(y_i\)</span> là các giá trị quan sát được tương ứng của biến ngẫu nhiên <span class="math inline">\(Y\)</span>. Trong ví dụ về chi phí cho quảng cáo, tập dữ liệu này bao gồm ngân sách quảng cáo qua truyền hình và doanh số bán sản phẩm ở <span class="math inline">\(n = 55\)</span> cửa hàng khác nhau. Mục tiêu của chúng ta là thu được các ước lượng cho hệ số <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> sao cho mô hình tuyến tính <a href="#eq:lm02">(1.2)</a> phù hợp tốt với dữ liệu có sẵn. Nói cách khác, chúng ta muốn tìm hệ số chặn <span class="math inline">\(\beta_0\)</span> và hệ số góc <span class="math inline">\(\beta_1\)</span> sao cho đường thẳng kết quả càng gần <span class="math inline">\(n = 55\)</span> điểm dữ liệu càng tốt. Có các phương pháp khác nhau để định nghĩa thế nào là một đường thẳng gần với một tập hợp điểm. Tuy nhiên, cho đến nay cách tiếp cận phổ biến nhất là liên quan đến tối thiểu tổng bình phương khoảng cách từ các điểm đến đường thẳng đó, hay còn gọi là phương pháp <span class="math inline">\(bình\)</span> <span class="math inline">\(phương\)</span> <span class="math inline">\(nhỏ\)</span> <span class="math inline">\(nhất\)</span> và chúng ta áp dụng cách tiếp cận đó trong chương này. Chi tiết về phương pháp bình phương nhỏ nhất sẽ được trình bày trong các phần sau của chương.</p>
<div class="figure"><span style="display:block;" id="fig:fglm01"></span>
<img src="bookdown-demo_files/figure-html/fglm01-1.png" alt="Hồi quy đơn biến doanh thu bán hàng theo chi phí quảng cáo trên truyền hình" width="672" />
<p class="caption">
Figure 1.1: Hồi quy đơn biến doanh thu bán hàng theo chi phí quảng cáo trên truyền hình
</p>
</div>
<p>Với <span class="math inline">\(\hat{y}_i = \hat{\beta}_0 + \hat{\beta}_1 \cdot x_i\)</span> là dự đoán cho <span class="math inline">\(Y\)</span> dựa trên giá trị thứ <span class="math inline">\(i\)</span> của <span class="math inline">\(X\)</span>. Khi đó ta ký hiệu <span class="math inline">\(e_i = y_i − \hat{y}_i\)</span> đại diện cho phần dư đối với quan sát thứ <span class="math inline">\(i\)</span>. Như vậy phần dư là sự khác biệt giữa giá trị quan sát được của biến mục tiêu và giá trị ước lượng được cho biến mục tiêu được tính toán bởi mô hình tuyến tính. Chúng ta xác định tổng bình phương của phần dư, ký hiệu là RSS (Residual Sum of Squares)
<span class="math display">\[\begin{align}
RSS &amp; = e_1^2 + e_2^2 + \cdots + e_n^2 \\
&amp; = (y_1 - \hat{\beta}_0 - \hat{\beta}_1 \cdot x_1) + (y_2 - \hat{\beta}_0 - \hat{\beta}_1 \cdot x_2) + \cdots + (y_n - \hat{\beta}_0 - \hat{\beta}_1 \cdot x_n)
\end{align}\]</span></p>
<p>Phương pháp bình phương nhỏ nhất lựa chọn <span class="math inline">\(\hat{\beta}_0\)</span> và <span class="math inline">\(\hat{\beta}_1\)</span> sao cho giá trị của RSS là nhỏ nhất. Bạn đọc có thể giải bài toán tối ưu bằng cách cho đạo hàm của RSS theo <span class="math inline">\(\hat{\beta}_0\)</span> và <span class="math inline">\(\hat{\beta}_1\)</span> bằng 0 và cho kết quả như sau
<span class="math display" id="eq:lm031">\[\begin{align}
\hat{\beta}_1 &amp; = \cfrac{\sum\limits_{i=1}^n (x_i - \bar{x}) (y_i - \bar{y})}{\sum\limits_{i=1}^n (x_i - \bar{x})^2} \\
\hat{\beta}_0 &amp; = \bar{y} - \hat{\beta}_1 \bar{x}
\tag{1.4}
\end{align}\]</span>
trong đó <span class="math inline">\(\bar{y} = \sum\limits_{i=1}^n y_i\)</span> và <span class="math inline">\(\bar{x} = \sum\limits_{i=1}^n x_i\)</span> là các giá trị trung bình của các quan sát.</p>
<p>Hàm số để thực hiện ước lượng mô hình tuyến tính trong R là hàm <code>lm()</code>. Bạn đọc thực hiện câu lệnh ước lương như sau</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co"># Lấy dữ liệu advertising vào R</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>Advertising<span class="ot">&lt;-</span><span class="fu">read.csv</span>(<span class="st">&quot;.../advertise.csv&quot;</span>)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co"># Thực hiện ước lượng mô hình</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co"># Doanh thu bán hàng (Sales) hồi quy theo TV</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="fu">lm</span>(Sales<span class="sc">~</span>TV, <span class="at">data =</span> Advertising)</span></code></pre></div>
<p>Hình <a href="#fig:fglm01">1.1</a> mô tả đường hồi quy tuyến tính đơn được xây dựng trên dữ liệu về quảng cáo với biến phụ thuộc là doanh số bán hàng và biến độc lập là chi phí quảng cáo trên truyền hình, với <span class="math inline">\(\hat{\beta}_0\)</span> = 5.1030285 và <span class="math inline">\(\hat{\beta}_1\)</span> = 0.0240875. Nói cách khác, theo các ước lượng này, thêm 1 triệu đồng chi cho quảng cáo truyền hình có liên quan đến việc tăng thêm khoảng 24.1 triệu từ doanh thu bán hàng.</p>
</div>
<div id="đánh-giá-sự-chính-xác-của-các-ước-lượng" class="section level4 hasAnchor" number="1.1.1.2">
<h4><span class="header-section-number">1.1.1.2</span> Đánh giá sự chính xác của các ước lượng<a href="#đánh-giá-sự-chính-xác-của-các-ước-lượng" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Nhắc lại rằng trong các mô hình học máy có giám sát, mối liên hệ thực tế giữa biến mục tiêu <span class="math inline">\(Y\)</span> và biến phụ thuộc <span class="math inline">\(X\)</span> được mô tả thông qua một hàm <span class="math inline">\(f\)</span>
<span class="math display">\[\begin{align}
Y = f(X) + \epsilon
\end{align}\]</span>
trong đó <span class="math inline">\(\epsilon\)</span> là thành phần hoàn toàn độc lập với biến <span class="math inline">\(X\)</span>, hay nói một cách khác là không thể đưa ra được thêm bất kỳ thông tin nào về <span class="math inline">\(\epsilon\)</span> dựa trên dữ liệu <span class="math inline">\(X\)</span>. Trong trường hợp hàm <span class="math inline">\(f\)</span> thực sự là một hàm tuyến tính, mối liên hệ giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> sẽ được mô tả thông qua hệ số chặn <span class="math inline">\(\beta_0\)</span> và hệ số góc <span class="math inline">\(\beta_1\)</span>
<span class="math display" id="eq:lm04">\[\begin{align}
Y = \beta_0 + \beta_1 X + \epsilon
\tag{1.5}
\end{align}\]</span>
Mô hình tuyến tính trong phương trình <a href="#eq:lm04">(1.5)</a> được gọi là đường hồi quy tuyến tính thật. Trong thực tế, không thể biết được đường hồi quy tuyến tính thật, mà chúng ta chỉ có thể dựa trên các giá trị quan sát được của biến mục tiêu và biến phụ thuộc để ước lượng ra các tham số <span class="math inline">\(\hat{\beta}_0\)</span> và <span class="math inline">\(\hat{\beta}_1\)</span>. Đường thẳng có hệ số chặn <span class="math inline">\(\hat{\beta}_0\)</span> và hệ số góc <span class="math inline">\(\hat{\beta}_1\)</span> được gọi là đường hồi quy tuyến tính ước lượng được.</p>
Để bạn đọc hiểu được chính xác khái niệm về đường hồi quy tuyến tính thật và đường hồi quy tuyến tính ước lượng được, chúng ta hãy quan sát ví dụ sau. Chúng tôi sinh ra <span class="math inline">\(n = 100\)</span> giá trị cho biến phụ thuộc <span class="math inline">\(X\)</span> và biến mục tiêu <span class="math inline">\(Y\)</span> dựa trên phương trình
<span class="math display" id="eq:lm05">\[\begin{align}
Y = 1 + 2 \cdot X + \epsilon
\tag{1.6}
\end{align}\]</span>
trong đó <span class="math inline">\(X\)</span> và <span class="math inline">\(\epsilon\)</span> là các biến ngẫu nhiên phân phối chuẩn có trung bình bằng 0 và độc lập với nhau. Đường thẳng có hệ số góc bằng 2 và hệ số chặn bằng 1 là đường hồi quy thật trong trường hợp này.
<div class="figure"><span style="display:block;" id="fig:fglm02"></span>
<img src="bookdown-demo_files/figure-html/fglm02-1.png" alt="Hình bên trái: Đường hồi quy tuyến tính thật màu đỏ và đường hồi quy tuyến tính ước lượng màu đen. Hình bên phải: Đường hồi quy tuyến tính thật màu đỏ và các đường hồi quy tuyến tính ước lượng màu xanh" width="672" />
<p class="caption">
Figure 1.2: Hình bên trái: Đường hồi quy tuyến tính thật màu đỏ và đường hồi quy tuyến tính ước lượng màu đen. Hình bên phải: Đường hồi quy tuyến tính thật màu đỏ và các đường hồi quy tuyến tính ước lượng màu xanh
</p>
</div>
<p>Đường màu đỏ ở phần bên trái của Hình <a href="#fig:fglm02">1.2</a> hiển thị đường hồi quy tuyến tính thực, <span class="math inline">\(f(x) = 1 + 2 \cdot x\)</span>, trong khi đường màu đen là ước lượng bình phương nhỏ nhất dựa trên dữ liệu quan sát được. Mối quan hệ thực sự thường không thể biết được dữ liệu thực, nhưng đường bình phương nhỏ nhất luôn có thể được ước lượng bằng cách sử dụng phương trình <a href="#eq:lm031">(1.4)</a>. Nói cách khác, trong các ứng dụng thực tế, mỗi khi chúng ta có một tập hợp các quan sát mà từ đó chúng ta có thể tính toán đường bình phương nhỏ nhất; tuy nhiên, đường hồi quy tuyến tính thực là thể quan sát được. Trong phần bên phải của Hình <a href="#fig:fglm02">1.2</a>, chúng tôi đã tạo ra mười bộ dữ liệu khác nhau từ mô hình hồi quy thật và vẽ mười đường bình phương nhỏ nhất tương ứng. Lưu ý rằng các tập dữ liệu khác nhau được tạo ra từ cùng một mô hình thực sẽ dẫn đến các đường bình phương nhỏ nhất hơi khác nhau một chút, nhưng đường hồi quy tổng thể không quan sát được không thay đổi.</p>
<p>Quan sát trên hình vẽ, sự khác biệt giữa đường hồi quy tổng thể và đường bình phương nhỏ nhất có vẻ khó nhận thấy và khó hiểu. Về cơ bản, khái niệm hai đường này là sự mở rộng của phương pháp thống kê tiêu chuẩn về việc sử dụng thông tin từ một mẫu để ước tính các đặc điểm của một tổng thể. Ví dụ, giả sử chúng ta muốn biết trung bình tổng thể <span class="math inline">\(\mu\)</span> của một biến ngẫu nhiên <span class="math inline">\(Y\)</span> nào đó. <span class="math inline">\(\mu\)</span> là một giá trị không biết, nhưng chúng ta có <span class="math inline">\(n\)</span> quan sát từ của <span class="math inline">\(Y\)</span>, mà chúng ta có thể viết là <span class="math inline">\(y_1, y_2, \cdots , y_n\)</span> và chúng ta có thể sử dụng để ước lượng <span class="math inline">\(\mu\)</span>. Một ước lượng hợp lý cho <span class="math inline">\(\mu\)</span> là <span class="math inline">\(\hat{\mu} = \bar{y}\)</span>, trong đó <span class="math inline">\(\bar{y} = \sum\limits_{i=1}^n y_i\)</span> là giá trị trung bình mẫu. Trung bình mẫu và trung bình tổng thể là khác nhau, nhưng nói chung trung bình mẫu sẽ cung cấp ước tính tốt về trung bình tổng thể. Theo cách tương tự, các hệ số chưa biết <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> trong hồi quy tuyến tính xác định đường hồi quy tổng thể. Chúng ta ước lượng các hệ số chưa biết này bằng cách sử dụng <span class="math inline">\(\hat{\beta_0}\)</span> và <span class="math inline">\(\hat{\beta_1}\)</span>.</p>
<p>Sự tương tự giữa ước lượng các hệ số của hồi quy tuyến tính và ước lượng giá trị trung bình của một biến ngẫu nhiên còn được thể hiện qua các tính chất của các ước lượng. Chẳng hạn như chúng ta luôn mong muốn các ước lượng là các ước lượng không chệch. Đối với trung bình tổng thể, chúng ta luôn tìm các ước lượng <span class="math inline">\(\hat{\mu}\)</span> sao cho <span class="math inline">\(\mathbb{E}(\hat{\mu}) = \mu\)</span>. Tính chất không chệch của ước lượng đảm bảo rằng nếu chúng ta có thể có một số lượng đủ lớn các quan sát thì giá trị trung bình mẫu sẽ xấp xỉ giá trị trung bình tổng thể. Các hệ số của mô hình hồi quy tuyến tính bằng phương pháp bình phương nhỏ nhất cũng là các ước lượng không chệch, nghĩa là nếu chúng ta ước lượng <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> trên cơ sở một tập dữ liệu cụ thể thì các ước lượn sẽ không chính xác bằng <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span>. Nhưng nếu chúng ta có thể tính trung bình các ước lượng thu được từ một số lượng lớn tập dữ liệu thì giá trị trung bình của các ước lượng này sẽ xấp xỉ <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span>! Trên thực tế, chúng ta có thể thấy từ bảng bên phải của Hình <a href="#fig:fglm02">1.2</a> rằng giá trị trung bình của nhiều đường bình phương tối thiểu, mỗi đường được ước tính từ một tập dữ liệu riêng biệt, khá gần với đường hồi quy tổng thể thực.</p>
<p>Một câu hỏi khác cần được đặt ra với ước lượng trung bình tổng thể <span class="math inline">\(\mu\)</span> của biến ngẫu nhiên <span class="math inline">\(Y\)</span> là: giá trị trung bình mẫu <span class="math inline">\(\hat{\mu}\)</span> ước tính của <span class="math inline">\(\mu\)</span> chính xác như thế nào? Chúng ta đã biết rằng giá trị trung bình của các <span class="math inline">\(\hat{\mu}\)</span> trên nhiều tập dữ liệu sẽ rất gần với <span class="math inline">\(\mu\)</span>, nhưng một ước tính duy nhất của <span class="math inline">\(\hat{\mu}\)</span> trên một dự liệu cụ thể sẽ chênh lệch với <span class="math inline">\(\mu\)</span> như thế nào? Nhìn chung, để trả lời câu hỏi này chúng ta cần tính độ lệch chuẩn của <span class="math inline">\(\hat{\mu}\)</span>, được ký hiệu là <span class="math inline">\(SE(\hat{\mu})\)</span>. Chúng ta đã biết rằng
<span class="math display">\[\begin{align}
SE(\hat{\mu}) = \cfrac{\sigma}{\sqrt{n}}
\end{align}\]</span>
với <span class="math inline">\(\sigma\)</span> là độ lệch chuẩn của biến <span class="math inline">\(Y\)</span>. <span class="math inline">\(SE(\hat{\mu})\)</span> cho chúng ta biết một ước lượng cụ thể <span class="math inline">\(\hat{\mu}\)</span> sẽ chênh lệch với <span class="math inline">\(\mu\)</span> như thế nào. Có thể dễ dàng thấy rằng khi số lượng quan sát <span class="math inline">\(n\)</span> đủ lớn, <span class="math inline">\(SE(\hat{\mu})\)</span> sẽ càng gần đến 0 và chênh lệch giữa <span class="math inline">\(\hat{\mu}\)</span> với <span class="math inline">\(\mu\)</span> sẽ càng nhỏ. Lập luận hoàn toàn tương tự, để biết các ước lượng cho các hệ số chặn và hệ số góc trong mô hình tuyến tính đơn chênh lệch với các giá trị thật <span class="math inline">\(\beta_0\)</span> và <span class="math inline">\(\beta_1\)</span> như thế nào, chúng ta cần tính toán độ lệch chuẩn của các ước lượng đó. Tính toán độ lệch chuẩn của các ước lượng cho hệ số sẽ được trình bày chi tiết trong các phần sau. Bạn đọc cần biết là độ lệch chuẩn của <span class="math inline">\(\hat{\beta_0}\)</span> và <span class="math inline">\(\hat{\beta_1}\)</span> có thể tính toán được như sau
<span class="math display" id="eq:lm06">\[\begin{align}
SE(\hat{\beta}_0) = \sigma \cdot \sqrt{\cfrac{1}{n} + \cfrac{\bar{x}^2}{\sum\limits_{i=1}^n (x_i - \bar{x})^2} } ; SE(\hat{\beta}_1) = \cfrac{\sigma}{\sqrt{\sum\limits_{i=1}^n (x_i - \bar{x})^2} }
\tag{1.7}
\end{align}\]</span>
trong đó <span class="math inline">\(\sigma = \sqrt{Var(\epsilon)}\)</span>. Các công thức cho độ lệch tiêu chuẩn của <span class="math inline">\(\hat{\beta_0}\)</span> và <span class="math inline">\(\hat{\beta_1}\)</span> ở trên đi kèm với giả định là các sai số <span class="math inline">\(\epsilon_i\)</span> là độc lập với nhau và có cùng phương sai là <span class="math inline">\(\sigma^2\)</span>. Giả thiết này thường không đạt được trong thực tế tuy nhiên công thức <a href="#eq:lm06">(1.7)</a> vẫn là một xấp xỉ tốt cho phương sai của các ước lượng. Lưu ý trong công thức ở trên rằng <span class="math inline">\(SE(\hat{\beta}_1)\)</span> nhỏ hơn khi <span class="math inline">\(x_i\)</span> trải rộng hơn quanh giá trị trung bình của nó. Chúng ta cũng thấy rằng <span class="math inline">\(SE(\hat{\beta}_0)\)</span> sẽ giống như độ lệch chuẩn của trung bình mẫu nếu <span class="math inline">\(\bar{x}\)</span> bằng 0. Điểm đáng lưu ý là <span class="math inline">\(\sigma^2\)</span> cũng là một đại lượng chưa biết chưa nhưng có thể ước lượng được từ dữ liệu. Ước lượng cho <span class="math inline">\(\sigma\)</span> được gọi là độ lệch chuẩn của phần dư, ký hiệu RSE (Residual Standard Error), và được tính theo công thức RSE = .</p>
<p>RSE có thể được sử dụng để tính toán các khoảng tin cậy. Khoảng tin cậy ở một mức xác suất, chẳng hạn như mức <span class="math inline">\(\alpha\)</span>, được định nghĩa là một khoảng giá trị sao cho với xác suất <span class="math inline">\(\alpha\)</span>, khoảng giá trị đó sẽ chứa giá trị thực chưa biết của tham số. Với giả thiết phần dư <span class="math inline">\(\epsilon\)</span> có phân phối chuẩn, có thể chứng minh được rằng <span class="math inline">\(\hat{\beta_0}\)</span> và <span class="math inline">\(\hat{\beta_1}\)</span> cũng có phân phối chuẩn. Khoảng tin cậy ở mức xác suất <span class="math inline">\(\alpha\)</span> được sử dụng là làm các khoảng tin cây cho tham số <span class="math inline">\(\beta_i\)</span> có dạng
<span class="math display">\[\begin{align}
\left[\hat{\beta_i} - z_{1 + \alpha/2} \cdot SE(\hat{\beta_i}); \hat{\beta_i} + z_{1 + \alpha/2} \cdot SE(\hat{\beta_i}) \right]
\end{align}\]</span>
trong đó <span class="math inline">\(z_{1+\alpha/2}\)</span> là giá trị tại mức xác suất <span class="math inline">\((1 + \alpha/2)\)</span> của biến ngẫu nhiên phân phối chuẩn <span class="math inline">\(\mathcal{N}(0,1)\)</span>.</p>
<p>Trong ví dụ về quảng cáo, với mức xác suất <span class="math inline">\(\alpha = 95\%\)</span>, giá trị tại mức xác suất <span class="math inline">\((1 + \alpha/2)\)</span> của phân phối chuẩn <span class="math inline">\(\mathcal{N}(0,1)\)</span> xấp xỉ bằng 1.96; ta có khoảng tin cậy cho hệ số chặn là [3.372; 6.834] và khoảng tin cậy cho hệ số góc là [0.0124; 0.0357]. Điều này có nghĩa là, không tính đến quảng cáo trên truyền hình, doanh thu trung bình của các cửa hàng rơi vào khoảng 3.372 tỷ đồng đến 6.834 tỷ đồng. Đồng thời, mỗi triệu đồng tăng thêm cho quảng cáo trên truyền hình, sẽ làm cho doanh thu trung bình tăng thêm khoảng 12.4 triệu đồng đến 35.7 triệu đồng.</p>
<p>Độ lệch tiêu chuẩn còn được sử dụng để trả lời câu hỏi là liệu mối liên hệ giữa biến <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> có thực sự có ý nghĩa. Theo thống kê toán, chúng ta cần phải kiểm đinh cặp giả thuyết:
<span class="math display">\[\begin{align}
H_0: \beta_1 = 0 \\
H_1: \beta_1 \neq 0
\end{align}\]</span>
vì nếu <span class="math inline">\(\beta_1 = 0\)</span> thì mô hình hồi quy tuyến tính đơn trở thành <span class="math inline">\(Y = \beta_0 + \epsilon\)</span> và <span class="math inline">\(X\)</span> không có liên hệ với <span class="math inline">\(Y\)</span> . Để kiểm định giả thuyết <span class="math inline">\(H_0\)</span>, chúng ta cần xác định xem liệu ước lượng của <span class="math inline">\(\beta_1\)</span>, là <span class="math inline">\(\hat{\beta}_1\)</span>, có đủ xa giá trị 0 để chúng ta có thể tin tưởng rằng <span class="math inline">\(\beta_1\)</span> khác 0 hay không. Nhưng như thế nào là đủ xa thì lại phụ thuộc vào độ chính xác của <span class="math inline">\(\hat{\beta}_1\)</span>, nghĩa là cũng phụ thuộc vào <span class="math inline">\(SE(\hat{\beta}_1)\)</span>. Nếu <span class="math inline">\(\hat{\beta}_1\)</span> tương đối nhỏ, nhưng <span class="math inline">\(SE(\hat{\beta}_1)\)</span> lại rất nhỏ, thì chúng ta vẫn có thể khá chắc chắn rằng <span class="math inline">\(\beta \neq 0\)</span>, và do đó có mối liên hệ giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span>. Ngược lại, nếu <span class="math inline">\(\hat{\beta}_1\)</span> tương đối xa giá trị 0, nhưng <span class="math inline">\(SE(\hat{\beta}_1)\)</span> lại rất lớn, thì cũng rất khó để khẳng định rằng <span class="math inline">\(\beta \neq 0\)</span>. Trong thực tế, chúng ta tính toán một thống kê <span class="math inline">\(t\)</span>
<span class="math display" id="eq:lm07">\[\begin{align}
t = \cfrac{\hat{\beta}_1 - 0}{SE(\hat{\beta}_1)}
\tag{1.8}
\end{align}\]</span>
dùng để đo độ lệch tương đối giữa <span class="math inline">\(\hat{\beta}\)</span> với giá trị 0. Với giả thiết <span class="math inline">\(\epsilon\)</span> có phân phối chuẩn, và dưới giả thuyết <span class="math inline">\(H_0\)</span>, có thể chứng minh được rằng thống kê <span class="math inline">\(t\)</span> sẽ có phân phối <span class="math inline">\(student\)</span> với bậc tự do là <span class="math inline">\(n-2\)</span>. Phân phối <span class="math inline">\(student\)</span> cũng có hình dạng quả chuông giống như phân phối chuẩn và sẽ tiệm cận phân phối chuẩn nếu tham số bậc tự do đủ lớn. Do đó, chúng ta có thể tính toán được xác suất mà một biến ngẫu nhiên phân phối <span class="math inline">\(student\)</span> bất kỳ có giá trị tuyệt đối lớn hơn hoặc bằng giá trị thống kê <span class="math inline">\(t\)</span> tính toán được trong phương trình <a href="#eq:lm07">(1.8)</a>. Xác suất này còn thường được gọi là <span class="math inline">\(p-value\)</span>. Nhìn chung, chúng ta có thể suy diễn <span class="math inline">\(p-value\)</span> như sau: nếu <span class="math inline">\(p-value\)</span> nhận giá trị nhỏ thì rất khó có thể có được giá trị thống kê <span class="math inline">\(t\)</span> có giá trị tuyệt đối lớn như vậy dưới giả thuyết <span class="math inline">\(H_0\)</span>, nghĩa là có cơ sở để bác bỏ giả thuyết <span class="math inline">\(H_0\)</span>. Hay nói một cách khác, có mối liên hệ giữa biến độc lập và biến mục tiêu. Giá trị <span class="math inline">\(p-value\)</span> thường được coi là nhỏ nếu nằm dưới các ngưỡng như 5% hoặc thậm chí 1%.</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm01">Table 1.1: </span><span id="tab:tblm01">Table 1.2: </span>Các hệ số ước lượng trong mô hình hồi quy đơn cho dữ liệu Quảng cáo.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Hệ số
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hệ số chặn
</td>
<td style="text-align:right;">
5.1030
</td>
<td style="text-align:right;">
0.8830
</td>
<td style="text-align:right;">
5.7794
</td>
<td style="text-align:right;">
0.0000004
</td>
</tr>
<tr>
<td style="text-align:left;">
Hệ số góc
</td>
<td style="text-align:right;">
0.0241
</td>
<td style="text-align:right;">
0.0059
</td>
<td style="text-align:right;">
4.0558
</td>
<td style="text-align:right;">
0.0001648
</td>
</tr>
</tbody>
</table>
<p>Bảng <a href="#tab:tblm01">1.1</a> cung cấp thông tin chi tiết về tham số ước lượng được trong mô hình hồi quy tuyến tính đơn bằng phương pháp bình phương nhỏ nhất để hồi quy doanh thu bán hàng đơn theo ngân sách quảng cáo trên truyền hình trong dữ liệu về quảng cáo. Lưu ý rằng các hệ số <span class="math inline">\(\hat{\beta_0}\)</span> và <span class="math inline">\(\hat{\beta_1}\)</span> rất lớn so với độ lệch chuẩn của các ước lượng này, do đó giá trị thống kê t cũng lớn. Xác suất để một biến ngẫu nhiên phân phối <span class="math inline">\(student\)</span> có tham số bậc tự do bằng 55 - 2 = 53 có giá trị lớn hơn các giá trị tuyệt đối của thống kê <span class="math inline">\(t\)</span> dưới giả thuyết <span class="math inline">\(H_0\)</span> đúng là gần như bằng 0. Do đó chúng ta có thể kết luận rằng <span class="math inline">\(\beta_0 \neq 0\)</span> và <span class="math inline">\(\beta_1 \neq 0\)</span>.</p>
</div>
<div id="đánh-giá-mô-hình-hồi-quy-tuyến-tính-đơn" class="section level4 hasAnchor" number="1.1.1.3">
<h4><span class="header-section-number">1.1.1.3</span> Đánh giá mô hình hồi quy tuyến tính đơn<a href="#đánh-giá-mô-hình-hồi-quy-tuyến-tính-đơn" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Sau khi chúng ta đã bác bỏ giả thuyết về các hệ số bằng 0, công việc tiếp theo sẽ là đưa ra các đánh giá định lượng về mức độ phù hợp của mô hình với dữ liệu. Chất lượng của mô hình hồi quy tuyến tính thường được đánh giá bằng cách sử dụng hai đại lượng: thứ nhất: độ lệch chuẩn của phần dư (RSE) và hệ số <span class="math inline">\(R^2\)</span>.</p>
<p>Độ lệch chuẩn của phần dư, được viết tắt là RSE (Residual Standard Error). Phần dư trong mô hình tuyến tính là phần độc lập với biến giải thích <span class="math inline">\(X\)</span>, nghĩa là trong các mô hình có sự hiện diện của phần dư, ngay cả khi chúng ta biết được đường hồi quy thực cũng không thể đưa ra dự đoán chính xác được về <span class="math inline">\(Y\)</span> từ <span class="math inline">\(X\)</span>. Phần dư luôn có giá trị trung bình bằng 0 vì nếu không phần giá trị trung bình sẽ được giải thích bằng hệ số chặn. Do đó, người xây dựng mô hình thường quan tâm đến độ lệch chuẩn của phần dư, hay còn gọi là RSE
<span class="math display" id="eq:lm08">\[\begin{align}
RSE = \sqrt{\cfrac{RSS}{n-2}} = \sqrt{\cfrac{\sum\limits_{i=1}^n (y_i - \hat{y}_i)^2 }{n-2}}
\tag{1.9}
\end{align}\]</span></p>
<p>Trong mô hình hồi quy tuyến tính trên dữ liệu Quảng cáo, RSE bằng 0.235. Điều này có nghĩa là sai số giữa doanh thu bán hàng thực tế và doanh thu bán hàng được ước lượng từ mô hình hồi quy tuyến tính sẽ có độ lệch chuẩn khoảng 0.235 tỷ đồng. Tuy nhiên, độ lệch chuẩn là 0.235 có phải là con số có thể chấp nhận được hay không còn tùy thuộc vào bối cảnh. Trong dữ liệu quảng cáo, giá trị trung bình của doanh số bán hàng trên tất cả các cửa hàng là khoảng 8.7 tỷ đồng và do đó sai số phần trăm là khoảng 0.235/8.7 <span class="math inline">\(\approx\)</span> 2.7 %. RSE có thể coi là thước đo mức độ phù hợp của các mô hình tuyến tính trên dữ liệu. Nếu các dự đoán thu được bằng cách sử dụng mô hình rất gần với giá trị kết quả thực, tức là, nếu các <span class="math inline">\(\hat{y}_i\)</span> rất gần với các <span class="math inline">\(y_i\)</span>, với <span class="math inline">\(i = 1, 2, \cdots, n\)</span>, khi đó RSE sẽ nhỏ và chúng ta có thể kết luận rằng mô hình rất phù hợp với dữ liệu. Mặt khác, <span class="math inline">\(\hat{y}_i\)</span> rất xa các <span class="math inline">\(y_i\)</span> đối với một hoặc nhiều quan sát thì RSE có thể khá lớn, cho thấy mô hình không phù hợp với dữ liệu.</p>
<p>RSE là một thước đo tuyệt đối về sự phù hợp hay không của mô hình hồi quy tuyến tính trên dữ liệu. Nhưng vì RSE được đo bằng độ lệch chuẩn nên khi tính toán RSE tương đối trên giá trị trung bình của <span class="math inline">\(Y\)</span> sẽ không cho chúng ta một cái nhìn chính xác thế nào là một RSE tốt. Thay vào đó, hệ số <span class="math inline">\(R^2\)</span> cung cấp một thước đo tương đối về mức độ phù hợp của mô hình. <span class="math inline">\(R^2\)</span> có dạng tỷ lệ giữa phương sai được giải thích trên tổng phương sai nên hệ số này luôn nhận giá trị từ 0 đến 1 và không phụ thuộc vào đơn vị của biến <span class="math inline">\(Y\)</span>. Hệ số <span class="math inline">\(R^2\)</span>, hay còn được gọi là <span class="math inline">\(R-squared\)</span>, được tính bằng công thức sau
<span class="math display" id="eq:lm08">\[\begin{align}
R^2 = \cfrac{TSS - RSS}{TSS} = 1 - \cfrac{RSS}{TSS}
\tag{1.9}
\end{align}\]</span>
với <span class="math inline">\(TSS = \sum (y_i - \bar{y})^2\)</span>.</p>
<p><span class="math inline">\(TSS\)</span> (Total Sum of Squares) là tổng phương sai của biến mục tiêu <span class="math inline">\(Y\)</span> và có thể được coi là mức độ biến thiên của biến mục tiêu xung quanh giá trị trung bình của nó. Giá trị này không phụ thuộc vào mô hình hồi quy tuyến tính. <span class="math inline">\(RSS\)</span> đo lường mức độ biến thiên mà không giải thích được bởi mô hình hồi quy tuyến tính. Do đó, <span class="math inline">\(TSS − RSS\)</span> đo lường mức độ biến thiên được giải thích bằng cách thực hiện hồi quy và hệ số <span class="math inline">\(R^2\)</span> đo lường tỷ lệ biến thiên của biến mục tiêu <span class="math inline">\(Y\)</span> có thể được giải thích bằng biến giải thích <span class="math inline">\(X\)</span> trong mô hình tuyến tính. Hệ số <span class="math inline">\(R^2\)</span> gần bằng 1 cho biết rằng phần lớn sự biến thiên trong biến mục tiêu đã được giải thích bằng mô hình hồi quy. Giá trị <span class="math inline">\(R^2\)</span> càng gần 0 cho thấy mô hình hồi quy không giải thích được nhiều về sự biến thiên của biến mục tiêu. Mô hình có <span class="math inline">\(R^2\)</span> nhỏ thông thường là do dạng của mô hình tuyến tính là sai, mô hình tuyến tính bị thiếu biến giải thích, hoặc do phần dư <span class="math inline">\(\epsilon\)</span> có phương sai lớn.</p>
<p>Các đại lượng <span class="math inline">\(RSS\)</span>, <span class="math inline">\(RSE\)</span>, <span class="math inline">\(TSS\)</span>, và <span class="math inline">\(R^2\)</span> trong mô hình tuyến tính đơn mà biến mục tiêu doanh thu được hồi quy theo chi phí quảng cáo trên truyền hình được cho trong bảng <a href="#tab:tblm02">1.3</a></p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm02">Table 1.3: </span><span id="tab:tblm02">Table 1.4: </span>Đo lường mức độ phù hợp của mô hình tuyến tính đơn trên dữ liệu Quảng cáo
</caption>
<thead>
<tr>
<th style="text-align:left;">
Đại lượng
</th>
<th style="text-align:left;">
Ký hiệu
</th>
<th style="text-align:right;">
Giá trị
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Residual sum of squares
</td>
<td style="text-align:left;">
RSS
</td>
<td style="text-align:right;">
2.925
</td>
</tr>
<tr>
<td style="text-align:left;">
Residual standard error
</td>
<td style="text-align:left;">
RSE
</td>
<td style="text-align:right;">
0.235
</td>
</tr>
<tr>
<td style="text-align:left;">
Total sum of squares
</td>
<td style="text-align:left;">
TSS
</td>
<td style="text-align:right;">
3.833
</td>
</tr>
<tr>
<td style="text-align:left;">
R-squares
</td>
<td style="text-align:left;">
<span class="math inline">\(R^2\)</span>
</td>
<td style="text-align:right;">
0.237
</td>
</tr>
</tbody>
</table>
<p>Trong Bảng <a href="#tab:tblm02">1.3</a>, <span class="math inline">\(R^2\)</span> bằng 0.237 có nghĩa là chỉ 23.7% sự biến thiên trong doanh số được giải thích bằng hồi quy tuyến tính theo chi phí quảng cáo trên truyền hình. Rõ ràng, hệ số <span class="math inline">\(R^2\)</span> dễ dàng diễn giải hơn so với <span class="math inline">\(RSE\)</span>, vì đại lượng này luôn nằm trong khoảng từ 0 đến 1. Tuy nhiên, vẫn có thể gặp khó khăn khi xác định thế nào là giá trị <span class="math inline">\(R^2\)</span> tốt. Điều này lại tùy thuộc vào từng ngữ cảnh thực tế. Ví dụ, trong một số dữ liệu thu thập được từ vật lý hay khoa học máy tính, chúng ta có thể đã biết rằng dữ liệu thực sự đến từ một mô hình tuyến tính có phần dư nhỏ. Hệ số <span class="math inline">\(R^2\)</span> thu được sẽ xấp xỉ bằng 1 và giá trị <span class="math inline">\(R^2\)</span> nhỏ hơn 0.9 có thể cho thấy có vấn đề với thử nghiệm mà dữ liệu được tạo ra. Mặt khác, trong các ứng dụng điển hình về kinh tế hay xã hội học, các mô hình tuyến tính thường có phần dư có phương sai rất lớn do có rất nhiều các yếu tố khác không được đo lường được từ dữ liệu. Trong trường hợp này, chúng ta chỉ cần một tỷ lệ phương sai được giải thích rất nhỏ. Hệ số <span class="math inline">\(R^2\)</span> bằng 0.05 hoặc 0.1 trong các dữ liệu như vậy lại có thể là bằng chứng cho một mô hình tốt!</p>
<p>Trong mô hình hồi quy tuyến tính đơn biến, giá trị <span class="math inline">\(R^2\)</span> chính là bình phương của hệ số tương quan giữa biến mục tiêu <span class="math inline">\(Y\)</span> và biến độc lập <span class="math inline">\(X\)</span>. Hệ số tương quan giữa <span class="math inline">\(Y\)</span> và <span class="math inline">\(X\)</span>, ký hiệu <span class="math inline">\(\rho{X,Y}\)</span>, và được ước lượng bằng công thức như sau
<span class="math display">\[\begin{align}
\hat{\rho}(X,Y) = \cfrac{ \sum\limits_{i=1}^n (x_i - \bar{x})(y_i - \bar{y}) }{ \sqrt{\sum\limits_{i=1}^n (x_i - \bar{x})^2}\sqrt{\sum\limits_{i=1}^n (y_i - \bar{y})^2} }
\end{align}\]</span></p>
<p>Hệ số tương quan <span class="math inline">\(\rho(X,Y)\)</span> đo lường mối liên hệ tuyến tính giữa hai biến <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span>. Hệ số <span class="math inline">\(\rho(X,Y)\)</span> nằm trong khoảng <span class="math inline">\([-1,1]\)</span>, và</p>
<ul>
<li><p>Khi <span class="math inline">\(\rho(X,Y) = 0\)</span>, chúng ta nói rằng giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> không có mối liên hệ tuyến tính.</p></li>
<li><p>Khi <span class="math inline">\(\rho(X,Y) &gt; 0\)</span>, chúng ta nói rằng giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> có mối liên hệ tuyến tính cùng chiều, nghĩa là khi <span class="math inline">\(X\)</span> tăng thì nhiều khả năng <span class="math inline">\(Y\)</span> cũng sẽ tăng theo một tỷ lệ cố định.</p></li>
<li><p>Khi <span class="math inline">\(\rho(X,Y) &lt; 0\)</span>, chúng ta nói rằng giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> có mối liên hệ tuyến tính ngược chiều, nghĩa là khi <span class="math inline">\(X\)</span> tăng thì nhiều khả năng <span class="math inline">\(Y\)</span> sẽ giảm theo một tỷ lệ cố định.</p></li>
</ul>
<p>Bạn đọc hãy lưu ý rằng đẳng thức <span class="math inline">\(R^2 = \left(\hat{\rho}(X,Y)\right)^2\)</span> chỉ đúng trong mô hình hồi quy đơn biến. Trong phần tiếp theo, chúng ta sẽ thảo luận về mô hình hồi quy tuyến tính đa biến, trong đó chúng ta sẽ sử dụng đồng thời nhiều biến độc lập để giải thích một biến mục tiêu. Chúng ta sẽ thấy nhiều hơn ý nghĩa của hệ số <span class="math inline">\(R^2\)</span> trong các mô hình như vậy.</p>
</div>
</div>
<div id="mô-hình-hồi-quy-tuyến-tính-đa-biến" class="section level3 hasAnchor" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Mô hình hồi quy tuyến tính đa biến<a href="#mô-hình-hồi-quy-tuyến-tính-đa-biến" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Hồi quy tuyến tính đơn là một phương pháp hữu ích để dự đoán biến mục tiêu dựa trên một biến giải thích duy nhất. Tuy nhiên, trong thực tế chúng ta thường có nhiều hơn một yếu tố để giải thích biến mục tiêu. Ví dụ: trong dữ liệu Quảng cáo, chúng ta đã kiểm tra mối quan hệ giữa doanh thu bán hàng và ngân sách quảng cáo trên truyền hình. Chúng ta cũng có dữ liệu về số tiền chi cho quảng cáo trên các mạng xã hội và quảng cáo thông qua tờ rơi, do đó chúng ta sẽ muốn biết rằng liệu các phương thức quảng cáo này có liên quan đến doanh thu bán hàng hay không; nghĩa là làm cách nào chúng ta có thể mở rộng phân tích dữ liệu Quảng cáo để phù hợp khi bổ sung thêm hai biến giải thích.</p>
<p>Bạn đọc có thể sử dụng ba mô hình hồi quy tuyến tính đơn riêng biệt, mỗi mô hình sử dụng một biến giải thích tương ứng với một phương thức quảng cáo khác nhau làm biến giải thích. Kết quả ước lượng ba mô hình tuyến tính đơn được cho trong Bảng <a href="#tab:tblm03">1.5</a></p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm03">Table 1.5: </span><span id="tab:tblm03">Table 1.6: </span>Ước lượng ba mô hình đơn biến dữ liệu quảng cáo
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
5.1030
</td>
<td style="text-align:right;">
0.8830
</td>
<td style="text-align:right;">
5.7794
</td>
<td style="text-align:right;">
0.0000004
</td>
</tr>
<tr>
<td style="text-align:left;">
TV
</td>
<td style="text-align:right;">
0.0241
</td>
<td style="text-align:right;">
0.0059
</td>
<td style="text-align:right;">
4.0558
</td>
<td style="text-align:right;">
0.0001648
</td>
</tr>
</tbody>
</table>
<table class="table" style="margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
6.6896
</td>
<td style="text-align:right;">
0.3583
</td>
<td style="text-align:right;">
18.6689
</td>
<td style="text-align:right;">
0e+00
</td>
</tr>
<tr>
<td style="text-align:left;">
Social_Media
</td>
<td style="text-align:right;">
0.0792
</td>
<td style="text-align:right;">
0.0142
</td>
<td style="text-align:right;">
5.5779
</td>
<td style="text-align:right;">
8e-07
</td>
</tr>
</tbody>
</table>
<table class="table" style="margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
6.1608
</td>
<td style="text-align:right;">
0.5266
</td>
<td style="text-align:right;">
11.6981
</td>
<td style="text-align:right;">
0.00e+00
</td>
</tr>
<tr>
<td style="text-align:left;">
Flyer
</td>
<td style="text-align:right;">
0.0512
</td>
<td style="text-align:right;">
0.0107
</td>
<td style="text-align:right;">
4.7951
</td>
<td style="text-align:right;">
1.36e-05
</td>
</tr>
</tbody>
</table>
<p>Bạn đọc có thể nhận thấy rằng nếu sử dụng ba mô hình hồi quy đơn, các biến giải thích đều có tác động lên biến mục tiêu một cách có ý nghĩa do các giá trị p-value đều rất nhỏ. Chúng ta sẽ thảo luận chi tiết về các hệ số tuyến tính trong Bảng <a href="#tab:tblm03">1.5</a> trong phần sau của cuốn sách. Tuy nhiên cách tiếp cận như trên sẽ gặp phải hai vấn đề. Thứ nhất: chúng ta sẽ không biết làm thế nào để đưa ra một dự đoán duy nhất về doanh thu bán hàng tương ứng với một phân bổ ngân sách quảng cáo cho ba hình thức quảng cáo, vì khi phân bổ ngân sách đến từng phương tiện quảng cáo sẽ có ba giá trị dự đoán riêng biệt. Thứ hai, mỗi phương trình hồi quy đơn đều bỏ qua hai phương tiện còn lại trong việc hình thành ước tính cho các hệ số hồi quy. Chúng ta sẽ sớm thấy rằng nếu ngân sách truyền thông có tương quan với nhau tại các cửa hàng, điều mà rất có thể xảy ra, thì điều này có thể dẫn đến những ước lượng có sai lệch rất lớn về tác động của từng phương tiện quảng cáo lên doanh thu bán hàng.</p>
<p>Thay vì điều chỉnh một mô hình hồi quy tuyến tính đơn giản riêng biệt cho từng yếu tố dự đoán, cách tiếp cận tốt hơn là mở rộng mô hình hồi quy tuyến tính đơn bằng cách cho tương ứng với mỗi biến giải thích một hệ số góc riêng. Nói chung, giả sử rằng chúng ta có <span class="math inline">\(p\)</span> biến giải thích riêng biệt. Khi đó mô hình hồi quy tuyến tính đa biến có dạng
<span class="math display" id="eq:lm100">\[\begin{align}
Y = \beta_0 + \beta_1 \cdot X_1 + \beta_2 \cdot X_2 + \cdots + \beta_p \cdot X_p + \epsilon
\tag{1.10}
\end{align}\]</span>
trong đó <span class="math inline">\(X_j\)</span> đại diện cho biến giải thích thứ <span class="math inline">\(j\)</span> và hệ số <span class="math inline">\(\beta_j\)</span> định lượng mối liên hệ tuyến tính giữa biến giải thích đó và biến mục tiêu. Có thể coi <span class="math inline">\(\beta_j\)</span> là đại lượng phản ánh sự thay đổi của biến mục tiêu <span class="math inline">\(Y\)</span> khi biến giải thích <span class="math inline">\(X_j\)</span> tăng thêm một đơn vị trong khi tất cả các biến giải thích khác không thay đổi. Trong ví dụ về dữ liệu quảng cáo, ta có mô hình hồi quy tuyến tính như sau
<span class="math display" id="eq:lm101">\[\begin{align}
Sales = \beta_0 + \beta_1 \times TV + \beta_2 \times Social\_Media + \beta_3 \times Flyer + \epsilon
\tag{1.11}
\end{align}\]</span>
trong đó <span class="math inline">\(Sales\)</span> là doanh thu từ bán hàng của 55 cửa hàng, <span class="math inline">\(TV\)</span> là chi phí quảng cáo trên truyền hình, <span class="math inline">\(Social\_Media\)</span> là chi phí quảng cáo qua mạng xã hội, và <span class="math inline">\(Flyer\)</span> là chi phí quảng cáo qua tờ rơi.</p>
<div id="ước-lượng-tham-số-cho-mô-hình-đa-biến" class="section level4 hasAnchor" number="1.1.2.1">
<h4><span class="header-section-number">1.1.2.1</span> Ước lượng tham số cho mô hình đa biến<a href="#ước-lượng-tham-số-cho-mô-hình-đa-biến" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Tương tự như trong mô hình hồi quy tuyến tính đơn, các hệ số hồi quy <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\beta_1\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(\beta_p\)</span> trong phương trình <a href="#eq:lm100">(1.10)</a> là chưa biết và cần được ước lượng. Các tham số này cũng được ước lượng bằng cách sử dụng phương pháp bình phương nhỏ nhất. Tuy nhiên, không giống như các ước lượng hồi quy tuyến tính đơn, các ước lượng hệ số hồi quy đa biến khá phức tạp cần được biểu diễn dưới dạng véc-tơ và ma trận. Chính vì lý do này, chúng tôi không đi sâu vào vấn đề này ở đây. Chi tiết của phương pháp bình phương nhỏ nhất trong hồi quy đa biến bạn đọc có thể tham khảo trong phần <a href="#leastsquared">1.2</a>. Với các ước lượng <span class="math inline">\(\hat{\beta}_0\)</span>, <span class="math inline">\(\hat{\beta}_1\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(\hat{\beta}_p\)</span> chúng ta có thể đưa ra dự đoán cho biến mục tiêu <span class="math inline">\(y\)</span> như sau
<span class="math display" id="eq:lm102">\[\begin{align}
\hat{y} = \hat{\beta}_0 + \hat{\beta}_1 \cdot x_1 + \hat{\beta}_2 \cdot x_2 + \cdots + \hat{\beta}_p \cdot x_p
\tag{1.12}
\end{align}\]</span></p>
<p>Bạn đọc có thể sử dụng hàm <code>lm()</code> để thực hiện ước lượng các hệ số tuyến tính. Chúng ta thực hiện ước lượng mô hình đa biến cho dữ liệu Quảng cáo như sau</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># Doanh thu bán hàng (Sales) hồi quy theo 3 biến</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">lm</span>(Sales <span class="sc">~</span> TV <span class="sc">+</span> Social_Media <span class="sc">+</span> Flyer, <span class="at">data =</span> Advertising)</span></code></pre></div>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm04">Table 1.7: </span><span id="tab:tblm04">Table 1.8: </span>Các hệ số ước lượng trong mô hình hồi quy đa biến cho dữ liệu Quảng cáo.
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
4.0915
</td>
<td style="text-align:right;">
0.7361
</td>
<td style="text-align:right;">
5.5586
</td>
<td style="text-align:right;">
0.0000010
</td>
</tr>
<tr>
<td style="text-align:left;">
TV
</td>
<td style="text-align:right;">
0.0163
</td>
<td style="text-align:right;">
0.0057
</td>
<td style="text-align:right;">
2.8480
</td>
<td style="text-align:right;">
0.0063263
</td>
</tr>
<tr>
<td style="text-align:left;">
Social_Media
</td>
<td style="text-align:right;">
0.0630
</td>
<td style="text-align:right;">
0.0147
</td>
<td style="text-align:right;">
4.2884
</td>
<td style="text-align:right;">
0.0000802
</td>
</tr>
<tr>
<td style="text-align:left;">
Flyer
</td>
<td style="text-align:right;">
0.0117
</td>
<td style="text-align:right;">
0.0123
</td>
<td style="text-align:right;">
0.9566
</td>
<td style="text-align:right;">
0.3432658
</td>
</tr>
</tbody>
</table>
<p>Bảng <a href="#tab:tblm04">1.7</a> hiển thị ước tính hệ số hồi quy bội khi ngân sách quảng cáo trên truyền hình, mạng xã hội, và tờ rơi được sử dụng để dự đoán doanh thu bán sản phẩm trên dữ liệu Quảng cáo. Chúng ta có thể giải thích những kết quả này như sau:</p>
<ul>
<li><p>Đối với một ngân sách cố định cho quảng cáo trên truyền hình và một ngân sách cố định cho quảng cáo qua mạng xã hội, việc chi thêm 1 triệu đồng cho quảng cáo bằng hình thức tờ rơi sẽ dẫn đến doanh thu bán hàng trung bình tăng khoảng 11.7 triệu đồng. Con số tương tự với quảng cáo trên truyền hình và qua mạng xã hội lần lượt là 63 triệu đồng và 16.3 triệu đồng. So sánh các con số này với Bảng <a href="#tab:tblm03">1.5</a>, chúng ta có thể nhận thấy rằng các hệ số ước lượng đã thay đổi đáng kể so với việc sử dụng ba mô hình hồi quy đơn biến.</p></li>
<li><p>Trong mô hình hồi quy đơn, hệ số tuyến tính của biến chi phí quảng cáo qua tờ rơi (<span class="math inline">\(Flyer\)</span>) là có ý nghĩa, trong khi trong mô hình hồi quy đa biến, hệ số của biến này lại không khác 0 một cách có ý nghĩa. Điều này thể hiện qua giá trị của thống kê <span class="math inline">\(t\)</span> khá nhỏ và <span class="math inline">\(p-value\)</span> khá lớn (khoảng 0.343)</p></li>
</ul>
<p>Sự khác biệt này xuất phát từ thực tế là trong trường hợp hồi quy đơn, hệ số góc thể hiện tác động trung bình của việc tăng 1 triệu đồng trong quảng cáo qua tờ rơi và bỏ qua các yếu tố dự đoán khác là quảng cáo qua truyền hình và qua mạng xã hội. Ngược lại, trong mô hình hồi quy đa biến, hệ số tuyến tính của biến <span class="math inline">\(Flyer\)</span> thể hiện tác động trung bình của việc tăng chi phí quảng cáo qua tờ rơi thêm 1 triệu đồng trong khi giữ nguyên chi phí quảng cáo trên truyền hình và qua mạng xã hội. Vậy liệu có hợp lý không khi mô hình hồi quy đa biến cho thấy không có mối quan hệ giữa doanh thu bán hàng và chi phí quảng cáo qua tờ rơi trong khi hồi quy tuyến tính đơn lại hàm ý ngược lại? Câu trả lời là có! Hãy quan sát ma trận hệ số tương quan của ba biến giải thích và biến mục tiêu trong Bảng <a href="#tab:tblm05">1.9</a>.</p>
<table>
<caption><span id="tab:tblm05">Table 1.9: </span>Ma trận hệ số tương quan của các biến trong dữ liệu Quảng cáo</caption>
<thead>
<tr class="header">
<th align="left"></th>
<th align="right">Sales</th>
<th align="right">TV</th>
<th align="right">Social_Media</th>
<th align="right">Flyer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Sales</td>
<td align="right">1.00</td>
<td align="right">0.49</td>
<td align="right">0.61</td>
<td align="right">0.55</td>
</tr>
<tr class="even">
<td align="left">TV</td>
<td align="right">0.49</td>
<td align="right">1.00</td>
<td align="right">0.18</td>
<td align="right">0.54</td>
</tr>
<tr class="odd">
<td align="left">Social_Media</td>
<td align="right">0.61</td>
<td align="right">0.18</td>
<td align="right">1.00</td>
<td align="right">0.51</td>
</tr>
<tr class="even">
<td align="left">Flyer</td>
<td align="right">0.55</td>
<td align="right">0.54</td>
<td align="right">0.51</td>
<td align="right">1.00</td>
</tr>
</tbody>
</table>
<p>Bạn đọc có thể thấy rằng hệ số tương quan giữa chi phí quảng cáo qua tờ rơi với hai biến giải thích còn lại là khá cao, lần lượt là 0.54 và 0.51. Điều này cho thấy xu hướng chi tiêu nhiều hơn cho quảng cáo qua hình thức tờ rơi ở các cửa hàng nơi chi tiêu nhiều hơn cho quảng cáo trên qua truyền hình hoặc qua mạng xã hội. Các mô hình hồi quy đơn và mô hình hồi quy đa biến đều cho kết luận là tăng chi tiêu quảng cáo qua truyền hình và quảng cáo qua mạng xã hội thực sự có ý nghĩa làm tăng doanh thu. Giả sử rằng kết luận này là đúng, khi đó việc sử dụng mô hình hồi quy tuyến tính đơn để kiểm tra mối liên hệ giữa doanh thu bán hàng theo quảng cáo trên tờ rơi cho hệ số ước lượng có ý nghĩa là do cả hai biến này đều có tương quan cao với chi phí quảng cáo qua truyền hình và mạng xã hội, chứ thực sự thì chi tiêu cho quảng cáo qua tờ rơi không có tác động đến doanh thu bán hàng.</p>
<p>Đây là kết quả rất thường gặp khi xây dựng mô hình trên dữ liệu thực tế. Một ví dụ thường được nhắc đến để mô tả tình huống này trong nhiều sách tham khảo là khi hồi quy số các cuộc tấn công của cá mập theo doanh số bán kem trên các bãi biển trong một khoảng thời gian nhất định. Đây là hai biến về bản chất không có mối liên hệ nhưng sẽ cho hệ số góc là một số dương có ý nghĩa thống kê. Cũng giống như chi phí quảng cáo qua hình thức tờ rơi và doanh thu bán hàng, việc không tính đến các biến giải thích có tác động thực sự lên biến mục tiêu sẽ khiến cho chúng ta lầm tưởng rằng doanh số bán kem có tác động đến số cuộc tấn công của cá mập! Trên thực tế, nhiệt độ cao hơn khiến nhiều người đến bãi biển hơn, từ đó dẫn đến doanh số bán kem nhiều hơn và nhiều vụ cá mập tấn công hơn. Nếu chúng ta xây dựng mô hình hồi quy bội mà số các cuộc tấn công của cá mập phụ thuộc vào doanh số bán kem và nhiệt độ của vùng đó sẽ cho kết quả là doanh số bán kem không còn có ý nghĩa giải thích số các cuộc tấn công!</p>
</div>
<div id="kiểm-định-mô-hình-tuyến-tính-đa-biến" class="section level4 hasAnchor" number="1.1.2.2">
<h4><span class="header-section-number">1.1.2.2</span> Kiểm định mô hình tuyến tính đa biến<a href="#kiểm-định-mô-hình-tuyến-tính-đa-biến" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Mục đích của kiểm định mô hình đa biến là để trả lời hai câu hỏi</p>
<ul>
<li><p>Thứ nhất: mô hình hồi quy có ý nghĩa giải thích biến mục tiêu <span class="math inline">\(Y\)</span> hay không? Hay nói một cách khác là có ít nhất một biến trong số các biến giải thích <span class="math inline">\(X_1\)</span>, <span class="math inline">\(X_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(X_p\)</span> có tác động lên biến mục tiêu?</p></li>
<li><p>Thứ hai: nếu mô hình hồi quy đa biến có ý nghĩa, thì tất cả các biến đều có ý nghĩa tác động lên biến mục tiêu, hay chỉ một tập hợp con các biến có tác động?</p></li>
</ul>
<p>Để trả lời cho câu hỏi thứ nhất, nhắc lại với bạn đọc rằng trong kiểm định mô hình hồi quy tuyến tính đơn, để xác định liệu có mối quan hệ giữa biến mục tiêu và biến giải thích hay không, chúng ta chỉ cần kiểm định giả thuyết <span class="math inline">\(H_0: \beta_1 = 0\)</span>. Trong mô hình hồi quy đa biến với <span class="math inline">\(p\)</span> biến giải thích dự đoán, chúng ta cần kiểm định giả thuyết liệu hệ số hồi quy của tất cả các biến giải thích đều bằng 0, tức là liệu có xảy ra trường hợp <span class="math inline">\(\beta_1 = \beta_2 = \cdots = \beta_p = 0\)</span>. Cặp giả thuyết <span class="math inline">\(H_0\)</span> - <span class="math inline">\(H_1\)</span> trong mô hình hồi quy đa biến được viết như sau
<span class="math display" id="eq:lm103">\[\begin{align}
&amp; H_0: \beta_1 = \beta_2 = \cdots = \beta_p = 0 \\
&amp; H_1: \text{ít nhất có một } \beta_j \text{ khác 0}
\tag{1.13}
\end{align}\]</span></p>
<p>Để kiểm định cặp giả thuyết trong <a href="#eq:lm103">(1.13)</a>, chúng ta sử dụng thống kê <span class="math inline">\(F\)</span>
<span class="math display" id="eq:lm104">\[\begin{align}
F = \cfrac{(TSS - RSS)/p}{RSS/(n-p-1)}
\tag{1.14}
\end{align}\]</span></p>
<p>Nếu giả thuyết <span class="math inline">\(H_0\)</span> là đúng thì thống kê <span class="math inline">\(F\)</span> sẽ có phân phối <span class="math inline">\(\mathcal{F}(p, n - p - 1)\)</span>. Do giá trị trung bình của biến ngẫu nhiên phân phối <span class="math inline">\(\mathcal{F}(p, n - p - 1)\)</span> là 1 nên khi giá trị thống kê <span class="math inline">\(F\)</span> lớn thì khả năng bác bỏ giả thuyết <span class="math inline">\(H_0\)</span> là lớn. Để hiểu được tại sao lại sử dụng phân phối <span class="math inline">\(\mathcal{F}\)</span> để kiểm định giả thuyết, bạn đọc tham khảo phần <a href="#leastsquared">1.2</a>. Chúng tôi không giải thích chi tiết vấn đề này tại đây để tránh sự phức tạp không cần thiết.</p>
<p>Thống kê <span class="math inline">\(F\)</span> cho mô hình hồi quy tuyến tính đa biến thu được bằng cách hồi quy doanh thu bán hàng theo chi phí quảng cáo qua truyền hình, mạng xã hội, và tờ rơi được trình bày là 18.7457433. Vì giá trị này lớn hơn 1 rất nhiều nên đây có cơ sở để bác bỏ giả thuyết H0. Nói cách khác, giá trị thống kê <span class="math inline">\(F\)</span> lớn cho thấy rằng ít nhất một trong các phương tiện quảng cáo phải liên quan đến doanh thu bán hàng. Tuy nhiên, thống kê <span class="math inline">\(F\)</span> cần phải lớn đến mức nào để chúng ta có thể bác bỏ <span class="math inline">\(H_0\)</span> và kết luận rằng có mối quan hệ và điều gì sẽ xảy ra nếu thống kê <span class="math inline">\(F\)</span> gần với 1 hơn? Để trả lời câu hỏi này còn phụ thuộc vào giá trị của <span class="math inline">\(n\)</span> và <span class="math inline">\(p\)</span>. Khi <span class="math inline">\(n\)</span> lớn, ngay cả khi thống kê <span class="math inline">\(F\)</span> chỉ lớn hơn 1 một chút chúng ta vẫn có thể có cơ sở để bác bỏ <span class="math inline">\(H_0\)</span>. Ngược lại, thống kê <span class="math inline">\(F\)</span> cần lớn hơn để có cơ sở bác bỏ <span class="math inline">\(H_0\)</span> nếu <span class="math inline">\(n\)</span> nhỏ.</p>
<p>Bạn đọc có thể quan sát hàm mật độ của biến ngẫu nhiên phân phối <span class="math inline">\(\mathcal{F}\)</span> với các tham số <span class="math inline">\((3,51)\)</span> trong Hình <a href="#fig:fglm03">1.3</a>. Khả năng một biến ngẫu nhiên có phân phối <span class="math inline">\(\mathcal{F}\)</span> lớn hơn giá trị thống kê <span class="math inline">\(F\)</span> tính toán từ dữ liệu là khoảng <span class="math inline">\(2.5 \times 10^{-8}\)</span>. Nói cách khác, với <span class="math inline">\(p-value\)</span> rất nhỏ, chúng ta có cơ sở để bác bỏ giả thuyết <span class="math inline">\(H_0\)</span>. Điều này đồng nghĩa với việc có ít nhất một ngân sách chi cho quảng cáo có tác động đến doanh thu bán hàng.</p>
<div class="figure"><span style="display:block;" id="fig:fglm03"></span>
<img src="bookdown-demo_files/figure-html/fglm03-1.png" alt="Hàm mật độ của phân phối F(3,51) cho dữ liệu quảng cáo. Giá trị thống kê F (F - value) đủ lớn để bác bỏ giả thuyết $H_0$" width="672" />
<p class="caption">
Figure 1.3: Hàm mật độ của phân phối F(3,51) cho dữ liệu quảng cáo. Giá trị thống kê F (F - value) đủ lớn để bác bỏ giả thuyết <span class="math inline">\(H_0\)</span>
</p>
</div>
<p>Để trả lời cho câu hỏi thứ hai, chúng ta cần thực hiện các kiểm định liệu một nhóm biến giải thích có tác động lên biến mục tiêu hay không. Giả sử các biến giải thích có số thứ tự lần lượt là <span class="math inline">\(1 \leq i_1 &lt; i_2 &lt; \cdots &lt; i_h \leq p\)</span>. Khi đó, giả thuyết <span class="math inline">\(H_0\)</span> - <span class="math inline">\(H_1\)</span> để thực hiện kiểm định giả thuyết được viết như sau
<span class="math display" id="eq:lm105">\[\begin{align}
&amp; H_0: \beta_{i_j} = 0 \ \ \forall j = 1,2, \cdots, h \\
&amp; H_1: \text{Tồn tại ít nhất $j$ sao cho} \ \beta_{i_j} &gt; 0
\tag{1.15}
\end{align}\]</span></p>
<p>Tương tự như trong trường hợp kiểm định giả thuyết trong phương trình <a href="#eq:lm103">(1.13)</a>, chúng ta có thể sử dụng phân phối <span class="math inline">\(\mathcal{F}\)</span> để thực hiện kiểm định giả thuyết. Thống kê <span class="math inline">\(F\)</span> được tính toán như sau
<span class="math display" id="eq:lm08" id="eq:lm106">\[\begin{align}
F = \cfrac{(RSS_1 - RSS)/h}{RSS/(n-p-1)}
\tag{1.16}
\end{align}\]</span>
trong đó <span class="math inline">\(RSS_1\)</span> là tổng bình phương sai số của mô hình hồi quy tuyến tính không bao gồm các biến độc lập có hệ số tuyến tính được liệt kê trong phương trình <a href="#eq:lm105">(1.15)</a>.
Nếu giả thuyết <span class="math inline">\(H_0\)</span> trong <a href="#eq:lm105">(1.15)</a> là đúng, thì có thể chứng minh được rằng (tham khảo phần <a href="#leastsquared">1.2</a>) thống kê <span class="math inline">\(F\)</span> sẽ có phân phối <span class="math inline">\(\mathcal{F}(h,n-p-1)\)</span>. Giá trị của thống kê <span class="math inline">\(F\)</span> lớn cho thấy rằng ít nhất một trong các biến độc lập có hệ số tuyến tính được liệt kê trong phương trình <a href="#eq:lm105">(1.15)</a> có tác động tuyến tính lên biến phụ thuộc. Trong trường hợp đặc biệt khi <span class="math inline">\(h=1\)</span>, nghĩa là khi chúng ta cần kiểm định từng biến có ý nghĩa ở trong mô hình hồi quy tuyến tính, giá trị thống kê <span class="math inline">\(F\)</span> trong phương trình <a href="#eq:lm106">(1.16)</a> chính là bình phương của thống kê <span class="math inline">\(t\)</span> khi kiểm định từng biến độc lập riêng lẻ. Giá trị của thống kê <span class="math inline">\(t\)</span> và giá trị <span class="math inline">\(p-value\)</span> tương ứng khi kiểm định từng chi phí quảng cáo có tác động đến doanh thu bán hàng hay không được cho trong Bảng <a href="#tab:tblm04">1.7</a>. Các giá trị <span class="math inline">\(p-value\)</span> này chỉ ra rằng truyền hình và mạng xã hội có liên quan đến doanh thu bán hàng, nhưng không có bằng chứng nào cho thấy quảng cáo qua hình thức tờ rơi có liên quan đến doanh thu bán hàng khi tính đến cả quảng cáo trên truyền hình và quảng cáo qua mạng xã hội.</p>
<p>Khi đã có các <span class="math inline">\(p-value\)</span> riêng lẻ cho từng biến, tại sao chúng ta cần xem xét thống kê <span class="math inline">\(F\)</span> trong kiểm định đồng thời? Liệu có phải rằng <span class="math inline">\(p-value\)</span> của một biến riêng lẻ là nhỏ thì ít nhất một trong các yếu tố dự đoán có liên quan đến phản hồi? Điều này không phải lúc nào cũng đúng, đặc biệt khi số lượng biến giải thích <span class="math inline">\(p\)</span> khá lớn. Chẳng hạn như khi số lượng biến giải thích <span class="math inline">\(p = 20\)</span> và chúng ta kiểm định giả thuyết <span class="math inline">\(H_0: \beta_1 = \beta_2 = \cdots = \beta_{20} = 0\)</span>. Ngay cả khi <span class="math inline">\(H_0\)</span> là thực sự đúng, thì với mức ý nghĩa 5%, vẫn sẽ có trung bình <span class="math inline">\(5\% \times 20 = 1\)</span> (biến) không lớn hơn 0.05! Điều này cũng giống như khi chúng ta tạo ra 20 biến ngẫu nhiên phân phối <span class="math inline">\(student\)</span> thì sẽ có trung bình một biến rơi vào miền giá trị có xác suất 0.05. Do đó, nếu chúng ta sử dụng thống kê <span class="math inline">\(t\)</span> riêng lẻ và các <span class="math inline">\(p-value\)</span> liên quan để quyết định xem có bất kỳ mối liên hệ nào giữa các biến giải thích và biến mục tiêu hay không, thì có khả năng cao là chúng ta sẽ kết luận sai rằng có một mối quan hệ. Sử dụng thống kê <span class="math inline">\(F\)</span> không gặp phải vấn đề này vì thống kê <span class="math inline">\(F\)</span> có tính toán đến số lượng biến giải thích đưa vào trong kiểm định. Nếu giả thuyết <span class="math inline">\(H_0\)</span> thực sự đúng thì chỉ có 5% khả năng thống kê <span class="math inline">\(F\)</span> có <span class="math inline">\(p-value\)</span> nhỏ hơn 0.05, bất kể số lượng biến giải thích là bao nhiêu.</p>
<p>Bước đầu tiên trong xây dựng một mô hình tuyến tính thường là ước lượng mô hình và tính toán giá trị thống kê <span class="math inline">\(F\)</span>. Nếu chúng ta kết luận dựa trên p-value của thống kê <span class="math inline">\(F\)</span> rằng ít nhất một trong các biến giải thích có liên quan đến biến mục tiêu, thì câu hỏi tiếp theo cần trả lời sẽ là các biến nào sẽ thực sự có ý nghĩa trong mô hình. Chúng ta có thể xem xét các <span class="math inline">\(p-value\)</span> riêng lẻ cho từng biến như trong bảng <a href="#tab:tblm04">1.7</a>, nhưng như đã thảo luận, nếu <span class="math inline">\(p\)</span> khá lớn thì chúng ta có thể thực hiện một số nhận định sai. Quá trình xác định những biến giải thích có liên quan đến biến mục tiêu để tìm ra một mô hình duy nhất chỉ bao gồm các biến có liên quan được gọi là quá trình lựa chọn biến. Vấn đề lựa chọn biến được thảo luận kỹ hơn trong phần <a href="#linearmodelselection">1.3</a>.</p>
</div>
<div id="kiểm-tra-sự-phù-hợp-của-mô-hình" class="section level4 hasAnchor" number="1.1.2.3">
<h4><span class="header-section-number">1.1.2.3</span> Kiểm tra sự phù hợp của mô hình<a href="#kiểm-tra-sự-phù-hợp-của-mô-hình" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Như đã đề cập trong mô hình tuyến tính đơn, hai thước đo định lượng phổ biến nhất về mức độ phù hợp của mô hình hồi quy tuyến tính là sai số của phần dư <span class="math inline">\(RSE\)</span> và hệ số <span class="math inline">\(R^2\)</span>. Hãy nhớ lại rằng trong hồi quy đơn, <span class="math inline">\(R^2\)</span> là bình phương hệ số tương quan giữa biến mục tiêu và biến giải thích. Trong hồi quy tuyến tính đa biến, có thể chứng minh được rằng hệ số <span class="math inline">\(R^2\)</span> chính là bình phương hệ số tương quan giữa <span class="math inline">\(Y\)</span> và <span class="math inline">\(\hat{Y}\)</span>. Giá trị <span class="math inline">\(R^2\)</span> gần bằng 1 cho thấy mô hình giải thích được phần lớn phương sai của biến mục tiêu. Hệ số <span class="math inline">\(R^2\)</span> trong hồi quy đa biến được tính toán dựa trên phương trình \tag{1.9} tương tự như hồi quy đơn. Hệ số <span class="math inline">\(R^2\)</span> được tính toán bằng hàm <code>lm()</code> như sau</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="co"># Hệ số R-squared trong mô hình hồi quy 3 biến</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">lm</span>(Sales <span class="sc">~</span> TV <span class="sc">+</span> Social_Media <span class="sc">+</span> Flyer,<span class="at">data =</span> Advertising))<span class="sc">$</span>r.squared</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co"># Hệ số R-squared trong mô hình hồi quy 2 biến: TV, Social_Media</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">lm</span>(Sales <span class="sc">~</span> TV <span class="sc">+</span> Social_Media,<span class="at">data =</span> Advertising))<span class="sc">$</span>r.squared</span></code></pre></div>
<p>Đối với Dữ liệu quảng cáo, mô hình sử dụng cả ba phương tiện quảng cáo để dự đoán doanh thu bán hàng có hệ số <span class="math inline">\(R^2\)</span> là 0.5244189. Mặt khác, mô hình chỉ sử dụng TV và <span class="math inline">\(Social\_Media\)</span> để dự đoán doanh thu bán hàng có giá trị <span class="math inline">\(R^2\)</span> là 0.5158851. Nói cách khác, có một sự gia tăng nhỏ trong <span class="math inline">\(R^2\)</span> nếu chúng ta đưa quảng cáo bằng tờ rơi vào mô hình đã có sẵn quảng cáo trên truyền hình và mạng xã hội, mặc dù trước đó chúng ta đã thấy rằng giá trị <span class="math inline">\(p-value\)</span> cho quảng cáo trên tờ rơi trong Bảng <a href="#tab:tblm04">1.7</a> là không đáng kể. Thực ra thì hệ số <span class="math inline">\(R^2\)</span> sẽ luôn tăng khi có nhiều biến hơn được thêm vào mô hình, ngay cả khi những biến đó không có liên quan hoặc liên quan yếu đến biến mục tiêu. Bạn đọc cần lưu ý vấn đề này khi lựa chọn mô hình. Hệ số <span class="math inline">\(R^2\)</span> mà chúng ta thảo luận ở đây chỉ là hệ số <span class="math inline">\(R^2\)</span> tính trên dữ liệu huấn luyện mô hình chứ không phải là trên dữ liệu kiểm tra mô hình. Theo kinh nghiệm thực tế thì khi thêm các biến như quảng cáo tờ rơi vào mô hình chỉ làm cho <span class="math inline">\(R^2\)</span> tăng thêm một chút là bằng chứng cho thấy biến <span class="math inline">\(Flyer\)</span> nên bị loại khỏi mô hình. Ngược lại, khi chúng ta sử dụng mô hình chỉ chứa biến <span class="math inline">\(TV\)</span> là biến giải thích có hệ số <span class="math inline">\(R^2\)</span> là 0.2368573. Việc thêm biến <span class="math inline">\(Social\_Media\)</span> vào mô hình sẽ dẫn đến sự cải thiện đáng kể về <span class="math inline">\(R^2\)</span>. Điều này ngụ ý rằng mô hình sử dụng hai biến chi phí quảng cáo qua truyền hình và qua mạng xã hội để dự đoán doanh thu bán hàng sẽ tốt hơn đáng kể so với mô hình chỉ sử dụng quảng cáo trên truyền hình.</p>
<p><span class="math inline">\(RSE\)</span> cũng có thể là một thước đo định lượng để đánh giá sự phù hợp của mô hình. Bạn đọc có thể quan sát <span class="math inline">\(RSE\)</span> của các mô hình với tổ hợp các biến giải thích khác nhau trong bảng <a href="#tab:tblm06">1.10</a></p>
<table>
<caption><span id="tab:tblm06">Table 1.10: </span>Sai số phần dư của các mô hình tuyến tính trên dữ liệu Quảng cáo</caption>
<thead>
<tr class="header">
<th align="left">Tổ hợp biến</th>
<th align="right">RSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">TV</td>
<td align="right">0.2349</td>
</tr>
<tr class="even">
<td align="left">Social_Media</td>
<td align="right">0.2135</td>
</tr>
<tr class="odd">
<td align="left">Flyer</td>
<td align="right">0.2246</td>
</tr>
<tr class="even">
<td align="left">TV + Social_Media</td>
<td align="right">0.1889</td>
</tr>
<tr class="odd">
<td align="left">TV + Flyer</td>
<td align="right">0.2184</td>
</tr>
<tr class="even">
<td align="left">Social_Media + Flyer</td>
<td align="right">0.2016</td>
</tr>
<tr class="odd">
<td align="left">TV + Social_Media + Flyer</td>
<td align="right">0.1891</td>
</tr>
</tbody>
</table>
<p>Trong các mô hình đơn biến, có thể thấy rằng mô hình sử dụng biến <span class="math inline">\(Flyer\)</span> làm biến giải thích có <span class="math inline">\(RSE\)</span> thậm chí còn nhỏ hơn so với mô hình chỉ sử dụng biến <span class="math inline">\(TV\)</span>. Khi sử dụng hai biến để giải thích biến doanh thu, bạn đọc có thể nhận thấy rằng mô hình sử dụng <span class="math inline">\(TV\)</span> và <span class="math inline">\(Social\_Media\)</span> có <span class="math inline">\(RSE\)</span> nhỏ hơn hẳn so với các mô hình còn lại. Khi thêm biến <span class="math inline">\(Flyer\)</span> vào mô hình đã bao gồm <span class="math inline">\(TV\)</span> và <span class="math inline">\(Social\_Media\)</span>, <span class="math inline">\(RSE\)</span> gần như không thay đổi. Không giống như hệ số <span class="math inline">\(R^2\)</span> luôn tăng khi thêm biến vào mô hình, các mô hình có nhiều biến hơn có thể có <span class="math inline">\(RSE\)</span> cao hơn nếu mức giảm <span class="math inline">\(RSS\)</span> nhỏ hơn so với sự gia tăng số lượng biến.</p>
<p>Sau khi chúng ta đã tìm ra mô hình phù, có thể sử dụng các hệ số tuyến tính để đưa ra dự đoán cho biến mục tiêu <span class="math inline">\(Y\)</span> trên giá trị các biến giải thích <span class="math inline">\(X_1, X_2, \cdots , X_p\)</span>. Tuy nhiên, trước khi đưa ra dự đoán cho biến mục tiêu dựa trên mô hình tuyến tính, có những vấn đề mà bạn đọc cần lưu ý:</p>
<ul>
<li><p>Thứ nhất: kể cả khi mối quan hệ giữa biến mục tiêu với các biến giải thích là mối quan hệ tuyến tính, thì chúng ta cũng không biết được giá trị thực của các hệ số tuyến tính. Các hệ số <span class="math inline">\(\hat{\beta}_0, \hat{\beta}_1, \cdots, \hat{\beta}_p\)</span> chỉ là các ước lượng cho các hệ số tuyến tính thực <span class="math inline">\(\beta_0, \beta_1, \cdots, \beta_p\)</span> dựa trên dữ liệu quan sát được. Sai số giữa ước lượng và các giá trị thực có thể giảm bớt được dựa trên độ lớn của dữ liệu và kỹ năng của người xây dựng mô hình.</p></li>
<li><p>Lưu ý thứ hai đó là sai số về mặt mô hình, nghĩa là mối quan hệ giữa các biến giải thích và các biến mục tiêu không phải là mối liên hệ tuyến tính nhưng chúng ta sử dụng mô hình tuyến tính để đưa ra dự đoán. Sai số này có thể được giảm bớt tùy theo kỹ năng của người xây dựng mô hình, chẳng hạn như sử dụng các phép biến đổi dữ liệu, hoặc thay đổi kiểu mô hình. Các mô hình phi tuyến sẽ được trình bày trong các phần sau của cuốn sách.</p></li>
<li><p>Lưu ý thứ ba đó là ngay cả khi chúng ta biết được mối quan hệ thực giữa biến mục tiêu và các biến giải thích, vẫn có những sai số mà hoàn toàn không thể được giải thích dựa trên dữ liệu. Các sai số này là không thể giảm bớt được.</p></li>
</ul>
<p>Với các ước lượng cho hệ số tuyến tính và sai số của phần dư, chúng ta có thể xây dựng được khoảng tin cậy với mức xác suất <span class="math inline">\(\alpha\)</span> cho giá trị trung bình của biến mục tiêu
<span class="math display" id="eq:lm107">\[\begin{align}
\left(\hat{\beta}_0 + \hat{\beta}_1 \cdot x_1 + \cdots + \hat{\beta}_p \cdot x_p - z_{1 - \alpha/2} \hat{\sigma} ; \hat{\beta}_0 + \hat{\beta}_1 \cdot x_1 + \cdots + \hat{\beta}_p \cdot x_p + z_{1 - \alpha/2} \hat{\sigma}\right)
\tag{1.17}
\end{align}\]</span></p>
<p>Đối với dữ liệu Quảng cáo, giả sử mô hình được lựa chọn là mô hình với hai biến giải thích là <span class="math inline">\(TV\)</span> và <span class="math inline">\(Social\_Media\)</span>. Với ngân sách cho quảng cáo trên trền hình là 150 triệu đồng và ngân sách cho quảng cáo trên mạng xã hội 30 triệu, chúng ta có khoảng tin cậy 95% cho doanh thu bán sản phẩm là <span class="math inline">\(\left(8.64 ; 9.38 \right)\)</span> tỷ đồng. Khoảng tin cậy này được tính bởi các tham số được ước lượng từ dữ liệu quan sát như sau:
<span class="math display" id="eq:lm108">\[\begin{align}
\left(4.06 + 0.019 \times 150 + 0.07 \times 30 - 1.96 \times 0.189 ;4.06 + 0.019 \times 150 + 0.07 \times 30 + 1.96 \times 0.189 \right)
\tag{1.18}
\end{align}\]</span></p>
</div>
</div>
<div id="những-cân-nhắc-khi-xây-dựng-mô-hình-hồi-quy-tuyến-tính" class="section level3 hasAnchor" number="1.1.3">
<h3><span class="header-section-number">1.1.3</span> Những cân nhắc khi xây dựng mô hình hồi quy tuyến tính<a href="#những-cân-nhắc-khi-xây-dựng-mô-hình-hồi-quy-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Trong phần này chúng ta sẽ thảo luận thêm về các vấn đề thường gặp phải khi xây dựng mô hình tuyến tính trên dữ liệu thực tế bao gồm có vấn đề biến giải thích có kiểu định tính và vấn đề về tồn tại mối liên hệ phi tuyến tính giữa biến mục tiêu và biến giải thích</p>
<div id="biến-giải-thích-là-biến-định-tính" class="section level4 hasAnchor" number="1.1.3.1">
<h4><span class="header-section-number">1.1.3.1</span> Biến giải thích là biến định tính<a href="#biến-giải-thích-là-biến-định-tính" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Khi ước lượng hệ số tuyến tính bằng phương pháp bình phương nhỏ nhất, chúng ta luôn giả định rằng tất cả các biến trong mô hình đều là biến định lượng. Trong thực tế chúng ta lại rất hay thường gặp các biến giải thích là kiểu biến định tính. Ví dụ: bộ dữ liệu có tên <span class="math inline">\(exposure.csv\)</span> là dữ liệu về số lần yêu cầu bồi thường viện phí và tổng số tiền bồi thường của khác hàng mua bảo hiểm sức khỏe tại một công ty bảo hiểm. Chúng tôi để mô hình ở dạng đơn giản nhất khi chỉ có hai biến phụ thuộc là giới tính (<span class="math inline">\(Gender\)</span>) và tuổi (<span class="math inline">\(Age\)</span>) của người được thanh toán bảo hiểm sức khỏe. Biến mục tiêu trong mô hình sẽ là số tiền bồi thường trung bình của những khách hàng (<span class="math inline">\(Ave\_Claim\)</span>) và được tính bằng tổng số tiền của tất cả các lần bồi thường chia cho tổng số lần khách hàng gửi yêu cầu.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># Load dữ liệu exposure</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>dat<span class="ot">&lt;-</span><span class="fu">read.csv</span>(<span class="st">&quot;C:/Users/AD/Desktop/Tex file/Thu latex/Book demo/bookdown_demo_hieu/exposure.csv&quot;</span>)</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="co"># Chỉ giữ lại những khác hàng có yêu cầu bồi thường</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>dat<span class="ot">&lt;-</span><span class="fu">filter</span>(dat,Claim_Count<span class="sc">&gt;</span><span class="dv">0</span>)</span></code></pre></div>
Giả sử chúng ta muốn xây dựng mô hình tuyến tính mà biến mục tiêu là số tiền bồi thường trung bình của khách hàng và các biến giải thích là độ tuổi và giới tính của khách hàng. Biến <span class="math inline">\(Age\)</span> có thể coi là biến định lượng và có thể nhận giá trị là mọi số tự nhiên từ 18 tuổi đến 65 tuổi. Biến giới tính (<span class="math inline">\(Gender\)</span>) không thể được sử dụng như một biến định lượng bởi vì chúng ta không thể đưa ra các so sánh định lượng giữa hai giá trị mà biến giới tính nhận được.
<div class="figure"><span style="display:block;" id="fig:fglm04"></span>
<img src="bookdown-demo_files/figure-html/fglm04-1.png" alt="Hình bên trái: Mối liên hệ giữa số tiền bồi thường trung bình với độ tuổi của người được bảo hiểm; Hình bên phải: Mối liên hệ giữa số tiền bồi thường trung bình với giới tính của người được bảo hiểm" width="672" />
<p class="caption">
Figure 1.4: Hình bên trái: Mối liên hệ giữa số tiền bồi thường trung bình với độ tuổi của người được bảo hiểm; Hình bên phải: Mối liên hệ giữa số tiền bồi thường trung bình với giới tính của người được bảo hiểm
</p>
</div>
<p>Hình <a href="#fig:fglm04">1.4</a> mô tả mối liên hệ giữa số tiền yêu cầu bồi thường trung bình với độ tuổi và giới tính của người được bảo hiểm. Bạn đọc có thể thấy rằng có mối liên hệ giữa các biến giải thích đến các biến mục tiêu, số tiền yêu cầu bồi thường trung bình có xu hướng tăng khi tuổi của người được bảo hiểm tăng, và số tiền yêu cầu bồi thường trung bình của nữ cao hơn so với nam giới. Như vậy tuổi và giới tính có nhiều khả năng là các biến có liên hệ đến biến mục tiêu. Ước lượng hệ số tuyến tính của biến <span class="math inline">\(Age\)</span> có thể được thực hiện giống như các biến định lượng thông thường. Để sử dụng biến giới tính như một biến giải thích, chúng ta tạo một biến mới có dạng như sau
<span class="math display" id="eq:lm109">\[\begin{align}
Gender_i = \begin{cases}
1 \text{ nếu giới tính là nam} \\
0 \text{ nếu giới tính là nữ}
\end{cases}
\tag{1.19}
\end{align}\]</span></p>
<p>Mô hình tuyến tính với biến mục tiêu là số tiền yêu cầu bồi thường trung bình (<span class="math inline">\(Y_i\)</span>) và hai biến giải thích là độ tuổi và giới tính được viết như sau
<span class="math display" id="eq:lm108">\[\begin{align}
Y_i = &amp; \beta_0 + \beta_1 \cdot Gender_i + \beta_2 \cdot Age_i + \epsilon_i \\
= &amp;
\begin{cases}
(\beta_0 + \beta_1) + \beta_2 \cdot Age_i + \epsilon_i  \ \ \text{ nếu giới tính là nam} \\
\beta_0 + \beta_2 \cdot Age_i + \epsilon_i \ \ \text{ nếu giới tính là nữ}
\end{cases}
\tag{1.18}
\end{align}\]</span></p>
<p>Hệ số <span class="math inline">\(\beta_0\)</span> trong phương trình <a href="#eq:lm107">(1.17)</a> là hệ số chặn trong mô hình hồi quy tuyến tính đơn mà số tiền yêu cầu bồi thường trung bình phụ thuộc vào độ tuổi nếu người được bảo hiểm là nữ giới, trong khi <span class="math inline">\((\beta_0 + \beta_1)\)</span> là hệ số chặn trong mô hình hồi quy tuyến tính đơn mà số tiền yêu cầu bồi thường trung bình phụ thuộc vào độ tuổi nếu người được bảo hiểm là nam giới. Để ước lượng mô hình hồi quy tuyến tính với biến định tính <span class="math inline">\(Gender\)</span> bằng hàm <code>lm()</code>, bạn đọc hãy đảm bảo biến định tính có kiểu factor trước khi đưa vào trong hàm ước lượng.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># Đổi dữ liệu cột Gender thành factor</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>dat<span class="sc">$</span>Gender<span class="ot">&lt;-</span><span class="fu">as.factor</span>(dat<span class="sc">$</span>Gender)</span></code></pre></div>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm07">Table 1.11: </span><span id="tab:tblm07">Table 1.12: </span>Các hệ số ước lượng trong mô hình hồi quy tuyến tính với biến định tính Gender nhận một trong hai giá trị là Male hoặc Female
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
-8.1140
</td>
<td style="text-align:right;">
0.5767
</td>
<td style="text-align:right;">
-14.068578
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
Age
</td>
<td style="text-align:right;">
0.3910
</td>
<td style="text-align:right;">
0.0135
</td>
<td style="text-align:right;">
28.957960
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
GenderMale
</td>
<td style="text-align:right;">
-2.8778
</td>
<td style="text-align:right;">
0.3693
</td>
<td style="text-align:right;">
-7.792182
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<p>Hệ số ước lượng của mô hình tuyến tính với biến phụ thuộc định tính được trình bày trong bảng <a href="#tab:tblm07">1.11</a>. Bạn đọc thấy rằng các hệ số ước lượng được đều có ý nghĩa thống kê vì giá trị <span class="math inline">\(p-value\)</span> đều rất nhỏ. Hệ số tuyến tính của biến độ tuổi bằng 0.39 cho thấy rằng nếu tuổi của người được bảo hiểm tăng thêm 1 tuổi, thì số tiền bồi thường trung bình sẽ tăng khoảng 0.39 triệu đồng. Hệ số tuyến tính của biến <span class="math inline">\(GenderMale\)</span> là số âm cho biết cùng một độ tuổi, trung bình mỗi lần yêu cầu bồi thường nam giới sẽ có số tiền yêu cầu ít hơn nữ giới khoảng 2.88 triệu đồng. Việc lựa chọn mã hóa giới tính trong phương trình <a href="#eq:lm109">(1.19)</a> là hoàn toàn tự do và không ảnh hưởng đến kết quả của mô hình hồi quy. Nếu bạn đọc sử dụng cách mã hóa nữ giới là 1 và nam giới là 0, kết quả thu được sẽ có hệ số của biến <span class="math inline">\(GenderFemale\)</span> là số dương, có giá trị bằng với giá trị tuyệt đối của hệ số của biến <span class="math inline">\(GenderMale\)</span> trong bảng <a href="#tab:tblm07">1.11</a>.</p>
<p>Bạn đọc có thể đặt ra câu hỏi về việc biến định tính nhận nhiều hơn hai giá trị. Cách ước lượng của mô hình tuyến tính là hoàn toàn tương tự như trường hợp hai biến. Giả sử mô hình hồi quy tuyến tính có biến <span class="math inline">\(Y\)</span> là biến mục tiêu và hai biến giải thích: <span class="math inline">\(X_1\)</span> là biến định lượng và <span class="math inline">\(X_2\)</span> là biến định tính. <span class="math inline">\(X_2\)</span> có thể nhận <span class="math inline">\(J\)</span> giá trị khác nhau lần lượt là <span class="math inline">\(1, 2, cdots, J\)</span>. Khi đó, ước lượng mô hình tuyến tính có <span class="math inline">\(J + 1\)</span> hệ số tuyến tính cần được ước lượng như sau
<span class="math display" id="eq:lm110">\[\begin{align}
Y = \begin{cases}
\beta_0 + \beta_1 \cdot X_1 + \epsilon \ \ \text{ nếu } X_2 = 1 \\
(\beta_0 + \beta_2) + \beta_1 \cdot X_1 + \epsilon \ \ \text{ nếu } X_2 = 2 \\
(\beta_0 + \beta_3) + \beta_1 \cdot X_1 + \epsilon \ \ \text{ nếu } X_2 = 3 \\
\cdots \\
(\beta_0 + \beta_J) + \beta_1 \cdot X_1 + \epsilon \ \ \text{ nếu } X_2 = J
\end{cases}
\tag{1.20}
\end{align}\]</span>
Có thể thấy rằng, nếu biến định tính nhận quá nhiều giá trị, số lượng tham số của mô hình tuyến tính tăng lên tương ứng. Khi mô hình sử dụng quá nhiều hệ số sẽ dễ dẫn đến hiện tượng overfitting. Giải pháp khi gặp biến định tính nhận nhiều giá trị là nhóm các giá trị có hệ số <span class="math inline">\(\beta\)</span> không khác nhau vào cùng một nhóm để giảm số lượng biến. Chúng ta sẽ thảo luận kỹ hơn về giải pháp này trong phần thực hành trên mô hình tuyến tính.</p>
</div>
<div id="basiclmconsideration2" class="section level4 hasAnchor" number="1.1.3.2">
<h4><span class="header-section-number">1.1.3.2</span> Mối quan hệ phi tuyến giữa biến mục tiêu và biến giải thích<a href="#basiclmconsideration2" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Mối liên hệ giữa số tiền yêu cầu bồi thường trung bình và biến độ tuổi trong Hình <a href="#fig:fglm04">1.4</a> không phải là một mối liên hệ tuyến tính. Bạn đọc có thể thấy rằng khi độ tuổi tăng thì số tiền yêu cầu bồi thường tăng lên nhanh hơn, điều này giải thích tại sao đường thẳng mô tả mối liên hệ giữa hai biến có độ dốc tăng dần khi độ tuổi tăng. Điều này gợi ý cho người xây dựng mô hình rằng mối liên hệ giữa số tiền bồi thường trung bình và độ tuổi là mối liên hệ phi tuyến hơn là tuyến tính. Đa số các phương pháp xây dựng mô hình hiện đại đều được xây dựng để mô tả mối quan hệ phi tuyến giữa biến giải thích và biến mục tiêu. Trong khuôn khổ mô hình hồi quy tuyến tính, chúng tôi giới thiệu một phương pháp tiếp cận đơn giản nhất, đó là hồi quy theo đa thức. Mối liên hệ giữa biến mục tiêu và biến giải thích trong Hình <a href="#fig:fglm04">1.4</a> có dạng parabol, do đó chúng ta có thể thêm vào mô hình biến giải thích là bình phương của độ tuổi với hi vọng là sẽ có một mô hình giải thích tốt hơn biến mục tiêu. Mô hình có dạng như sau
<span class="math display" id="eq:lm111">\[\begin{align}
Y = \begin{cases}
(\beta_0 + \beta_1) + \beta_2 \cdot Age + \beta_3 \cdot Age^2 + \epsilon  \ \ \text{ nếu giới tính là nam} \\
\beta_0 + \beta_2 \cdot Age_i + \beta_3 \cdot Age^2 + \epsilon \ \ \text{ nếu giới tính là nữ}
\end{cases}
\tag{1.21}
\end{align}\]</span></p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm08">Table 1.13: </span><span id="tab:tblm08">Table 1.14: </span>Các hệ số ước lượng trong mô hình hồi quy quy đa thức với bình phương của biến Age là biến giải thích
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
9.9182
</td>
<td style="text-align:right;">
1.5918
</td>
<td style="text-align:right;">
6.230760
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
Age
</td>
<td style="text-align:right;">
-0.6224
</td>
<td style="text-align:right;">
0.0848
</td>
<td style="text-align:right;">
-7.340056
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
Age^2
</td>
<td style="text-align:right;">
0.0125
</td>
<td style="text-align:right;">
0.0010
</td>
<td style="text-align:right;">
12.094988
</td>
<td style="text-align:right;">
0
</td>
</tr>
<tr>
<td style="text-align:left;">
GenderMale
</td>
<td style="text-align:right;">
-2.7683
</td>
<td style="text-align:right;">
0.3573
</td>
<td style="text-align:right;">
-7.747662
</td>
<td style="text-align:right;">
0
</td>
</tr>
</tbody>
</table>
<p>Kết quả ước lượng trong Bảng <a href="#tab:tblm08">1.13</a> cho thấy tất cả các hệ số tuyến tính đều có ý nghĩa, điều này cho thấy mối liên hệ giữa số tiền bồi thường trung bình và độ tuổi là mối liên hệ phi tuyến hơn là tuyến tính. Mô hình có biến giải thích độ tuổi bình phương có hệ số <span class="math inline">\(R^2\)</span> lớn hơn nhiều so với mô hình không có biến độ tuổi bình phương, điều này cho thấy mô hình có biến độ tuổi bình phương phù hợp hơn để giải thích biến mục tiêu. Tuy nhiên, bạn đọc cũng có thể nhận thấy rằng, mô hình đã trở nên khó giải thích hơn một chút. Chúng ta không thể đưa ra đánh giá ngay lập tức cho biến mục tiêu khi tuổi của người yêu cầu bồi thường tăng 1 hay giảm 1 tuổi. Đó là sự đánh đổi giữa khả năng giải thích và khả năng dự đoán mà bạn đọc sẽ thường xuyên gặp phải khi xây dựng mô hình. Chúng ta sẽ thảo luận về các kỹ thuật mô tả mối liên hệ phi tuyến giữa biến mục tiêu và biến giải thích trong phần xxxxxxx</p>
</div>
<div id="sự-kết-hợp-giữa-các-biến-giải-thích-không-chỉ-là-cộng-tính" class="section level4 hasAnchor" number="1.1.3.3">
<h4><span class="header-section-number">1.1.3.3</span> Sự kết hợp giữa các biến giải thích không chỉ là cộng tính<a href="#sự-kết-hợp-giữa-các-biến-giải-thích-không-chỉ-là-cộng-tính" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Trong nhiều trường hợp, biến mục tiêu không chỉ phụ thuộc vào từng biến giải thích một cách riêng lẻ, mà còn phụ thuộc vào sự tương tác giữa các biến giải thích. Một ví dụ điển hình cho trường hợp này là khi sử dụng mô hình tuyến tính để mô tả mối liên hệ giữa số lượng thành phẩm của một nhà máy sản xuất (<span class="math inline">\(products\)</span>) với số lượng công nhân (<span class="math inline">\(workers\)</span>) và số lượng máy chế tạo (<span class="math inline">\(machine\)</span>). Nhìn chung khi tăng số lượng công nhân hoặc tăng số lượng máy thì số lượng thành phẩm sẽ tăng lên. Tuy nhiên mô hình hồi quy tuyến tính chỉ bao gồm hai biến giải thích <span class="math inline">\(workers\)</span> và <span class="math inline">\(machines\)</span> sẽ không mô tả được thực tế là khi tăng số lượng công nhân lên quá nhiều sẽ dẫn đến việc công nhân không có máy để sản xuất nên số lượng thành phẩm cũng sẽ không tăng theo tương ứng. Chính vì thế, để mô tả được thực tế đó, mô hình tuyến tính cần có biến giải thích mô tả sự tương tác giữa <span class="math inline">\(workers\)</span> và <span class="math inline">\(machines\)</span>:
<span class="math display" id="eq:lm112">\[\begin{align}
products = \beta_0 + \beta_1 \cdot workers  + \beta_2 \cdot machines + \beta_3 \cdot workers \times machines + \epsilon
\tag{1.22}
\end{align}\]</span>
hoặc chúng ta cũng có thể viết mô hình <a href="#eq:lm112">(1.22)</a> dưới dạng mô hình tuyến tính mà hệ số tuyến tính của biến <span class="math inline">\(machines\)</span> phụ thuộc vào biến <span class="math inline">\(workers\)</span>
<span class="math display" id="eq:lm113">\[\begin{align}
products = &amp; \beta_0 + \beta_1 \cdot workers  + (\beta_2 + \beta_3 \cdot workers) \cdot machines + \epsilon \\
= &amp; \beta_0 + (\beta_1 + \beta_3 \cdot machines)  \cdot workers  + \beta_2 \cdot machines + \epsilon
\tag{1.23}
\end{align}\]</span></p>
<p>Có thể giải thích mô hình <a href="#eq:lm113">(1.23)</a> rằng mỗi khi tăng thêm 1 máy sản xuất, số lượng thành phẩm sẽ tăng lên tương ứng là bằng <span class="math inline">\((\beta_2 + \beta_3 \cdot workers)\)</span>, hoặc tăng thêm 1 công nhân, số lượng thành phẩm sẽ tăng lên là <span class="math inline">\((\beta_1 + \beta_3 \cdot machines)\)</span>. Hay nói một cách khác, số lượng thành phẩm tăng khi số lượng máy móc tăng nhưng tốc độ tăng còn phụ thuộc vào số lượng công nhân hiện tại; hoặc số lượng thành phẩm tăng khi tăng số lượng công nhân nhưng tốc độ tăng còn phụ thuôc vào số máy móc hiện có. Mô hình <a href="#eq:lm113">(1.23)</a> sẽ phù hợp hơn mô hình tuyến tính chỉ bao gồm hai biến giải thích <span class="math inline">\(workers\)</span> và <span class="math inline">\(machines\)</span> khi giải thích biến mục tiêu <span class="math inline">\(products\)</span>.</p>
</div>
</div>
<div id="những-khiếm-khuyết-của-mô-hình-hồi-quy-tuyến-tính" class="section level3 hasAnchor" number="1.1.4">
<h3><span class="header-section-number">1.1.4</span> Những khiếm khuyết của mô hình hồi quy tuyến tính<a href="#những-khiếm-khuyết-của-mô-hình-hồi-quy-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Khi chúng ta ước lượng mô hình hồi quy tuyến tính cho dữ liệu cụ thể những vấn đề dưới đây có thể xảy ra làm cho kết quả ước lượng của mô hình trở nên kém hiệu quả:</p>
<ol style="list-style-type: decimal">
<li><p>Tồn tại mối liên hệ phi tuyến giữa biến mục tiêu và biến giải thích;</p></li>
<li><p>Các sai số <span class="math inline">\(\epsilon_i\)</span> có tương quan với nhau.</p></li>
<li><p>Phương sai của các <span class="math inline">\(\epsilon_i\)</span> không phải là hằng số.</p></li>
<li><p>Trong dữ liệu có điểm ngoại lai.</p></li>
<li><p>Các biến giải thích có tương quan cao với nhau, hay còn gọi là đa cộng tuyến.</p></li>
</ol>
<p>Trong thực tế, việc xác định và khắc phục những vấn đề này là những chủ đề khoa học được nghiên cứu xuyên suốt cho đến thời điểm hiện tại. Có nhiều cuốn sách có chủ đề tập trung vào mô hình hồi quy tuyến tính có thể giải quyết một hoặc một vài vấn đề được nêu ở trên. Vì mô hình hồi quy tuyến tính không phải là trọng tâm của cuốn sách này nên chúng tôi sẽ chỉ tóm tắt ngắn gọn về các vấn đề và một số hướng giải quyết ngắn gọn.</p>
<div id="dữ-liệu-quan-sát-được-có-dạng-phi-tuyến-tính" class="section level4 hasAnchor" number="1.1.4.1">
<h4><span class="header-section-number">1.1.4.1</span> Dữ liệu quan sát được có dạng phi tuyến tính<a href="#dữ-liệu-quan-sát-được-có-dạng-phi-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Như chúng tôi đã trình bày ở phần <a href="#sec:basiclmconsideration2"><strong>??</strong></a>, khi tồn tại mối liên hệ phi tuyến giữa biến mục tiêu và biến giải thích, sử dụng mô hình tuyến tính thông thường sẽ không phù hợp và làm cho kết quả dự đoán không được chính xác. Mối liên hệ phi tuyến có thể được phát hiện khi vẽ đồ thị biến mục tiêu theo biến giải thích giống như Hình <a href="#fig:fglm04">1.4</a> hoặc chúng ta vẽ đồ thị phần dư của mô hình theo biến mục tiêu</p>
<div class="figure"><span style="display:block;" id="fig:fglm05"></span>
<img src="bookdown-demo_files/figure-html/fglm05-1.png" alt="Đồ thị mô tả phần dư của mô hình tuyến tính theo biến mục tiêu trên dữ liệu về số tiền yêu cầu bồi thường bảo hiểm y tế. Hình bên trái: Phần dư của mô hình tuyến tính thông thường theo biến mục tiêu. Hình bên phải: Phần dư của mô hình hồi quy đa thức bậc hai theo biến mục tiêu" width="672" />
<p class="caption">
Figure 1.5: Đồ thị mô tả phần dư của mô hình tuyến tính theo biến mục tiêu trên dữ liệu về số tiền yêu cầu bồi thường bảo hiểm y tế. Hình bên trái: Phần dư của mô hình tuyến tính thông thường theo biến mục tiêu. Hình bên phải: Phần dư của mô hình hồi quy đa thức bậc hai theo biến mục tiêu
</p>
</div>
<p>Hình <a href="#fig:fglm05">1.5</a> mô tả mối liên hệ giữa phần dư của mô hình tuyến tính thông thường và mô hình hồi quy đa thức với biến mục tiêu là số tiền yêu cầu bồi thường trung bình. Đường mô tả mối liên hệ trong mô hình hồi quy đa thức gần với đường trung bình của phần dư hơn cho thấy mối liên hệ phi tuyến giữa biến mục tiêu và phần dư tuy đã giảm bớt so với hồi quy tuyến tính thông thường nhưng vẫn còn tồn tại trong mô hình hồi quy đa thức. Như vậy, có thể thấy rằng thêm các biến giải thích là các hàm phi tuyến của các biến giải thích ban đầu vào trong mô hình hồi quy tuyến tính là một phương pháp để mô tả mối quan hệ phi tuyến trong dữ liệu. Các biến đổi phi tuyến thường được dùng có dạng hàm mũ, hàm <span class="math inline">\(\log\)</span> của biến giải thích. Nghĩa là từ biến giải thích <span class="math inline">\(X\)</span> ban đầu, nếu đồ thị mô tả mối liên hệ giữa <span class="math inline">\(X\)</span> và <span class="math inline">\(Y\)</span> cho thấy có mối liên hệ phi tuyến, tùy theo hình dạng của đồ thị mà chúng ta có thể thêm vào mô hình các biến giải thích như <span class="math inline">\(\sqrt{X}\)</span>, <span class="math inline">\(X^2\)</span>, <span class="math inline">\(X^3\)</span>, <span class="math inline">\(\log(X)\)</span>, <span class="math inline">\(\cdots\)</span>, …, để có được mô hình phù hợp hơn. Trong phần sau của cuốn sách chúng ta sẽ thảo luận về các kỹ thuật hiện đại hơn để mô tả tốt hơn mối liên hệ phi tuyến như vậy.</p>
</div>
<div id="tồn-tại-tương-quan-giữa-các-phần-dư" class="section level4 hasAnchor" number="1.1.4.2">
<h4><span class="header-section-number">1.1.4.2</span> Tồn tại tương quan giữa các phần dư<a href="#tồn-tại-tương-quan-giữa-các-phần-dư" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Một giả thiết quan trọng của mô hình hồi quy tuyến tính là các sai số <span class="math inline">\(\epsilon_1\)</span>, <span class="math inline">\(\epsilon_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(\epsilon_n\)</span> không tương quan với nhau. Điều này có nghĩa là kể cả khi đã biết <span class="math inline">\(\epsilon_i\)</span>, chúng ta cũng không có thông tin gì về các <span class="math inline">\(\epsilon_j\)</span> khi <span class="math inline">\(j \neq i\)</span>. Giả thiết các sai số có phân phối chuẩn và không tương quan có ý nghĩa quan trọng trong xây dựng các khoảng tin cậy cho hệ số tuyến tính. Trên thực tế, nếu có mối tương quan giữa các sai số thì phương sai của các hệ số tuyến tính ước lượng bằng phương pháp bình phương nhỏ nhất sẽ nhỏ hơn nhiều cho so với phương sai thực. Kết quả là khoảng tin cậy ước lượng được sẽ nhỏ hơn các khoảng tin cậy thực sự.</p>
<p>Bạn đọc có thể hình dung việc phần dư có tương quan với nhau cũng giống như việc chúng ta trong quá trình thu thập dữ liệu có sai sót dẫn đến dữ liệu bị trùng lặp. Chẳng hạn như mỗi dòng dữ liệu bị lặp lại một lần, nghĩa là dữ liệu đúng để ước lượng mô hình chỉ có <span class="math inline">\(n\)</span> dòng nhưng chúng ta đã nhân đôi dữ liệu lên trước khi thực hiện ước lượng. Khi tính toán độ lệch chuẩn của sai số, chúng ta sử dụng <span class="math inline">\(2 n\)</span> quan sát để tính toán thay vì <span class="math inline">\(n\)</span> làm cho độ lệch chuẩn bị giảm xuống một tỷ lệ là <span class="math inline">\(\sqrt{2}\)</span>. Các khoảng tin cậy khi tính toán với dữ liệu bị trùng lặp sẽ bị thu hẹp lại so với khoảng tin cậy được tính toán với dữ liệu chính xác.</p>
<p>Khi nào thì chúng ta sẽ gặp phải hiện tượng phần dư có tương quan với nhau? Ngoài việc sai sót trong quá trình thu thập dữ liệu làm cho dữ liệu vị trùng lặp, chúng ta cũng thường gặp phải hiện tượng phần dư có tương quan khi sử dụng mô hình hồi quy tuyến tính trong dữ liệu dạng chuỗi thời gian. Trong trường hợp mà mỗi dòng dữ liệu là một quan sát thu được tại các thời điểm liền kề nhau thì rất có nhiều khả năng các biến mục tiêu sẽ có tương quan với nhau, dẫn đến tương quan giữa các phần dư trong mô hình tuyến tính.</p>
<p>Để xác định xem phần dư từ một mô hình hồi quy tuyến tính có tương quan hay không, chúng ta có thể quan sát đồ thị phần dư. Nếu phần dư không có tương quan thì sẽ không có mối liên hệ rõ ràng nào. Mặt khác, nếu có tồn tại tương quan dương thì chúng ta có thể thấy có sự liên kết giữa các giá trị phần dư.</p>
<div class="figure"><span style="display:block;" id="fig:fglm06"></span>
<img src="bookdown-demo_files/figure-html/fglm06-1.png" alt="Đồ thị mô tả phần dư có tương quan và không có tương quan. Hình trên: các phần dư có tương quan bằng 0. Hình ở giữa: hai giá trị phần dư cạnh nhau có tương quan 0.5. Hình dưới: hai giá trị phần dư cạnh nhau có tương quan 0.9" width="672" />
<p class="caption">
Figure 1.6: Đồ thị mô tả phần dư có tương quan và không có tương quan. Hình trên: các phần dư có tương quan bằng 0. Hình ở giữa: hai giá trị phần dư cạnh nhau có tương quan 0.5. Hình dưới: hai giá trị phần dư cạnh nhau có tương quan 0.9
</p>
</div>
<p>Hình <a href="#fig:film06"><strong>??</strong></a> minh họa đồ thị phần dư của ba mô hình khác nhau. Trong hình trên cùng, chúng ta thấy phần dư từ mô hình hồi quy tuyến tính tương ứng với dữ liệu mà biến mục tiêu không có tương quan với nhau. Bạn đọc có thể thấy rằng không có mối liên hệ nào rõ ràng về xu hướng của các giá trị phần dư. Ngược lại, phần dư ở hình dưới cùng là từ tập dữ liệu trong đó các sai số liền kề có hệ số tương quan là 0.9. Bạn đọc có thể nhận thấy có một sự liên kết rõ ràng trong phần dư mà trong đó các giá trị liền kề nhau có xu hướng nhận các giá trị tương tự hay cùng dấu. Cuối cùng, hình ở giữa minh họa một trường hợp ít rõ ràng hơn mà trong đó phần dư có hệ số tương quan là 0,5. Vẫn có bằng chứng về sự liên hệ nhưng không rõ ràng như trường hợp có hệ số tương quan 0.9.</p>
<p>Nhìn chung giả định về phần dư không tương quan là vô cùng quan trọng đối với mô hình hồi quy tuyến tính nói riêng cũng như đối với các mô hình học máy hiện đại. Ngoài nguyên nhân từ xây dựng mô hình hay cách lựa chọn biến, sự tương quan giữa các phần dư cũng có thể tồn tại ngay trong chính cách dữ liệu được thu thập, đặc biệt là những dữ liệu mà biến mục tiêu và biến giải thích cùng chịu sự tác động từ các yếu tố bên ngoài. Có nhiều phương pháp đã được phát triển để xác định các mối tương quan của phần dư trong mô hình hồi quy tuyến tính, đặc biệt là đối với mô hình tuyến tính có các biến mục tiêu và biến giải thích có dạng dữ liệu chuỗi thời gian. Nội dung của các phương pháp này bạn đọc có thể tham khảo trong các sách tham khảo dành riêng cho mô hình hồi quy tuyến tính.</p>
</div>
<div id="phương-sai-của-phần-dư-thay-đổi" class="section level4 hasAnchor" number="1.1.4.3">
<h4><span class="header-section-number">1.1.4.3</span> Phương sai của phần dư thay đổi<a href="#phương-sai-của-phần-dư-thay-đổi" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Một giả thiết quan trọng khác của mô hình hồi quy tuyến tính là các phần dư có phương sai không thay đổi: <span class="math inline">\(\mathbb{V}(\epsilon_i) = \sigma^2\)</span> <span class="math inline">\(\forall i = 1, 2, \cdots, n\)</span>. Ước lượng các hệ số tuyến tính, xây dựng các khoảng tin cậy cho hệ số, hay kiểm định các giả thuyết của mô hình tuyến tính đều dựa trên giả định này. Thực tế là chúng ta rất hay gặp phải trường hợp phương sai của phần dư là không cố định. Một nguyên nhân hiện tượng phần dư có phương sai thay đổi đến từ việc mối liên hệ giữa biến mục tiêu và biến giải thích là phi tuyến. Nếu xuất phát từ nguyên nhân này, chúng ta có thể biến đổi biến mục tiêu trước khi thực hiện ước lượng.</p>
<p>Một ví dụ điển hình thường gặp phải là khi phương sai của phần dư tăng theo giá trị của biến mục tiêu. Chúng ta có thể xác định được hiện tượng phương sai của phần dư thay đổi bằng cách sử dụng đồ thị của phần dư theo giá trị ước lượng được của biến mục tiêu.</p>
<div class="figure"><span style="display:block;" id="fig:fglm07"></span>
<img src="bookdown-demo_files/figure-html/fglm07-1.png" alt="Đồ thị mô tả phần dư có phương sai thay đổi. Hình ở trên: cho thấy phần dư có phương sai thay đổi. Hình ở dưới: Phần dư có phương sai ổn định" width="672" />
<p class="caption">
Figure 1.7: Đồ thị mô tả phần dư có phương sai thay đổi. Hình ở trên: cho thấy phần dư có phương sai thay đổi. Hình ở dưới: Phần dư có phương sai ổn định
</p>
</div>
<p>Một ví dụ cho phần dư có phương sai thay đổi được thể hiện trong hình <a href="#fig:fglm07">1.7</a>. Khi chúng ta sử dụng biến mục tiêu <span class="math inline">\(Y\)</span>, độ lớn của phần dư có xu hướng tăng theo các giá trị của biến mục tiêu. Khi gặp vấn đề này, một giải pháp đơn giản là biến đổi biến mục tiêu <span class="math inline">\(Y\)</span> bằng cách sử dụng các hàm <span class="math inline">\(\log\)</span> Y hoặc hàm <span class="math inline">\(\sqrt\)</span>. Các phép biến đổi này có thể làm giảm hiện tượng phương sai thay đổi. Hình phía dưới của Hình <a href="#fig:fglm07">1.7</a> mô tả phần dư theo giá trị của biến mục tiêu sau khi sử dụng phép biến đổi <span class="math inline">\(\log\)</span>. Phần dư đã trở nên ổn định hơn mặc dù có một số dấu hiệu về mối quan hệ phi tuyến trong giữa biến mục tiêu và biến giải thích.</p>
<p>Hiện tượng phương sai của sai số thay đổi có thể là kết quả của quá trình dữ liệu được thu thập, khi mà biến mục tiêu thứ <span class="math inline">\(i\)</span> là giá trị trung bình của <span class="math inline">\(n_i\)</span> quan sát độc lập. Ví dụ, dữ liệu về yêu cầu bồi thường của các khách hàng của một công ty bảo hiểm, mỗi khách hàng có thể yêu cầu bồi thường nhiều lần trong khoảng thời gian một năm nhưng dữ liệu chỉ được lưu trữ dưới dạng tổng số tiền khách hàng yêu cầu bồi thường và tổng số lần khách hàng yêu cầu bồi thường. Khi xây dựng mô hình với biến mục tiêu là số tiền yêu cầu bồi thường trung bình thì độ lệch chuẩn của biến mục tiêu sẽ tỷ lệ nghịch với số lần khách hàng yêu cầu bồi thường. Trong trường hợp như vậy, một phương pháp khắc phục đơn giản là ước lượng mô hình sử dụng phương pháp bình phương nhỏ nhất có trọng số. Trọng số được sử dụng tỷ lệ nghịch với phương sai của biến mục tiêu. Chẳng hạn như trong ví dụ về yêu cầu bồi thường, trọng số được sử dụng đối với quan sát thứ <span class="math inline">\(i\)</span> chính là số lần khách hàng yêu cầu bồi thường.</p>
</div>
<div id="dữ-liệu-có-giá-trị-ngoại-lai" class="section level4 hasAnchor" number="1.1.4.4">
<h4><span class="header-section-number">1.1.4.4</span> Dữ liệu có giá trị ngoại lai<a href="#dữ-liệu-có-giá-trị-ngoại-lai" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Điểm ngoại lai là điểm dữ liệu mà giá trị biến mục tiêu <span class="math inline">\(y_i\)</span> khác xa giá trị được dự đoán bởi mô hình <span class="math inline">\(\hat{y}_i\)</span>. Các ngoại lai có thể phát sinh vì nhiều lý do, chẳng hạn như sự không chính xác trong quá trình thu thập dữ liệu. Bạn đọc có thể tham khảo thêm về giá trị ngoại lai trong phần @ref(#ourlier)</p>
<div class="figure"><span style="display:block;" id="fig:fglm08"></span>
<img src="bookdown-demo_files/figure-html/fglm08-1.png" alt="Dữ liệu chứa giá trị ngoại lai là điểm màu đỏ. Hình bên trái: đồ thị mô tả biến mục tiêu theo biến giải thích và các đường hồi quy tuyến tính được xây dụng cho hai trường hợp là có chứa điểm ngoại lai (nét liền màu xanh) và không chứa điểm ngoại lai (nét đứt màu đen). Hình bên phải: Đồ thị phần dư được điều chỉnh theo biến giải thích, điểm ngoại lai có phần dư có giá trị tuyệt đối lớn hơn hẳn các phần dư khác" width="672" />
<p class="caption">
Figure 1.8: Dữ liệu chứa giá trị ngoại lai là điểm màu đỏ. Hình bên trái: đồ thị mô tả biến mục tiêu theo biến giải thích và các đường hồi quy tuyến tính được xây dụng cho hai trường hợp là có chứa điểm ngoại lai (nét liền màu xanh) và không chứa điểm ngoại lai (nét đứt màu đen). Hình bên phải: Đồ thị phần dư được điều chỉnh theo biến giải thích, điểm ngoại lai có phần dư có giá trị tuyệt đối lớn hơn hẳn các phần dư khác
</p>
</div>
<p>Điểm màu đỏ ở hình bên trái của Hình <a href="#fig:fglm08">1.8</a> minh họa một ngoại giá trị ngoại lai điển hình. Đường liền màu xanh dương là đường hồi quy tuyến tính sử dụng đầy đủ dữ liệu, trong khi đường nét đứt màu đen là đường hồi quy tuyến tính sau khi loại bỏ đi điểm ngoại lai. Trong trường hợp này, việc loại bỏ giá trị ngoại lai ít ảnh hưởng đến đường hồi quy tuyến tính vì bạn đọc có thể thấy hai đường hồi quy khá gần nhau. Thông thường, một giá trị ngoại lai duy nhất sẽ ít ảnh hưởng đến sự hình dạng của đường hồi quy tuyến tính, tuy nhiên, điểm ngoại lai này lại có thể gây ra các vấn đề khác. Trong ví dụ ở trên, <span class="math inline">\(RSE\)</span> là 1.8 khi giá trị ngoại lai được đưa vào hồi quy, và <span class="math inline">\(RSE\)</span> chỉ bằng 0.9 khi giá trị ngoại lai bị loại bỏ. Vì chúng ta sẽ sử dụng <span class="math inline">\(RSE\)</span> để tính toán các khoảng tin cậy và các <span class="math inline">\(p-value\)</span>, nên sự thay đổi đáng kể của <span class="math inline">\(RSE\)</span> như vậy sẽ có tác động đến việc giải thích sự phù hợp của mô hình. Tương tự, việc đưa giá trị ngoại lai vào làm cho <span class="math inline">\(R^2\)</span> giảm từ 0.973 xuống 0.89.</p>
<p>Chúng ta có thể xác định một quan sát là ngoại lai hay không bằng cách vẽ đồ thị phần dư. Trong ví dụ ở trên, giá trị ngoại lai có thể được xác định rõ ràng trong Hình <a href="#fig:fglm08">1.8</a>. Nhưng trong thực tế, có thể khó đưa ra được quyết định là phần dư cần phải lớn đến mức nào để chúng ta coi điểm đó là điểm bất thường. Để giải quyết vấn đề này, thay vì vẽ đồ thị phần dư, chúng ta có thể vẽ đồ thị phần dư sau khi chia phần dư cho <span class="math inline">\(RSE\)</span>. Nếu các giả thiết của mô hình hồi quy tuyến tính là đúng, phần dư được điều chỉnh (sau khi chia cho <span class="math inline">\(RSE\)</span>) sẽ có phân phối Student. Nếu một giá trị quan sát của phần dư vượt quá các ngưỡng xác suất của phân phối Student, nhiều khả năng đó là giá trị ngoại lai. Trong Hình <a href="#fig:fglm08">1.8</a>, tất cả các quan sát có phần dư nằm trong khoảng -2 đến 2 trong khi giá trị ngoại lai có giá trị là gần 6. Nói một cách khác khả năng điểm màu đỏ với phần dư được điểu chỉnh gần bằng 6 có khả năng rất cao là giá trị ngoại lai.</p>
</div>
<div id="đa-cộng-tuyến" class="section level4 hasAnchor" number="1.1.4.5">
<h4><span class="header-section-number">1.1.4.5</span> Đa cộng tuyến<a href="#đa-cộng-tuyến" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Đa cộng tuyến là sự kiện mà trong đó hai hoặc nhiều biến giải thích có tương quan cao với nhau với nhau. Để giải thích rõ ràng khái niệm này, chúng ta hãy lấy một ví dụ khi xây dựng mô hình hồi quy tuyến tính trên dữ liệu có tên là <span class="math inline">\(Credit\_Card\)</span> . Đây là dữ liệu về thông tin thẻ tín dụng của các khách hàng tại một ngân hàng với biến mục tiêu là số dư tài khoản (<span class="math inline">\(Balance\)</span>) và 10 biến giải thích. Để giải thích về đa cộng tuyến, chúng tôi chỉ sử dụng ba biến giải thích là 1. Độ tuổi của chủ thẻ tín dụng (<span class="math inline">\(Age\)</span>), 2. Hạn mức thẻ tín dụng (<span class="math inline">\(Limit\)</span>), và 3. Điểm tín dụng của khách hàng (<span class="math inline">\(Rating\)</span>). Hiện tượng đa cộng tuyến được minh họa trên Hình <a href="#fig:fglm09">1.9</a></p>
<div class="figure"><span style="display:block;" id="fig:fglm09"></span>
<img src="bookdown-demo_files/figure-html/fglm09-1.png" alt="Mối liên hệ giữa các biến giải thích trong dữ liệu Credit. Hình bên trái: Không cho thấy có mối tương quan giữa hạn mức tín dụng với tuổi của khách hàng. Hình ở giữa: Tương quan giữa hạn mức tín dụng và điểm tính dụng là rất cao. Hình bên phải: Không có tương quan giữa tuổi của khách hàng với xếp hạng tín dụng" width="672" />
<p class="caption">
Figure 1.9: Mối liên hệ giữa các biến giải thích trong dữ liệu Credit. Hình bên trái: Không cho thấy có mối tương quan giữa hạn mức tín dụng với tuổi của khách hàng. Hình ở giữa: Tương quan giữa hạn mức tín dụng và điểm tính dụng là rất cao. Hình bên phải: Không có tương quan giữa tuổi của khách hàng với xếp hạng tín dụng
</p>
</div>
<p>Trong hình bên trái của Hình <a href="#fig:fglm09">1.9</a>, hai biến giải thích là hạn mức tín dụng và độ tuổi không có mối tương quan rõ ràng. Tương tự, trong hình bên phải, cũng không có mối tương quan rõ ràng giữa độ tuổi với xếp hạng tín dụng. Ngược lại, trong hình ở giữa của Hình <a href="#fig:fglm09">1.9</a>, hạn mức tín dụng và điểm tín dụng có mối tương quan rất cao với nhau bởi các điểm gần như nằm trên một đường thẳng.</p>
<p>Hiện tượng đa cộng tuyến gây ra các vấn đề khi ước lượng và giải thích mô hình hồi quy bởi khó có thể tách biệt các tác động riêng lẻ của các biến có tương quan cao lên biến mục tiêu. Trong ví dụ ở trên. hạn mức tín dụng và điểm tín dụng có xu hướng tăng hoặc giảm cùng nhau nên khó có thể xác định xem từng biến riêng biệt có liên quan như thế nào đến biến mục tiêu là số dư tài khoản. Một vấn đề đáng kể khác khi gặp hiện tượng đa cộng tuyến đó là phương sai của các hệ số ước lượng sẽ rất lớn dẫn đến các ước lượng trở nên ít tin cậy hơn và chúng ta sẽ rất khó bác bỏ được giả thuyết hệ số tuyến tính bằng 0.</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm09">Table 1.15: </span><span id="tab:tblm09">Table 1.16: </span>Các hệ số ước lượng trong mô hình hồi quy tuyến tính số dư tài khoản phụ thuộc vào độ tuổi và hạn mức tín dụng
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
-173.4109
</td>
<td style="text-align:right;">
43.8284
</td>
<td style="text-align:right;">
-3.9566
</td>
<td style="text-align:right;">
1e-04
</td>
</tr>
<tr>
<td style="text-align:left;">
Age
</td>
<td style="text-align:right;">
-2.2915
</td>
<td style="text-align:right;">
0.6725
</td>
<td style="text-align:right;">
-3.4075
</td>
<td style="text-align:right;">
7e-04
</td>
</tr>
<tr>
<td style="text-align:left;">
Limit
</td>
<td style="text-align:right;">
0.1734
</td>
<td style="text-align:right;">
0.0050
</td>
<td style="text-align:right;">
34.4959
</td>
<td style="text-align:right;">
0e+00
</td>
</tr>
</tbody>
</table>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm10">Table 1.17: </span><span id="tab:tblm10">Table 1.18: </span>Các hệ số ước lượng trong mô hình hồi quy tuyến tính số dư tài khoản phụ thuộc vào hạn mức tín dụng và điểm tín dụng
</caption>
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
Ước lượng
</th>
<th style="text-align:right;">
Độ lệch chuẩn
</th>
<th style="text-align:right;">
Thống kê t
</th>
<th style="text-align:right;">
p-value
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
(Intercept)
</td>
<td style="text-align:right;">
-377.5368
</td>
<td style="text-align:right;">
45.2542
</td>
<td style="text-align:right;">
-8.3426
</td>
<td style="text-align:right;">
0.0000
</td>
</tr>
<tr>
<td style="text-align:left;">
Limit
</td>
<td style="text-align:right;">
0.0245
</td>
<td style="text-align:right;">
0.0638
</td>
<td style="text-align:right;">
0.3840
</td>
<td style="text-align:right;">
0.7012
</td>
</tr>
<tr>
<td style="text-align:left;">
Rating
</td>
<td style="text-align:right;">
2.2017
</td>
<td style="text-align:right;">
0.9523
</td>
<td style="text-align:right;">
2.3120
</td>
<td style="text-align:right;">
0.0213
</td>
</tr>
</tbody>
</table>
<p>Bảng <a href="#tab:tblm09">1.15</a> và <a href="#tab:tblm10">1.17</a> so sánh các hệ số tuyến tính ước lượng được được từ hai mô hình hồi quy riêng biệt. Trước tiên là hồi quy số dư tài khoản thẻ tín dụng theo độ tuổi và hạn mức tín dụng, sau đó là hồi quy số dư tài khoản theo hạn mức tín dụng và điểm tín dụng. Trong mô hình hồi quy đầu tiên, độ tuổi và hạn mức tín dụng đều có ý nghĩa do giá trị <span class="math inline">\(p-value\)</span> rất nhỏ. Trong mô hình thứ hai, hiện tượng đa cộng tuyến giữa hạn mức tín dụng và điểm tín dụng đã khiến độ lệch chuẩn của ước tính hệ số giới hạn tăng lên gấp 13 lần và <span class="math inline">\(p-value\)</span> tăng lên thành 0.701. Nói cách khác, sự quan trọng của biến hạn mức tín dụng đã bị che khuất do hiện tượng đa cộng tuyến. Để tránh rơi vào tình trạng như vậy, cần xác định và giải quyết vấn đề đa cộng tuyến trước khi ước lượng mô hình.</p>
<p>Một cách đơn giản để phát hiện hiện tượng đa cộng tuyến là xem xét ma trận tương quan của các biến giải thích. Một phần tử của ma trận này có giá trị tuyệt đối lớn là dấu hiệu cho thấy một cặp biến có tương quan cao và do đó có hiện tượng đa cộng tuyến trong dữ liệu. Tuy nhiên, bạn đọc cần lưu ý là vấn đề về đa cộng tuyến luôn có thể được phát hiện bằng cách kiểm tra ma trận tương quan bởi vì có thể tồn tại sự cộng tuyến giữa ba hoặc nhiều biến ngay cả khi không có cặp biến nào có tương quan cao. Thay vì kiểm tra ma trận tương quan, cách tốt hơn để đánh giá hiện tượng đa cộng tuyến là tính hệ số lạm phát phương sai (Variance Inflation Factor hay <span class="math inline">\(VIF\)</span>). <span class="math inline">\(VIF\)</span> là tỷ lệ giữa phương sai của hệ số <span class="math inline">\(\hat{\beta}_j\)</span> khi ước lượng mô hình đầy đủ biến và hệ số <span class="math inline">\(\hat{\beta}_j\)</span> khi ước lượng mô hình với riêng biến đó. Một cách đơn giản hơn để tính <span class="math inline">\(VIF\)</span> là sử dụng hệ số <span class="math inline">\(R^2\)</span> trong mô hình hồi quy tuyến tính biến <span class="math inline">\(X_j\)</span> theo các biến giải thích còn lại:
<span class="math display" id="eq:lm112">\[\begin{align}
VIF_j = \cfrac{1}{1 - R^2_{X_j|X_{-j}}}
\tag{1.22}
\end{align}\]</span>
trong đó <span class="math inline">\(R^2_{X_j|X_{-j}}\)</span> là hệ số <span class="math inline">\(R^2\)</span> trong mô hình hồi quy biến <span class="math inline">\(X_j\)</span> theo các biến giải thích còn lại. Nếu không tồn tại đa cộng tuyến, hệ số <span class="math inline">\(R^2_{X_j|X_{-j}}\)</span> sẽ gần bằng 0 và <span class="math inline">\(VIF_j\)</span> sẽ lớn hơn 1 một chút. Ngược lại, nếu biến <span class="math inline">\(X_j\)</span> có thể được xấp xỉ bằng tổ hợp tuyến tính của các biến giải thích còn lại, hệ số <span class="math inline">\(R^2_{X_j|X_{-j}}\)</span> sẽ xấp xỉ 1 và dẫn đến <span class="math inline">\(VIF_j\)</span> có giá trị rất lớn.</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:tblm11">Table 1.19: </span><span id="tab:tblm11">Table 1.20: </span>Hệ số lạm phát phương sai (VIF) của các biến giải thích trong dữ liệu về thẻ tín dụng
</caption>
<thead>
<tr>
<th style="text-align:left;">
Biến giải thích
</th>
<th style="text-align:right;">
Hệ số <span class="math inline">\(R^2\)</span>
</th>
<th style="text-align:right;">
<span class="math inline">\(VIF_j\)</span>
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Độ tuổi
</td>
<td style="text-align:right;">
0.0113
</td>
<td style="text-align:right;">
1.01
</td>
</tr>
<tr>
<td style="text-align:left;">
Hạn mức tín dụng
</td>
<td style="text-align:right;">
0.9938
</td>
<td style="text-align:right;">
161.29
</td>
</tr>
<tr>
<td style="text-align:left;">
Điểm tín dụng
</td>
<td style="text-align:right;">
0.9938
</td>
<td style="text-align:right;">
161.29
</td>
</tr>
</tbody>
</table>
<p>Từ Bảng <a href="#tab:tblm11">1.19</a> được tính toán từ dữ liệu về thẻ tín dụng, có thể thấy rằng các biến giải thích độ tuổi, hạn mức tín dụng, và điểm tín dụng có giá trị <span class="math inline">\(VIF\)</span> lần lượt là <span class="math inline">\(1.01\)</span>, <span class="math inline">\(160.67\)</span> và <span class="math inline">\(160.59\)</span>. Có thể kết luận là có hiện tượng đa cộng tuyến trong dữ liệu thẻ tín dụng! Khi gặp hiện tượng đa cộng tuyến như vậy, có hai giải pháp đơn giản thường được sử dụng. Giải pháp trước tiên là loại bỏ một trong các biến có hệ số VIF cao ra khỏi mô hình hồi quy. Giải pháp này thường được thực hiện mà không ảnh hưởng nhiều đến sự phù hợp của mô hình hồi quy. Trong ví dụ về dữ liệu thẻ tín dụng, chúng ta có thể hồi quy số dư tài khoản theo độ tuổi và hạn mức tín dụng và bỏ qua biến điểm tín dụng mà không làm cho hệ số <span class="math inline">\(R^2\)</span> giảm một cách đáng kể. Giải pháp thứ hai là kết hợp các biến có đa cộng tuyến lại với nhau thành một biến giải thích duy nhất. Chẳng hạn như chúng ta có thể lấy giá trị trung bình biến hạn mức tín dụng và biến điểm tín dụng để tạo ra một biến giải thích mới trong mô hình hồi quy tuyến tính.</p>
<p>Trong phần tiếp theo, chúng tôi sẽ đi sâu vào giải thích phương pháp bình phương nhỏ nhất được sử dụng để ước lượng mô hình hồi quy tuyến tính và tính chất của các ước lượng. Mục tiêu là để bạn đọc hiểu rõ hơn những kết quả đã được sử dụng hoặc công nhận ở phần trên. Những bạn đọc cảm thấy không cần thiết có thể bỏ qua và chuyển sang các phần tiếp theo mà không gặp bất kỳ khó khăn nào khi sử dụng các kết quả của mô hình hồi quy tuyến tính.</p>
</div>
</div>
</div>
<div id="leastsquared" class="section level2 hasAnchor" number="1.2">
<h2><span class="header-section-number">1.2</span> Mô hình hồi quy tuyến tính và phương pháp bình phương nhỏ nhất<a href="#leastsquared" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Mô hình hồi quy tuyến tính, đúng như tên gọi của nó, cho rằng hàm <span class="math inline">\(f\)</span> được sử dụng để mô tả tác động của các biến giải thích <span class="math inline">\(X_1, X_2, \cdot ,X_p\)</span> lên biến mục tiêu <span class="math inline">\(Y\)</span> là có dạng hàm tuyến tính
<span class="math display" id="eq:lm1">\[\begin{align}
f(\textbf{X}) = \beta_0 + \beta_1 \cdot X_1 + \beta_2 \cdot X_2 + \cdots + \beta_p \cdot X_p
\tag{1.24}
\end{align}\]</span>
Các hệ số <span class="math inline">\(\beta_i\)</span> trong phương trình <a href="#eq:lm1">(1.24)</a> được gọi là các tham số của mô hình hồi quy tuyến tính hoặc còn được gọi là các hệ số hồi quy. Các biến <span class="math inline">\(X_i\)</span> có thể được đưa vào mô hình từ những cách như sau:</p>
<ul>
<li><p>Biến <span class="math inline">\(X_i\)</span> là một biến kiểu số.</p></li>
<li><p>Biến <span class="math inline">\(X_i\)</span> là một biến đổi của một biến kiểu số để mối liên hệ giữa <span class="math inline">\(Y\)</span> và <span class="math inline">\(X_i\)</span> trở nên tuyến tính. Các phép biến đổi thường gặp có thể là phép biến đổi <span class="math inline">\(\log\)</span>, phép lấy căn, lấy bình phương, …</p></li>
<li><p>Biến <span class="math inline">\(X_i\)</span> có thể là một đa thức của một biến trong dữ liệu ban đầu. Trong trường hợp này chúng ta thường gọi là mô hình hồi quy đa thức.</p></li>
<li><p>Trong trường hợp <span class="math inline">\(X_i\)</span> là một biến kiểu <span class="math inline">\(factor\)</span> và nhận <span class="math inline">\(J\)</span> giá trị khác nhau. Giả sử <span class="math inline">\(J\)</span> giá trị được mã hóa thành <span class="math inline">\(1, 2, \cdots, J\)</span> thì để mô tả tác động của biến <span class="math inline">\(X_i\)</span> lên biến mục tiêu trong mô hình tuyến tính, chúng ta cần <span class="math inline">\(J\)</span> giá trị hệ số tuyến tính: <span class="math inline">\(\beta_{i,1}\)</span>, <span class="math inline">\(\beta_{i,2}\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(\beta_{i,J}\)</span>; trong đó hệ số tuyến tính <span class="math inline">\(\beta_{i,j}\)</span> mô tả tác động của giá trị <span class="math inline">\(X_i = j\)</span> lên biến mục tiêu.</p></li>
<li><p>Biến giải thích được tính toán từ tác động qua lại giữa các biến giải thích khác, chẳng hạn như <span class="math inline">\(X_i \cdot X_j\)</span>.</p></li>
</ul>
<div id="ước-lượng-các-hệ-số-tuyến-tính" class="section level3 hasAnchor" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Ước lượng các hệ số tuyến tính<a href="#ước-lượng-các-hệ-số-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Dù biến giải thích được tính toán như thế nào, biến mục tiêu <span class="math inline">\(Y\)</span> vẫn là một hàm số tuyến tính của các hệ số <span class="math inline">\((\beta_0, \beta_1, \beta_2,\cdots, \beta_p)\)</span>. Để dễ dàng triển khai các công thức, chúng tôi sẽ sử dụng ký hiệu <span class="math inline">\(\boldsymbol{\beta}\)</span> tương đương như véc-tơ hệ số <span class="math inline">\((\beta_0, \beta_1, \beta_2,\cdots, \beta_p)\)</span>. Phương pháp thông dụng nhất để ước lượng các hệ số của mô hình hồi quy tuyến tính là phương pháp bình phương nhỏ nhất, nghĩa là tham số <span class="math inline">\(\boldsymbol{\beta}\)</span> được tính toán từ bài toán tối ưu
<span class="math display" id="eq:lm2">\[\begin{align}
\hat{\boldsymbol{\beta}} = \underset{\boldsymbol{\beta}}{\operatorname{argmin}} \sum\limits_{i=1}^n \left( y_i - \beta_0 - \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j} \right)^2
\tag{1.25}
\end{align}\]</span></p>
<p>Sai số giữa <span class="math inline">\(y_i\)</span> và <span class="math inline">\(\beta_0 + \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j}\)</span> được gọi là phần dư (hay <span class="math inline">\(residuals\)</span>) trong mô hình hồi quy tuyến tính. Vế bên phải của công thức <a href="#eq:lm2">(1.25)</a> là tổng bình phương của các phần dư và được viết tắt là <span class="math inline">\(RSS\)</span>. Nếu coi tổng bình phương sai số là hàm số của các hệ số hồi quy <span class="math inline">\(\boldsymbol{\beta}\)</span> và viết công thức tổng bình phương sai số dưới dạng ma trận ta sẽ có
<span class="math display" id="eq:lm200">\[\begin{align}
RSS(\boldsymbol{\beta}) = (\textbf{y} - \textbf{x} \boldsymbol{\beta})^T \ (\textbf{y} - \textbf{x} \boldsymbol{\beta})
\tag{1.26}
\end{align}\]</span>
với <span class="math inline">\(\text{x}\)</span> là dữ liệu huấn luyện mô hình có kích thước <span class="math inline">\(n \times (p+1)\)</span>; <span class="math inline">\(\textbf{y}\)</span> là véc-tơ biến mục tiêu có kích thước <span class="math inline">\(n \times 1\)</span>; và véc-tơ tham số <span class="math inline">\(\boldsymbol{\beta}\)</span> có kích thước <span class="math inline">\((p+1) \times 1\)</span>. Véc-tơ gradient của <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> là véc-tơ có độ dài <span class="math inline">\((p+1)\)</span> mà phần tử thứ <span class="math inline">\((j+1)\)</span> là giá trị đạo hàm của RSS theo <span class="math inline">\(\beta_j; j = 0, 1, \cdots, p\)</span>; và được xác định như sau
<span class="math display" id="eq:lm201">\[\begin{align}
\cfrac{\nabla RSS(\boldsymbol{\beta})}{\nabla \boldsymbol{\beta}} &amp;= \cfrac{\nabla (\textbf{y} - \textbf{x} \boldsymbol{\beta})^T (\textbf{y} - \textbf{x} \boldsymbol{\beta}) }  {\nabla \boldsymbol{\beta}} \\
&amp; = - 2 \textbf{x}^T \  (\textbf{y} - \textbf{x} \boldsymbol{\beta})
\tag{1.27}
\end{align}\]</span></p>
<p>Ma trận Hessian là ma trận kích thước <span class="math inline">\(((p+1) \times (p+1))\)</span> mà phần tử hàng <span class="math inline">\(i+1\)</span> cột <span class="math inline">\(j+1\)</span> là đạo hàm cấp hai của <span class="math inline">\(RSS\)</span> lần lượt theo <span class="math inline">\(\beta_i\)</span> rồi theo <span class="math inline">\(\beta_j\)</span>
<span class="math display" id="eq:lm202">\[\begin{align}
\cfrac{\nabla RSS(\boldsymbol{\beta})}{\nabla \boldsymbol{\beta} \ \nabla \boldsymbol{\beta}^T} = 2 \textbf{x}^T \ \textbf{x}
\tag{1.28}
\end{align}\]</span></p>
<p>Giả sử rằng ma trận biến giải thích không có cột nào là tổ hợp tuyến tính của các cột còn lại, hay nói cách khác, hạng của ma trận <span class="math inline">\(\textbf{x}\)</span> là <span class="math inline">\((p+1)\)</span>. Khi đó ta có <span class="math inline">\((\textbf{x}^T \ \textbf{x})\)</span> là ma trận xác định dương. Giá trị <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> làm tối thiểu hóa <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> là nghiệm của
<span class="math display" id="eq:lm203">\[\begin{align}
\cfrac{\nabla RSS(\boldsymbol{\beta})}{\nabla \boldsymbol{\beta}} = \textbf{0}
\tag{1.29}
\end{align}\]</span>
nghĩa là <span class="math inline">\(\hat{\beta}\)</span> được tính toán như sau
<span class="math display" id="eq:lm3">\[\begin{align}
\textbf{x}^T \  (\textbf{y} - \textbf{x} \hat{\boldsymbol{\beta}}) = \textbf{0} \\
\rightarrow \textbf{x}^T \ \textbf{y} = \textbf{x}^T \ \textbf{x} \hat{\boldsymbol{\beta}} \\
\rightarrow \hat{\boldsymbol{\beta}} = (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \ \textbf{y}
\tag{1.30}
\end{align}\]</span></p>
<p>Với ma trận dữ liệu <span class="math inline">\(\textbf{x}\)</span>, giá trị dự báo <span class="math inline">\(\hat{\textbf{y}}\)</span> được tính toán từ công thức dưới đây
<span class="math display" id="eq:lm30">\[\begin{align}
\hat{\textbf{y}} = \textbf{x} \ (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \ \textbf{y}
\tag{1.31}
\end{align}\]</span></p>
<p>Điều gì xảy ra nếu hạng của ma trận <span class="math inline">\(\textbf{x}\)</span> nhỏ hơn <span class="math inline">\((p+1)\)</span>, nghĩa là một (hoặc một vài cột dữ liệu) là tổ hợp tuyến tính của các cột dữ liệu khác, hoặc trong trường hợp ma trận <span class="math inline">\(\textbf{x}\)</span> có số hàng ít hơn số cột. Khi đó ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> sẽ không khả nghịch và phương trình tuyến tính <a href="#eq:lm203">(1.29)</a> sẽ có vô số nghiệm <span class="math inline">\(\boldsymbol{\beta}\)</span>. Đa số các hàm có sẵn khi xây dựng và ước lượng mô hình tuyến tính đều tính toán đến vấn đề này, mỗi khi thêm một biến vào trong mô hình, luôn có bước kiểm tra nếu biến được thêm vào có phải là tổ hợp tuyển tính (hoặc xấp xỉ bằng tổ hợp tuyến tính) của các biến sẵn có để loại bỏ biến đó khỏi mô hình.</p>
<p>Để có thể đưa ra các suy diễn về véc-tơ hệ số, chúng ta cần có giả thiết về phân phối của biến phụ thuộc <span class="math inline">\(Y\)</span>. Mô hình hồi quy tuyến tính có giả thiết quan trọng là biến mục tiêu <span class="math inline">\(Y\)</span> có phân phối chuẩn. Nói một cách khác, biến ngẫu nhiên <span class="math inline">\(Y|X = x_i\)</span>, được viết tắt là <span class="math inline">\(Y_i\)</span>, là các biến ngẫu nhiên phân phối chuẩn độc lập có giá trị trung bình <span class="math inline">\(\textbf{x}_i^T \boldsymbol{\beta}\)</span> và phương sai cố định là <span class="math inline">\(\sigma^2\)</span> (không phụ thuộc vào <span class="math inline">\(i\)</span>). Mô hình hồi quy tuyến tính được viết như sau
<span class="math display" id="eq:lm31">\[\begin{align}
&amp; Y_i = \beta_0 + \beta_1 \cdot x_{i,1} + \beta_2 \cdot x_{i,2} + \cdots + \beta_p \cdot x_{i,p} + \epsilon_i \\
&amp; \epsilon_i \sim \mathcal{N}(0, \sigma^2) \\
&amp; Cov(\epsilon_i, \epsilon_j) = 0 \ \ \forall i \neq j
\tag{1.32}
\end{align}\]</span></p>
<p>Hoặc chúng ta có thể viết mô hình hồi quy tuyến tính dưới dạng ma trận
<span class="math display" id="eq:lm310">\[\begin{align}
Y \sim \mathcal{N}(\textbf{x} \boldsymbol{\beta}, \sigma^2 \ \textbf{I}_n)
\tag{1.33}
\end{align}\]</span>
trong đó <span class="math inline">\(\textbf{I}_n\)</span> là ma trận đơn vị kích thước <span class="math inline">\(n \times n\)</span>. Với giả thiết phân phối chuẩn của <span class="math inline">\(Y\)</span> trong phương trình <a href="#eq:lm310">(1.33)</a> và kết hợp với <a href="#eq:lm3">(1.30)</a> chúng ta thấy rằng <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> là một phép biến đổi tuyến tính của một véc-tơ phân phối chuẩn nên cũng là một véc-tơ phân phối chuẩn. Véc-tơ trung bình của <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> được xác định như sau
<span class="math display" id="eq:lm4">\[\begin{align}
\mathbb{E}(\hat{\boldsymbol{\beta}}) &amp;= \mathbb{E}\left((\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \ \textbf{y}\right) \\
&amp; = (\textbf{x}^T \ \textbf{x} )^{-1} (\textbf{x}^T \textbf{x}) \ \boldsymbol{\beta} \\
&amp; = \boldsymbol{\beta}
\tag{1.34}
\end{align}\]</span>
Ma trận hiệp phương sai của véc-tơ <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span>
<span class="math display" id="eq:lm40">\[\begin{align}
\mathbb{V}ar(\hat{\boldsymbol{\beta}}) &amp;= \mathbb{V}ar\left((\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \ \textbf{y}\right) \\
&amp;= \sigma^2 \ (\textbf{x}^T \ \textbf{x} )^{-1}
\tag{1.35}
\end{align}\]</span></p>
<p>Có thể thấy rằng véc-tơ trung bình của <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> hoàn toàn phụ thuộc vào dữ liệu trong khi ma trận hiệu phương sai lại phụ thuộc vào một tham số không biết là <span class="math inline">\(\sigma\)</span>. Để xây dựng được các khoảng tin cậy hoặc kiểm định được các hệ số có khác không hay không, chúng ta cần ước lượng tham số <span class="math inline">\(\sigma^2\)</span>.</p>
</div>
<div id="ước-lượng-phương-sai-của-biến-phụ-thuộc." class="section level3 hasAnchor" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Ước lượng phương sai của biến phụ thuộc.<a href="#ước-lượng-phương-sai-của-biến-phụ-thuộc." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Tham số thứ hai của mô hình hồi quy tuyến tính là phương sai của biến phụ thuộc, ký hiệu <span class="math inline">\(\sigma^2\)</span>, được ước lượng như sau
<span class="math display" id="eq:lm40">\[\begin{align}
\hat{\sigma}^2 = RSS(\hat{\boldsymbol{\beta}}) = \cfrac{\sum \hat{\epsilon}_i^2}{n - (p+1)} = \cfrac{\hat{\boldsymbol{\epsilon}}^{T} \ \hat{\boldsymbol{\epsilon}}}{n - (p+1)}
\tag{1.35}
\end{align}\]</span>
với <span class="math inline">\(\hat{\epsilon}_i = y_i - \hat{y}_i\)</span>.</p>
<p>Với giả thiết phân phối chuẩn của các <span class="math inline">\(\epsilon_i\)</span> như <a href="#eq:lm31">(1.32)</a>, <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> được ước lượng từ phương trình <a href="#eq:lm3">(1.30)</a>, và <span class="math inline">\(\hat{y}\)</span> được tính toán từ <a href="#eq:lm30">(1.31)</a>, ta có thể chứng minh được rằng <span class="math inline">\(\cfrac{\sum \hat{\epsilon}_i^2}{\sigma^2}\)</span> là một biến ngẫu nhiên phân phối <span class="math inline">\(\chi^2\)</span> với bậc tự do là <span class="math inline">\(n-(p+1)\)</span>. Thật vậy, ta có
<span class="math display">\[\begin{align}
\hat{\boldsymbol{\epsilon}} &amp;= \textbf{y} - \hat{\textbf{y}} = y - \textbf{x} \hat{\beta} \\
&amp; = \textbf{y} - \textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \ \textbf{y} \\
&amp; = Q \textbf{y}
\end{align}\]</span>
với ma trận <span class="math inline">\(Q = I_n - \textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T\)</span>. Ma trận <span class="math inline">\(Q\)</span> có các tính chất sau:</p>
<ul>
<li><p>Thứ nhất là Q có vết (<span class="math inline">\(Trace\)</span>) bằng <span class="math inline">\(n - (p+1)\)</span>, thật vậy
<span class="math display">\[\begin{align}
Trace(Q) = Trace(\textbf{I}_n) - Trace(\textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T)
\end{align}\]</span>
đồng thời
<span class="math display">\[\begin{align}
Trace(\textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T) &amp;= Trace( \textbf{x}^T \textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} ) \\
&amp; = Trace(I_{p+1}) = (p+1)
\end{align}\]</span>
do đó <span class="math inline">\(Trace(Q) = n - (p+1)\)</span></p></li>
<li><p>Thứ hai, có thể thấy rằng <span class="math inline">\(Q = Q^{&#39;}\)</span> và <span class="math inline">\(Q = Q^2\)</span> do đó các giá trị riêng của Q chỉ có thể nhận giá trị là 0 hoặc 1. Như vậy, nếu gọi <span class="math inline">\(V\)</span> là ma trận có các cột là các véc-tơ riêng của Q thì chúng ta có’
<span class="math display" id="eq:lm5">\[\begin{align}
V Q V^{&#39;} = \Delta = diag(1,1,\cdots,1,0,0,\cdots,0)
\tag{1.36}
\end{align}\]</span>
trong đó <span class="math inline">\(\Delta\)</span> là ma trận đường chéo chỉ chứa 0 và 1 trên đường chéo chính. Kết hợp với kết quả <span class="math inline">\(Trace(Q)\)</span> <span class="math inline">\(=\)</span> <span class="math inline">\(n - (p+1)\)</span> có thể kết luận rằng <span class="math inline">\(Q\)</span> có <span class="math inline">\(n - (p+1)\)</span> giá trị riêng bằng 1 và <span class="math inline">\((p+1)\)</span> giá trị riêng bằng 0.</p></li>
</ul>
<p>Ta có <span class="math inline">\(\boldsymbol{\epsilon} \sim \mathcal{N}(\textbf{0}, \sigma^2 I)\)</span> và <span class="math inline">\(\hat{\boldsymbol{\epsilon}} \sim \mathcal{N}(\textbf{0}, \sigma^2 Q)\)</span>. Từ <a href="#eq:lm5">(1.36)</a> ta có <span class="math inline">\(V \hat{\boldsymbol{\epsilon}} ~ \sim \mathcal{N}(\textbf{0}, \sigma^2 \Delta)\)</span>. Nói cách khác, nếu cho <span class="math inline">\(\textbf{z} = V \hat{\epsilon}\)</span> thì <span class="math inline">\(\textbf{z}\)</span> là véc-tơ phân phối chuẩn với trung bình là <span class="math inline">\(\textbf{0}\)</span> và ma trận hiệp phương sai <span class="math inline">\(\sigma^2 \Delta\)</span>. Ma trận đường chéo <span class="math inline">\(\Delta\)</span> có <span class="math inline">\(n-(p+1)\)</span> phần tử nằm trên đường chéo chính bằng 1 và (p+1) phần tử nằm trên đường chéo chính bằng 0. Nói một cách khác, các phần tử từ vị trí thứ <span class="math inline">\(1\)</span> đến <span class="math inline">\(n-(p+1)\)</span> trong <span class="math inline">\(\textbf{z}\)</span> có phương sai bằng <span class="math inline">\(\sigma^2\)</span> và <span class="math inline">\(p+1\)</span> phần tử còn lại trong <span class="math inline">\(\textbf{z}\)</span> có phương sai bằng 0.</p>
<p>Do <span class="math inline">\(V\)</span> là ma trận các giá trị riêng thỏa mãn <span class="math inline">\(V V&#39; = I_n\)</span> nên
<span class="math display" id="eq:lm50">\[\begin{align}
\hat{\boldsymbol{\epsilon}}^{T} \ \hat{\boldsymbol{\epsilon}} = (V \hat{\boldsymbol{\epsilon}})^T V \hat{\boldsymbol{\epsilon}} = \textbf{z}^T \textbf{z} = z_1^2 + z_2^2 + \cdots + z_{n-(p+1)}^2 \sim \sigma^2 \cdot \chi^2_{n-(p+1)}
\tag{1.37}
\end{align}\]</span></p>
<p>Như vậy, từ phương trình <a href="#eq:lm50">(1.37)</a> chúng ta có
<span class="math display" id="eq:lm501">\[\begin{align}
\left(n-(p+1)\right) \times \hat{\sigma}^2 = \hat{\boldsymbol{\epsilon}}^{T} \ \hat{\boldsymbol{\epsilon}} \sim \sigma^2 \times \chi^2_{n-(p+1)}
\tag{1.38}
\end{align}\]</span></p>
<p><span class="math inline">\(\hat{\sigma}^2\)</span> là ước lượng không chệch của <span class="math inline">\(\sigma^2\)</span> vì
<span class="math display">\[\begin{align}
\mathbb{E}\left(\hat{\sigma}^2\right) &amp; = \cfrac{1}{(n-(p+1))} \mathbb{E}\left(\sigma^2 \cdot \chi^2_{n-(p+1)} \right) \\
&amp; = \sigma^2 \times \cfrac{\mathbb{E}\left(\chi^2_{n-(p+1)} \right)}{(n-(p+1))} \\
&amp; = \sigma^2
\end{align}\]</span>
vì giá trị trung bình của biến ngẫu nhiên <span class="math inline">\(\chi^2_{n-(p+1)}\)</span> là <span class="math inline">\(n-(p+1)\)</span>.Có thể tóm tắt các ước lượng tham số của mô hình hồi quy tuyến tính, bao gồm các hệ số tuyến tính va phương sai của biến mục tiêu, sử dụng phương pháp bình phương nhỏ nhất như sau
<span class="math display" id="eq:lm6">\[\begin{align}
\hat{\boldsymbol{\beta}} &amp; = P \cdot \textbf{y} \\
\hat{\sigma}^2 &amp; = \cfrac{1}{n-(p+1)} \ (Q \cdot \textbf{y})^T (Q \cdot \textbf{y}) \\
P &amp; = (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T \\
Q &amp; = \textbf{I}_n - \textbf{x} \ (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T
\tag{1.39}
\end{align}\]</span></p>
<p>Lưu ý rằng <span class="math inline">\(P \cdot Q^T\)</span> là một ma trận kích thước <span class="math inline">\((p+1) \times n\)</span> có tất cả các phần tử bằng 0, do đó <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> và <span class="math inline">\(\hat{\sigma}^2\)</span> là các biến ngẫu nhiên độc lập.</p>
</div>
<div id="kiểm-định-các-hệ-số-ước-lượng." class="section level3 hasAnchor" number="1.2.3">
<h3><span class="header-section-number">1.2.3</span> Kiểm định các hệ số ước lượng.<a href="#kiểm-định-các-hệ-số-ước-lượng." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Từ các phương trình <a href="#eq:lm4">(1.34)</a>, <a href="#eq:lm40">(1.35)</a>, và <a href="#eq:lm501">(1.38)</a>, chúng ta có phân phối xác suất của các tham số của mô hình hồi quy tuyến tính:
<span class="math display" id="eq:lm60">\[\begin{align}
&amp; \hat{\beta}_j \sim \mathcal{N}(\beta_j, \sigma^2 a_{jj}) \ \ \forall 1 \leq j \leq (p+1) \\
&amp; \hat{\sigma}^2 \sim \cfrac{\sigma^2}{n-(p+1)} \ \chi^2_{n-(p+1)}
\tag{1.40}
\end{align}\]</span>
với <span class="math inline">\(a_{jj}\)</span> là phần tử nằm ở hàng <span class="math inline">\(j\)</span> cột <span class="math inline">\(j\)</span> của ma trận <span class="math inline">\((\textbf{x}^T \ \textbf{x} )^{-1}\)</span>.</p>
<p>Sau khi ước lượng hệ số tuyến tính từ phương trình <a href="#eq:lm6">(1.39)</a>, chúng ta thường quan tâm đến sự kiện <span class="math inline">\(\beta_j \neq 0\)</span> ở một mức độ tin cậy nào đó, nghĩa là biến độc lập <span class="math inline">\(X_j\)</span> có tác động tuyến tính lên biến mục tiêu <span class="math inline">\(Y\)</span> một cách có ý nghĩa. Để trả lời câu hỏi này, chúng ta cần kiểm định giả thuyết <span class="math inline">\(H_0: \beta_j = 0\)</span>. Dưới giả thuyết <span class="math inline">\(H_0\)</span>, <span class="math inline">\(\hat{\beta}_j\)</span> là biến ngẫu nhiên phân phối chuẩn có giá trị trung bình bằng 0, tuy nhiên phương sai của <span class="math inline">\(\hat{\beta}_j\)</span> phụ thuộc vào giá trị không biết là <span class="math inline">\(\sigma^2\)</span>. Cho biến ngẫu nhiên <span class="math inline">\(T_j = \hat{\beta}_j/\left(\sqrt{a_{jj}} \cdot \hat{\sigma}\right)\)</span> thì cùng chia cả tử và mẫu của <span class="math inline">\(T_j\)</span> cho <span class="math inline">\(\sqrt{a_{jj}} \cdot \sigma\)</span> ta có
<span class="math display" id="eq:lm7">\[\begin{align}
T_j = \hat{\beta}_j/(\hat{\sigma} \cdot  \sqrt{a_{jj}})  = \cfrac{\hat{\beta}_j/(\sigma \cdot  \sqrt{a_{jj}})}{\hat{\sigma}/\sigma}
\tag{1.41}
\end{align}\]</span></p>
<p>Dưới giả thuyết <span class="math inline">\(H_0\)</span> ta có
<span class="math display" id="eq:lm70">\[\begin{align}
&amp; \hat{\beta}_j/(\sigma \cdot  \sqrt{a_{jj}}) \sim \mathcal{N}(0,1) \\
&amp; \hat{\sigma}/\sigma \sim \sqrt{\cfrac{\chi^2_{n-(p+1)}}{n-(p+1)}}
\tag{1.42}
\end{align}\]</span>
do đó <span class="math inline">\(T_j\)</span> là biến ngẫu nhiên phân phối Student với bậc tự do <span class="math inline">\(n-(p+1)\)</span>. Lưu ý rằng khi bậc tự do đủ lớn, biến ngẫu nhiên phân phối Student sẽ hội tụ đến phân phối chuẩn với trung bình bằng 0 và phương sai bằng 1. Do đó trong nhiều trường hợp, người xây dựng mô hình sử dụng phân phối <span class="math inline">\(\mathcal{N}(0,1)\)</span> để kiểm định giả thuyết <span class="math inline">\(H_0: \beta_j = 0\)</span>.</p>
<p>Giá trị của <span class="math inline">\(T_j\)</span> tính từ công thức <a href="#eq:lm7">(1.41)</a> là cơ sở để bác bỏ hoặc không bác bỏ giả thuyết <span class="math inline">\(H_0\)</span>. Một cách tự nhiên, nếu giá trị tuyệt đối của <span class="math inline">\(T_j\)</span> lớn, nghĩa là <span class="math inline">\(T_j\)</span> nằm xa giá trị 0, xác suất để bác bỏ giả thuyết <span class="math inline">\(H_0\)</span> là lớn hơn so với khi <span class="math inline">\(T_j\)</span> gần 0. <span class="math inline">\(p-value\)</span> được tính bởi công thức dưới đây
<span class="math display">\[\begin{align}
p-value = 2 \mathbb{P}(T_{n-(p+1)} &gt; |T_j|)
\end{align}\]</span>
Khi <span class="math inline">\(p-value\)</span> nhỏ hơn một mức ý nghĩa <span class="math inline">\(\alpha\)</span> thì có thể kết luận rằng với độ tin cậy <span class="math inline">\((1-\alpha)\)</span>, hệ số <span class="math inline">\(\beta_j\)</span> là khác 0 một cách có ý nghĩa thống kê.</p>
<p>Trong nhiều trường hợp chúng ta cần phải thực hiện kiểm định giả thuyết mà nhiều hệ số tuyến tính đồng thời bằng 0. Chẳng hạn như các hệ số tuyến tính của một nhóm các biến liên tục, hoặc hệ số tuyến tính của 1 biến rời rạc nhận từ ba giá trị trở lên. Giả sử các hệ số cần được kiểm định đồng thời là <span class="math inline">\(\beta_{j_1}, \beta_{j_2}, \cdots, \beta_{j_h}\)</span>, khi đó cặp giả thuyết <span class="math inline">\(H_0\)</span> - <span class="math inline">\(H_1\)</span> sẽ là
<span class="math display">\[\begin{align}
&amp; H_0: \beta_{j_i} = 0 \ \ \forall i = 1,2, \cdots, h \\
&amp; H_1: \text{Tồn tại ít nhất $i$ sao cho} \ \beta_{j_i} \neq 0
\end{align}\]</span></p>
<p>Dưới giả thuyết <span class="math inline">\(H_0\)</span> ta có
<span class="math display" id="eq:lm71">\[\begin{align}
\cfrac{1}{h} \sum\limits_{i = 1}^h T^2_{j_i} &amp; =  \cfrac{ \cfrac{1}{h}  \sum\limits_{i = 1}^h \left( \hat{\beta}_{j_i}/(\sigma \cdot  \sqrt{a_{jj}}) \right)^2}{{\hat{\sigma}^2/\sigma^2}}
= \cfrac{\chi^2_{h}/h}{\chi^2_{n-(p+1)}/(n-(p+1))} \sim \mathcal{F}(h,n-(p+1))
\tag{1.43}
\end{align}\]</span></p>
<p>Trong đó <span class="math inline">\(\mathcal{F}(h,n-(p+1))\)</span> là phân phối <span class="math inline">\(\mathcal{F}\)</span> với các tham số <span class="math inline">\(h\)</span> và <span class="math inline">\(n - (p+1)\)</span>. Một cách tự nhiên, nếu giá trị của <span class="math inline">\(\sum\limits_{i = 1}^h T^2_{j_i}/h\)</span> đủ lớn, chúng ta sẽ bác bỏ giả thuyết <span class="math inline">\(H_0\)</span>, nghĩa là tồn tại ít nhất một <span class="math inline">\(i\)</span> sao cho <span class="math inline">\(\beta_{j_i} \neq 0\)</span>. Nhắc lại rằng chúng tôi đã đề cập đến phân phối <span class="math inline">\(\mathcal{F}\)</span> khi kiểm định mô hình tuyến tính đa biến. Chúng tôi đã sử dụng thống kê <span class="math inline">\(F\)</span> được tính toán bằng công thức <a href="#eq:lm104">(1.14)</a>. Trong trường hợp tổng quát, nếu <span class="math inline">\(RSS_1\)</span> là tổng bình phương sai số của mô hình tuyến tính bao gồm đầy đủ <span class="math inline">\(p+1\)</span> biến giải thích trong khi <span class="math inline">\(RSS_1\)</span> là tổng bình phương sai số của mô hình tuyến tính không bao gồm các biến <span class="math inline">\(X_{j_1}, X_{j_2}, \cdots, X_{j_h}\)</span>, thống kê <span class="math inline">\(F\)</span> được tính toán bằng công thức sau
<span class="math display" id="eq:lm72">\[\begin{align}
F = \cfrac{(RSS_1 - RSS_0)/h}{RSS_0/\left(n-(p+1)\right)}
\tag{1.44}
\end{align}\]</span></p>
<p>Nếu giả thuyết <span class="math inline">\(H_0\)</span> là đúng, nghĩa là các hệ số <span class="math inline">\(\beta_{j_i}\)</span> đều nhận giá trị bằng 0, có thể chứng minh được rằng thống kê <span class="math inline">\(F\)</span> sẽ có phân phối <span class="math inline">\(\mathcal{F}\)</span> với tham số <span class="math inline">\(h\)</span> và <span class="math inline">\(n - (p+1)\)</span>.
xxxxxxxxxxxxxxx</p>
</div>
</div>
<div id="linearmodelselection" class="section level2 hasAnchor" number="1.3">
<h2><span class="header-section-number">1.3</span> Các phương pháp chọn biến trong mô hình hồi quy tuyến tính.<a href="#linearmodelselection" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Có hai lý do khiến những người xây dựng mô hình thường không hài lòng với kết quả từ phương pháp bình phương nhỏ nhất</p>
<ul>
<li><p>Thứ nhất là khả năng dự đoán của mô hình: ước lượng tham số bằng phương pháp bình phương nhỏ nhất thường có bais thấp nhưng variance lớn. Độ chính xác của dự đoán đôi khi có thể được cải thiện bằng các phương pháp như thu nhỏ số lượng biến giải thích hoặc các phương pháp shinkage. Bằng cách tiếp cận như vậy, người xây dựng mô hình chấp nhận tăng bais để giảm variance của các giá trị dự đoán để có thể cải thiện độ chính xác trong dự đoán.</p></li>
<li><p>Lý do thứ hai là khả năng diễn giải của mô hình. Khi số lượng biến giải thích là quá nhiều, chúng ta thường muốn xác định một tập hợp nhỏ hơn những biến có tác động mạnh đáng kể nhất nhằm diễn giải mô hình một cách tốt nhất.</p></li>
</ul>
<p>Trong phần này, trước tiên chúng ta sẽ thảo luận một số cách tiếp cận để lựa chọn biến giải thích để đưa vào trong mô hình hồi quy tuyến tính bao gồm các phương pháp như best subset selection, forward stepwise selection, backward stepwise selection. Trong phần tiếp theo, chúng ta thảo luận về các phương pháp rút gọn (shrinkage) với mục tiêu kiểm soát phương sai của dự đoán.</p>
<p>Nhìn chung, khi lựa chọn biến giải thích đưa vào mô hình, chúng ta chỉ giữ lại một tập hợp con của các biến và loại bỏ phần còn lại khỏi mô hình. Phương pháp bình phương nhỏ nhất được sử dụng để ước tính các hệ số tuyến tính. Các tiêu chí đánh giá mô hình sẽ được đưa ra nhằm so sánh các tập hợp biến khác nhau.</p>
<div id="phương-pháp-lựa-chọn-tập-hợp-con-tốt-nhất" class="section level3 hasAnchor" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Phương pháp lựa chọn tập hợp con tốt nhất<a href="#phương-pháp-lựa-chọn-tập-hợp-con-tốt-nhất" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Đúng như tên gọi, lựa chọn biến bằng phương pháp lựa chọn tập hợp con tốt nhất có nghĩa là với mỗi giá trị của <span class="math inline">\(k \in \{0,1,2,... ,p\}\)</span> người xây dựng mô hình cố gắng tìm tập hợp con có bao gồm đúng <span class="math inline">\(k\)</span> biến giải thích sao cho tổng bình phương phần dư đạt giá trị nhỏ nhất. Điểm bất lợi của phương pháp này là khối lượng tính toán quá lớn bởi vì số lượng mô hình cần ước lượng là <span class="math inline">\(2^p\)</span>. Phương pháp tiếp cận của Furnival và Wilson (1974) giúp cho thuật toán này có thể thực hiện được với <span class="math inline">\(p\)</span> lên đến 40. Tuy nhiên, thời gian tính toán chậm vẫn là điểm bất lợi nhất của phương pháp này.</p>
<div class="figure"><span style="display:block;" id="fig:fglm10"></span>
<img src="bookdown-demo_files/figure-html/fglm10-1.png" alt="Phương pháp lựa chọn tập hợp con tốt nhất được thực hiện trên dữ liệu Boston. Đường ranh giới dưới là các mô hình có tổng bình phương phần dư nhỏ nhất" width="672" />
<p class="caption">
Figure 1.10: Phương pháp lựa chọn tập hợp con tốt nhất được thực hiện trên dữ liệu Boston. Đường ranh giới dưới là các mô hình có tổng bình phương phần dư nhỏ nhất
</p>
</div>
<p>Hình <a href="#fig:fglm10">1.10</a> hiển thị tất cả các mô hình có tập hợp con <span class="math inline">\(k\)</span> biến, <span class="math inline">\(k = 0, 1, \cdots, 13\)</span> cho ví dụ về giá nhà ở Boston. Đường ranh giới dưới biểu thị các mô hình đủ điều kiện để lựa chọn theo cách tiếp cận tập hợp con tốt nhất. Lưu ý rằng tập hợp con tốt nhất có kích thước bằng 2 không nhất thiết bao gồm biến nằm trong tập con tốt nhất có kích thước 1. Đường cong tập hợp con tốt nhất (ranh dưới màu đỏ) luôn giảm theo <span class="math inline">\(k\)</span>, do đó không thể được sử dụng để chọn kích thước tập hợp con tối ưu. Câu hỏi đặt ra là làm thế nào để chọn <span class="math inline">\(k\)</span> để cân bằng giữa sai lệch và phương sai của mô hình tuyến tính, đồng thời không quá tốn nhiều tài nguyên tính toán. Có một số tiêu chí mà chúng ta có thể cân nhắc; trong thực tế chúng tôi thường sử dụng xác thực chéo để ước tính sai số dự đoán và lựa chọn <span class="math inline">\(k\)</span>, hoặc khi khối lượng tính toán cho xác thực chéo quá lớn thì cũng có thể sử dụng tiêu chí AIC là một lựa chọn thay thế.</p>
</div>
<div id="forward--and-backward-stepwise-selection" class="section level3 hasAnchor" number="1.3.2">
<h3><span class="header-section-number">1.3.2</span> Forward- and Backward-Stepwise Selection<a href="#forward--and-backward-stepwise-selection" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Thay vì tìm kiếm qua tất cả các tập hợp con, điều mà này trở nên không khả thi đối với <span class="math inline">\(p\)</span> lớn, chúng ta có thể tìm kiếm tập hợp con một cách tuần tự theo từng bước, mà ở đó, kết quả của bước tiếp theo phụ thuộc vào bước trước đó.</p>
<ul>
<li><p>Forward-stepwise selection bắt đầu bằng cách lựa chọn mô hình có 1 biến tốt nhất. Sau đó, phương pháp này tìm kiểm mô hình có <span class="math inline">\(k\)</span> biến bằng cách lấy <span class="math inline">\((k-1)\)</span> biến đã được lựa chọn ở bước trước đó để thêm vào một biến. Như vậy, tại bước thứ <span class="math inline">\(k\)</span>, sẽ có <span class="math inline">\((p-k+1)\)</span> mô hình tuyến tính cần được ước lượng. Số mô hình cần được ước lượng trong phương pháp forward-stepwise selection là
<span class="math display">\[\begin{align}
p + (p-1) + \cdots + 1 = \cfrac{p(p+1)}{2}
\end{align}\]</span></p></li>
<li><p>Bước thứ nhất của phương pháp Backward-stepwise selection bắt đầu bằng ước lượng mô hình có đầy đủ <span class="math inline">\(p\)</span> biến. Sau đó, tại bước thứ <span class="math inline">\(k\)</span>, mô hình tìm cách loại bỏ đi 1 biến trong <span class="math inline">\((p+2-k)\)</span> biến trong mô hình được ước lượng tại bước thứ <span class="math inline">\((k-1)\)</span>. Như vậy, tại bước thứ <span class="math inline">\(k\)</span> với <span class="math inline">\(k &gt;1\)</span> sẽ có <span class="math inline">\((p+2-k)\)</span> mô hình cần được ước lượng. Tổng số mô hình cần được ước lượng trong phương pháp là
<span class="math display">\[\begin{align}
1 + p + (p-1) + \cdots + 2 = \cfrac{p(p+1)}{2}
\end{align}\]</span></p></li>
</ul>
<p>Hai phương pháp mô tả ở trên có bất lợi so với phương pháp lựa chọn tập hợp con tốt nhất là không chắc chắn tìm thấy được mô hình có <span class="math inline">\(k\)</span> biến tốt nhất do kết quả của các bước phụ thuộc vào các bước trước đó. Tuy nhiên, lợi thế của các phương pháp này có thể kể đến là</p>
<ul>
<li><p>Nguồn lực tính toán: với <span class="math inline">\(p\)</span> lớn thì thời gian tính toán của hai phương pháp kể trên nhanh hơn nhiều so với best subset selection. Các phương pháp có thể được áp dụng cả trong trường hợp <span class="math inline">\(p \geq N\)</span>.</p></li>
<li><p>Về mặt ý nghĩa thống kê: phương pháp lựa chọn tập hợp con tốt nhất tìm kiếm mô hình có <span class="math inline">\(k\)</span> biến tốt nhất trong tất cả các lựa chọn có thể, do đó kết quả thường thu được mô hình có phương sai cao hơn. Ngược lại, các phương pháp forward và backward stepwise selection chỉ tìm kiếm mô hình <span class="math inline">\(k\)</span> biến trong một không gian nhỏ hơn (phụ thuộc vào các biến đã được lựa chọn trong các bước trước đó) nên thường có phương sai nhỏ hơn.</p></li>
</ul>
<p>Hình vẽ <a href="#fig:fglm11">1.11</a> mô tả các mô hình có <span class="math inline">\(k\)</span> biến tốt nhất với <span class="math inline">\(k = 0, 1, \cdots, 13\)</span> sử dụng phương pháp forward stepwise selection. Trong trường hợp dữ liệu <span class="math inline">\(Boston\)</span>, ba phương pháp lựa chọn biến chúng tôi mô tả ở trên cho cùng một kết quả.</p>
<div class="figure"><span style="display:block;" id="fig:fglm11"></span>
<img src="bookdown-demo_files/figure-html/fglm11-1.png" alt="Phương pháp forward stepwise selection được thực hiện trên dữ liệu Boston. Đường ranh giới dưới là các mô hình có sai số trung bình nhỏ nhất." width="672" />
<p class="caption">
Figure 1.11: Phương pháp forward stepwise selection được thực hiện trên dữ liệu Boston. Đường ranh giới dưới là các mô hình có sai số trung bình nhỏ nhất.
</p>
</div>
</div>
</div>
<div id="hồi-quy-tuyến-tính-có-ràng-buộc-tham-số" class="section level2 hasAnchor" number="1.4">
<h2><span class="header-section-number">1.4</span> Hồi quy tuyến tính có ràng buộc tham số<a href="#hồi-quy-tuyến-tính-có-ràng-buộc-tham-số" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Bằng cách tìm kiếm một tập hợp con các biến giải thích, các phương pháp lựa chọn biến trình bày ở phần trên có thể giúp bạn đọc tìm ra các mô hình có khả năng giải thích tốt và có khả năng có sai lệch thấp hơn so với mô hình gồm đầy đủ tất cả các biến. Hạn chế của các mô hình này ở chỗ, do mỗi biến giải thích chỉ có một trong hai khả năng là có xuất hiện hoặc không xuất hiện, nên các mô hình kết quả vẫn sẽ có phương sai lớn. Các phương pháp ràng buộc tham số được trình bày trong phần này là các phương pháp thường được sử dụng để cải thiện các mô hình có phương sai lớn với mục đích giảm phương sai của các mô hình và chấp nhận (đánh đổi) khả năng sai lệch có thể tăng.</p>
<div id="hồi-quy-ridge" class="section level3 hasAnchor" number="1.4.1">
<h3><span class="header-section-number">1.4.1</span> Hồi quy ridge<a href="#hồi-quy-ridge" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Hồi quy ridge hạn chế ảnh hưởng của biến giải thích lên biến mục tiêu bằng cách thêm vào một hàm “phạt” nếu giá trị tuyệt đối của hệ số tuyến tính tăng lên. Thay vì tìm các hệ số <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> để tối thiểu hóa <span class="math inline">\(RSS(\beta)\)</span>, hồi quy ridge tìm các hệ số <span class="math inline">\(\hat{\boldsymbol{\beta}}^{ridge}\)</span> để tối thiểu hóa tổng của <span class="math inline">\(RSS(\beta)\)</span> với một hàm phạt
<span class="math display" id="eq:ridge1">\[\begin{align}
\hat{\boldsymbol{\beta}}^{ridge} = \underset{\boldsymbol{\beta}}{\operatorname{argmin}} \sum\limits_{i=1}^n \left( y_i - \beta_0 - \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j} \right)^2 + \lambda \cdot \sum\limits_{j=1}^p \beta_j^2
\tag{1.45}
\end{align}\]</span></p>
<p>Hồi quy ridge sử dụng hàm phạt là <span class="math inline">\(PF(\boldsymbol{\beta}) = \sum\limits_{j=1}^p \beta_j^2\)</span>. Lưu ý rằng hệ số chặn <span class="math inline">\(\beta_0\)</span> không có trong hàm phạt bởi vì hệ số này không bị tác động bởi các biến giải thích. Hệ số <span class="math inline">\(\lambda \geq 0\)</span> điều khiển mức độ ảnh hưởng của hàm phạt lên giá trị tối ưu. Khi <span class="math inline">\(\lambda\)</span> nhỏ thì ảnh hưởng của hàm phạt lên giá trị tối ưu không đáng kể và nếu <span class="math inline">\(\lambda\)</span> lớn thì hàm phạt sẽ chiếm ưu thế trong bài toán tối ưu và làm cho tất cả các hệ số <span class="math inline">\(\hat{\boldsymbol{\beta}}^{ridge}\)</span> gần tới 0.</p>
<p>Bài toán tối ưu trong phương trình <a href="#eq:ridge1">(1.45)</a> có thể phát biểu dưới dạng bài toán có ràng buộc như sau:
<span class="math display" id="eq:ridge2">\[\begin{align}
&amp; \hat{\boldsymbol{\beta}}^{ridge} = \underset{\boldsymbol{\beta}}{\operatorname{argmin}} \sum\limits_{i=1}^n \left( y_i - \beta_0 - \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j} \right)^2, \\
&amp; \text{ với ràng buộc: }  \sum\limits_{j=1}^p \beta_j^2 \leq c
\tag{1.46}
\end{align}\]</span></p>
<p>Trong trường hợp mô hình tuyến tính có các biến độc lập có tương quan cao với nhau ước lượng của các hệ số tuyến tính có độ biến động lớn khiến mô hình tuyến tính kém hiệu quả. Bằng cách sử dụng ràng buộc trên cho tổng bình phương các hệ số, hồi quy ridge kiểm soát được vấn đề các biến giải thích tương quan cao. Ngoài ra, khi thực hiện hồi quy ridge các hệ số tuyến tính sẽ phụ thuộc vào việc có hay không thực hiện biến đổi tuyến tính các biến giải thích, do đó trước khi thực hiện hồi quy người xây dựng mô hình thường chuẩn hóa các biến giải thích. Sau khi các biến giải thích được chuẩn hóa, ước lượng cho hệ số chặn là giá trị trung bình của biến mục tiêu, và phương pháp bình phương nhỏ nhất được thực hiện để ước lượng <span class="math inline">\(\beta_1, \beta_2, \cdots, \beta_p\)</span>.</p>
<p>Tổng bình phương sai số dưới trong hồi quy ridge được viết như sau
<span class="math display">\[\begin{align}
RSS(\boldsymbol{\beta}) = (\textbf{y} - \textbf{x} \boldsymbol{\beta})^T \ (\textbf{y} - \textbf{x} \boldsymbol{\beta}) + \lambda \boldsymbol{\beta}^T \boldsymbol{\beta})
\end{align}\]</span></p>
<p>Lưu ý rằng ma trận biến giải thích <span class="math inline">\(\textbf{x}\)</span> sau khi chuẩn hóa có kích thước <span class="math inline">\(n \times p\)</span>. Tương tự như mô hình tuyến tính, hệ số hồi quy được ước lượng bằng phương pháp bình phương nhỏ nhất
<span class="math display">\[\begin{align}
\hat{\boldsymbol{\beta}}^{ridge} = (\textbf{x}^T \ \textbf{x} + \lambda I_{p} )^{-1} \textbf{x}^T \ \textbf{y}
\end{align}\]</span>
với <span class="math inline">\(I_p\)</span> là ma trận đơn vị có kích thước <span class="math inline">\(p \times p\)</span>. Như vậy, tương tự như hồi quy tuyến tính thông thường, véc-tơ hệ số <span class="math inline">\(\hat{\boldsymbol{\beta}}^{ridge}\)</span> vẫn là tổ hợp tuyến tính của véc-tơ biến mục tiêu <span class="math inline">\(\textbf{y}\)</span>. Sự khác nhau của các hệ số đến ở chỗ hồi quy ridge thêm vào đường chéo chính của ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> giá trị <span class="math inline">\(\lambda\)</span> trước khi lấy nghịch đảo.</p>
<p>Trong trường hợp các biến giải thích đôi một độc lập, có thể chứng minh được rằng
<span class="math display">\[\begin{align}
\hat{\boldsymbol{\beta}} = \cfrac{\hat{\boldsymbol{\beta}}^{ridge}}{1 + \lambda}
\end{align}\]</span>
trong đó <span class="math inline">\(\hat{\boldsymbol{\beta}}\)</span> là ước lượng của các hệ số tuyến tính khi không sử dụng hàm phạt. Khi <span class="math inline">\(\lambda\)</span> đủ lớn sẽ làm cho các giá trị hệ số tuyến tính giảm dần về 0. Điều đó có nghĩa là khi <span class="math inline">\(\lambda\)</span> càng lớn, bậc tự do của mô hình càng nhỏ. Trong mô hình tuyến tính thông thường, bậc tự do của mô hình có thể hiểu một cách đơn giản là số lượng tham số và bằng <span class="math inline">\((p+1)\)</span>. Với <span class="math inline">\(\lambda &gt; 0\)</span>, vẫn có <span class="math inline">\((p+1)\)</span> hệ số tuyến tính trong hồi quy ridge được ước lượng, tuy nhiên các hệ số bị ràng buộc với nhau làm cho bậc tự do của mô hình giảm. Điều này cũng đồng nghĩa với việc mô hình ít bị phụ thuộc vào dữ liệu hơn (phương sai giảm) nhưng đánh đổi lại là sai lệch sẽ tăng.</p>
<p>Khái niệm bậc tự do trong các mô hình có ràng buộc về tham số thường được gọi là bậc tự do hiệu quả thay vì bậc tự do thông thường. Bậc tự do hiệu quả được định nghĩa bằng tổng độ nhạy (đạo hàm) của các giá trị dự báo <span class="math inline">\(\hat{y}_i = \hat{f}(x_i)\)</span> theo các giá trị quan sát của biến mục tiêu
<span class="math display" id="eq:ridge3">\[\begin{align}
\textit{Bậc tự do hiệu quả} = \sum\limits_{i=1}^n \cfrac{\partial \hat{y}_i }{\partial y_i}
\tag{1.47}
\end{align}\]</span></p>
<p>Bậc tự do hiệu quả lớn có nghĩa là giá trị dự đoán <span class="math inline">\(\hat{y}_i\)</span> sẽ thay đổi lớn khi các giá trị quan sát <span class="math inline">\(y_i\)</span> thay đổi, ngược lại, bậc tự do hiệu quả nhỏ có nghĩa là các giá trị dự đoán <span class="math inline">\(\hat{y}_i\)</span> sẽ thay đổi nhỏ khi các giá trị quan sát được <span class="math inline">\(y_i\)</span> thay đổi. Tương tự như khái niệm bậc tự do trong mô hình tuyến tính thông thường, mô hình có bậc tự do hiệu quả lớn nghĩa là mô hình có phương sai lớn.</p>
<p>Trong hồi quy tuyến tính thông thường hoặc hồi quy tuyến tính ridge, giá trị dự báo của mô hình có dạng
<span class="math display">\[\begin{align}
\hat{\textbf{y}} = A \textbf{y}
\end{align}\]</span>
với <span class="math inline">\(A = \textbf{x} (\textbf{x}^T \ \textbf{x} )^{-1} \textbf{x}^T\)</span> trong mô hình tuyến tính thông thường, và <span class="math inline">\(A = \textbf{x} (\textbf{x}^T \ \textbf{x} + \lambda I_{p} )^{-1} \textbf{x}^T\)</span> trong hồi quy tuyến tính ridge.</p>
<p>Bậc tự do hiệu quả của các mô hình trên chính là vết (trace) của ma trận <span class="math inline">\(A\)</span>
<span class="math display" id="eq:ridge4">\[\begin{align}
\sum\limits_{i=1}^n \cfrac{\partial \hat{y}_i }{\partial y_i} = Trace(A) = \sum\limits_{i=1}^n A_{i,i}
\tag{1.48}
\end{align}\]</span>
trong đó <span class="math inline">\(A_{i,i}\)</span> là các phần tử thứ <span class="math inline">\(i\)</span> nằm trên đường chéo chính của ma trận <span class="math inline">\(A\)</span>. Trong ước lượng mô hình tuyến tính thông thường ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> có hạng bằng <span class="math inline">\((p+1)\)</span>, chúng ta đã có <span class="math inline">\(trace(A) = (p+1)\)</span>, nghĩa là bậc tự do hiệu quả của mô hình tuyến tính thông thường bằng số tham số trong mô hình.</p>
<p>Để trả lời câu hỏi bậc tự do hiệu quả của hồi quy ridge phụ thuộc vào <span class="math inline">\(\lambda\)</span> như thế nào, chúng ta giả sử ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> có hạng bằng <span class="math inline">\(p\)</span>. Khi đó, ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> có thể được viêt dưới dạng sau
<span class="math display">\[\begin{align}
\textbf{x}^T \ \textbf{x} = U D U^{T}
\end{align}\]</span>
với <span class="math inline">\(U\)</span> là ma trận các véc-tơ riêng chuẩn hóa của <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> và <span class="math inline">\(D\)</span> là ma trận đường chéo có các phần tử nằm trên đường chéo chính là các giá trị riêng của ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span>.
<span class="math display">\[\begin{align}
D = Diag(\lambda_1, \lambda_2, \cdots, \lambda_p)
\end{align}\]</span>
với <span class="math inline">\(\lambda_i\)</span> là các giá trị riêng của ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span>. Lưu ý rằng ma trận <span class="math inline">\(U\)</span> là ma trận unitary. Hơn thế nữa, ma trận <span class="math inline">\(\textbf{x}^T \ \textbf{x}\)</span> xác định dương nên tất cả các giá trị riêng <span class="math inline">\(\lambda_i\)</span> đều là các số dương. Chúng ta có bậc tự do hiệu quả của hồi quy ridge được xác định như sau:
<span class="math display" id="eq:ridge40">\[\begin{align}
Trace\left(\textbf{x} (\textbf{x}^T \ \textbf{x} + \lambda \textbf{I}_p )^{-1}\right) &amp; = Trace(\textbf{x}^T \textbf{x} (\textbf{x}^T \ \textbf{x} + \lambda \textbf{I}_p )^{-1}) \\
&amp; = Trace\left[ Diag \left( \cfrac{\lambda_1}{\lambda_1 + \lambda}, \cfrac{\lambda_2}{\lambda_2 + \lambda}, \cdots, \cfrac{\lambda_{p}}{\lambda_{p} + \lambda} \right) \right] \\
&amp; = \sum\limits_{i = 1}^{p} \cfrac{\lambda_i}{\lambda_i + \lambda}
\tag{1.49}
\end{align}\]</span></p>
<p>Có thể thấy rằng bậc tự do hiệu quả của hồi quy ridge là hàm số giảm theo <span class="math inline">\(\lambda\)</span>. Trong mô hình tuyến tính với <span class="math inline">\(p\)</span> biến giải thích và không có hệ số chặn, bậc tự do là <span class="math inline">\(p\)</span>. Khi sử dụng ràng buộc trên các hệ số tuyến tính, kể cả khi các hệ số khác 0 một cách có ý nghĩa, các hệ số vẫn bị ràng buộc bởi <span class="math inline">\(\lambda\)</span>. Bậc tự do hiệu quả nhận giá trị bằng <span class="math inline">\(p\)</span> khi <span class="math inline">\(\lambda = 0\)</span>, tương đương với bài toán tối ưu không có ràng buộc, trong khi bậc tự do hiệu quả sẽ xấp xỉ 0 nếu chúng ta chọn <span class="math inline">\(\lambda\)</span> đủ lớn.</p>
<div class="figure"><span style="display:block;" id="fig:fglm111"></span>
<img src="bookdown-demo_files/figure-html/fglm111-1.png" alt="Hồi quy ridge tương đương với bài toán tìm RSS nhỏ nhất với ràng buộc các hệ số tuyến tính." width="672" />
<p class="caption">
Figure 1.12: Hồi quy ridge tương đương với bài toán tìm RSS nhỏ nhất với ràng buộc các hệ số tuyến tính.
</p>
</div>
<p>Hình <a href="#fig:fglm111">1.12</a> mô tả quá trình ước lượng tham số của hồi quy ridge trên một dữ liệu được mô phỏng. Dữ liệu có 500 quan sát và các hệ số <span class="math inline">\(\beta_1\)</span> và <span class="math inline">\(\beta_2\)</span> được lựa chọn để sinh dữ liệu là <span class="math inline">\(\beta_1 = 2\)</span> và <span class="math inline">\(\beta_2 = -1\)</span>. Bạn đọc có thể thấy rằng lời giải của bài toán tối ưu không có ràng buộc là điểm xấp xỉ <span class="math inline">\((2,-1)\)</span>. Giá trị <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> tương ứng với điểm tối ưu này là 80. Khi chúng ta thêm ràng buộc với hệ số <span class="math inline">\(\beta_1\)</span> và <span class="math inline">\(\beta_2\)</span> như phương trình <a href="#eq:ridge2">(1.46)</a> với <span class="math inline">\(c = 1\)</span> thì miền giá trị của các hệ số phải nằm trong hình tròn có tâm tại (0,0) và bán kính bằng 1 giống như trong hình vẽ. Để thỏa mãn được ràng buộc này, chúng ta phải chấp nhận giá trị của <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> tăng lên. Tại mỗi giá trị của <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> lớn hơn giá trị tối thiểu là 80, tập hợp các điểm (<span class="math inline">\(\beta_1\)</span>, <span class="math inline">\(\beta_2\)</span>) sao cho giá trị của <span class="math inline">\(RSS\)</span> không thay đổi là một hình ellipse do khai triển công thức của RSS sẽ thu được phương trình của một ellipse trên các biến (<span class="math inline">\(\beta_1\)</span>, <span class="math inline">\(\beta_2\)</span>). Hình <a href="#fig:fglm111">1.12</a> mô tả ba ellipse đồng tâm, có độ lớn tăng dần tương ứng với giá trị của RSS là 100, 230 và 480. Tại giá trị 480, ellipse tiếp xúc với hình tròn mô tả miền ràng buộc tham số tại điểm chính là lời giải của bài toán tối ưu có ràng buộc hay chính là giá trị ước lượng tham số của hồi quy ridge. Bạn đọc có thể thấy rằng hồi quy ridge luôn luôn đẩy các hệ số tuyến tính về gần 0 hơn và làm cho mô hình ít bị phụ thuộc hơn vào các tham số tuyến tính.</p>
</div>
<div id="phương-pháp-lasso" class="section level3 hasAnchor" number="1.4.2">
<h3><span class="header-section-number">1.4.2</span> Phương pháp Lasso<a href="#phương-pháp-lasso" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Lasso cũng là một phương pháp để tạo ràng buộc cho các hệ số của mô hình hồi quy tuyến tính. Lasso sử dụng hàm phạt dưới dạng tổng giá trị tuyệt đối của các hệ số thay vì tổng bình phương các hệ số tuyến tính. Lasso có thể được phát biểu dưới dạng bài toán tối ưu với ràng buộc như sau
<span class="math display" id="eq:lasso1">\[\begin{align}
&amp; \hat{\boldsymbol{\beta}}^{ridge} = \underset{\boldsymbol{\beta}}{\operatorname{argmin}} \sum\limits_{i=1}^n \left( y_i - \beta_0 - \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j} \right)^2, \\
&amp; \text{ với ràng buộc: }  \sum\limits_{j=1}^p |\beta_j| \leq c
\tag{1.50}
\end{align}\]</span></p>
<p>Tương tự như hồi quy ridge, các biến độc lập cũng sẽ được chuẩn hóa để có giá trị trung bình bằng 0. Khi đó, ước lượng cho <span class="math inline">\(\beta_0\)</span> là giá trị trung bình của biến phụ thuộc. Ước lượng tham số cho Lasso là quá trình tìm hệ số tuyến tính <span class="math inline">\(\hat{\boldsymbol{\beta}}^{Lasso}\)</span> để tối thiểu hóa tổng bình phương sai số cộng thêm một hàm phạt</p>
<p><span class="math display" id="eq:lasso2">\[\begin{align}
\hat{\boldsymbol{\beta}}^{Lasso} = \underset{\boldsymbol{\beta}}{\operatorname{argmin}} \sum\limits_{i=1}^n \left( y_i - \beta_0 - \sum\limits_{j = 1}^p \beta_j \cdot x_{i,j} \right)^2 + \lambda \cdot \sum\limits_{j=1}^p |\beta_j|
\tag{1.51}
\end{align}\]</span></p>
<p>Không giống như hồi quy ridge, sử dụng hàm phạt là tổng giá trị tuyệt đối của các hệ số sẽ dẫn đến bài toán tìm <span class="math inline">\(\hat{\boldsymbol{\beta}}^{Lasso}\)</span> không có lời giải chính xác. Các phương pháp giải số thường được áp dụng để ước lượng tham số. Khi hằng số <span class="math inline">\(c\)</span> trong ràng buộc của bài toán tối ưu <a href="#eq:lasso1">(1.50)</a> xấp xỉ 0, các hệ số tuyến tính cũng sẽ xấp xỉ 0. Ngược lại khi <span class="math inline">\(c\)</span> đủ lớn, lời giải của bài toán tối ưu sẽ là hệ số của mô hình tuyến tính thông thường.</p>
<div class="figure"><span style="display:block;" id="fig:fglm112"></span>
<img src="bookdown-demo_files/figure-html/fglm112-1.png" alt="Hồi quy ridge tương đương với bài toán tìm RSS nhỏ nhất với ràng buộc các hệ số tuyến tính." width="672" />
<p class="caption">
Figure 1.13: Hồi quy ridge tương đương với bài toán tìm RSS nhỏ nhất với ràng buộc các hệ số tuyến tính.
</p>
</div>
<p>Hình <a href="#fig:fglm112">1.13</a> mô tả quá trình ước lượng tham số của hồi quy lasso trên một dữ liệu mô phỏng mà chúng tôi đã sử dụng trong mô tả hồi quy ridge. Các hệ số <span class="math inline">\(\beta_1\)</span> và <span class="math inline">\(\beta_2\)</span> được lựa chọn để sinh dữ liệu là <span class="math inline">\(\beta_1 = 2\)</span> và <span class="math inline">\(\beta_2 = -1\)</span> và lời giải của bài toán tối ưu không có ràng buộc là điểm xấp xỉ <span class="math inline">\((2,-1)\)</span>. Giá trị <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> tương ứng với điểm tối ưu này là 80. Khi chúng ta thêm ràng buộc với hệ số <span class="math inline">\(\beta_1\)</span> và <span class="math inline">\(\beta_2\)</span> như phương trình <a href="#eq:lasso1">(1.50)</a> với <span class="math inline">\(c = 1\)</span> thì miền giá trị của các hệ số phải nằm trong hình kim cương 4 cạnh được mô tả như trong hình vẽ. Cũng giống như trong hồi quy ridge, để thỏa mãn được ràng buộc chúng ta phải chấp nhận giá trị của <span class="math inline">\(RSS(\boldsymbol{\beta})\)</span> tăng lên. Hình <a href="#fig:fglm111">1.12</a> mô tả ba ellipse đồng tâm, có độ lớn tăng dần tương ứng với giá trị của RSS là 100, 240 và 550. Tại giá trị 550, ellipse tiếp xúc với miền ràng buộc tham số tại một điểm và điểm đó chính là lời giải của phương pháp lasso. Tương tự như hồi quy ridge, phương pháp lasso luôn kéo các hệ số tuyến tính về gần 0 và làm cho mô hình ít bị phụ thuộc hơn vào các tham số tuyến tính. Do đặc điểm của miền ràng buộc, phương pháp lasso nhiều khi còn hiệu quả hơn hồi quy ridge trong ràng buộc tham số bởi vì điểm tiếp xúc của ellipse với hình kim cương sẽ luôn khiến cho một trong hai hệ số nhận giá trị gần 0 hơn.</p>
</div>
</div>
<div id="thực-hành-xây-dựng-mô-hình-tuyến-tính-trên-dữ-liệu-boston" class="section level2 hasAnchor" number="1.5">
<h2><span class="header-section-number">1.5</span> Thực hành xây dựng mô hình tuyến tính trên dữ liệu Boston<a href="#thực-hành-xây-dựng-mô-hình-tuyến-tính-trên-dữ-liệu-boston" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Chúng ta sẽ thực hành xây dựng mô hình tuyến tính trên dữ liệu là dữ liệu về giá nhà tại các vùng ngoại ô của thành phố Boston. Biến mục tiêu có tên là <span class="math inline">\(medv\)</span> là giá trị trung vị của giá nhà tại mỗi vùng. Có 13 biến giải thích bao gồm 12 biến giải thích là các biến liên tục và một biến giải thích định tính duy nhất là <code>chas</code> nhận hai giá trị là 1 nếu vùng ngoại ô nằm trên đường bờ sông và nhận giá trị bằng 0 nếu vùng đó không nằm trên đường bờ sông. Dữ liệu có 506 quan sát.</p>
<p>Về nguyên tắc, dữ liệu trước khi sử dụng để xây dựng mô hình cần được làm sạch, xử lý giá trị không quan sát được, loại bỏ các giá trị ngoại lai, loại bỏ các biến không cần thiết,… Tuy nhiên, để không lặp lại các kiến thức đã trình bày trong các chương trước, chúng tôi sẽ bỏ qua phần này và trực tiếp đi vào phần xây dựng mô hình.</p>
<p>Một lưu ý khác là đa số các hàm số dùng để xây dựng mô hình trên dữ liệu đều đã được phát triển dưới dạng các hàm số có sẵn trên R. Người xây dựng mô hình chỉ cần gọi đúng tên hàm số, khai báo chính xác tham số, và đọc được kết quả trả ra mà không cần phải hiểu chính xác cách viết các hàm số đó như thế nào. Đây là ưu điểm lớn nhất đồng thời cũng là nhược điểm lớn nhất khi sử dụng R để xây dựng mô hình. Là ưu điểm vì bạn đọc chỉ cần một dòng lệnh là đã có thể xây dựng được mô hình phức tạp trên dữ liệu mà không cần hiểu một cách chính xác về mô hình đó. Là nhược điểm bởi vì khi người xây dựng mô hình không hiểu rõ về bản chất có thể dẫn tới sử dụng mô hình không đúng mục đích và dẫn đến các nhận định sai lầm. Để hạn chế được nhược điểm này, trong một số trường hợp, chúng tôi sẽ yêu cầu bạn đọc tự viết các câu lệnh tính toán tham số trước khi gọi các hàm có sẵn.</p>
<div id="xây-dựng-mô-hình-hồi-quy-đa-biến" class="section level3 hasAnchor" number="1.5.1">
<h3><span class="header-section-number">1.5.1</span> Xây dựng mô hình hồi quy đa biến<a href="#xây-dựng-mô-hình-hồi-quy-đa-biến" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Trước hết chúng ta sẽ xây dựng mô hình tuyến tính đơn biến mà giá nhà phụ thuộc vào một biến có tên là <code>lstat</code>. Các hệ số tuyến tính trong mô hình hồi quy đơn <span class="math inline">\(Y \sim \beta_0 + \beta_1 \cdot X\)</span> được ước lượng bằng phương pháp bình phương nhỏ nhất được tính toán như sau:
<span class="math display">\[\begin{align}
\hat{\beta}_1 = \cfrac{cov(X,Y)}{var(X)} \ \ \ ; \ \ \ \hat{\beta}_0 = \bar{Y} - \hat{\beta}_1 \cdot \bar{X}
\end{align}\]</span></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> Boston</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>y <span class="ot">&lt;-</span> Boston<span class="sc">$</span>medv</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>x <span class="ot">&lt;-</span> Boston<span class="sc">$</span>lstat</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>beta1 <span class="ot">&lt;-</span> <span class="fu">cov</span>(x,y)<span class="sc">/</span><span class="fu">var</span>(x); beta0 <span class="ot">&lt;-</span> <span class="fu">mean</span>(y) <span class="sc">-</span> beta1 <span class="sc">*</span> <span class="fu">mean</span>(x)</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">c</span>(beta0,beta1))</span></code></pre></div>
<pre><code>## [1] 34.5538409 -0.9500494</code></pre>
<p>Như vậy, chúng ta có mô hình tuyến tính đơn biến mà <code>medv</code> phụ thuộc vào <code>lstat</code>
<span class="math display">\[\begin{align}
\hat{medv} = 34.5538409 - 0.9500494 \times lstat
\end{align}\]</span></p>
<p>Kết quả mô hình cho thấy khi <code>lstat</code> tăng thêm 1 (%) thì giá nhà trung bình sẽ giảm đi khoảng 0.950 (nghìn USD). Sai số (phần dư) của mô hình là hiệu số giữa giá trị của biến <code>medv</code> được ước lượng từ mô hình và giá trị của <code>medv</code> trong dữ liệu. Chúng ta có đồ thị phần dư như sau</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>phandu <span class="ot">&lt;-</span> (y <span class="sc">-</span>  beta0 <span class="sc">-</span> beta1 <span class="sc">*</span> x)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(phandu), <span class="at">phandu =</span> phandu)<span class="sc">%&gt;%</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(x,phandu))<span class="sc">+</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">color =</span> <span class="st">&quot;blue&quot;</span>,<span class="at">alpha =</span> <span class="fl">0.3</span>)<span class="sc">+</span></span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="dv">0</span>, <span class="at">col =</span> <span class="st">&quot;orange&quot;</span>)<span class="sc">+</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()<span class="sc">+</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;Số quan sát&quot;</span>)<span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">&quot;Phần dư&quot;</span>)</span></code></pre></div>
<p><img src="bookdown-demo_files/figure-html/lmthuchanh2-1.png" width="672" /></p>
<p>Nhìn vào đồ thị phần dư, bạn đọc có thể dễ dàng nhận thấy rằng giả thiết phân phối chuẩn của phần dư và giả thiết các phần dư không tương quan với nhau là không đúng. Điều này có thể cải thiện bằng cách thêm các biến giải thích khác vào mô hình. Bỏ qua vấn đề này, chúng ta ước lượng được phương sai (RSE) của phần dư như sau
<span class="math display">\[\begin{align}
\hat{\sigma} = RSE = \sqrt{\cfrac{RSS}{n-2}}
\end{align}\]</span>
trong đó RSS là tổng sai số bình phương và <span class="math inline">\(n\)</span> là số quan sát</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>RSS <span class="ot">&lt;-</span> <span class="fu">sum</span>(phandu<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>RSE <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(RSS<span class="sc">/</span>(<span class="fu">nrow</span>(Boston)<span class="sc">-</span><span class="dv">2</span>))</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;RSE =&quot;</span>, RSE))</span></code></pre></div>
<pre><code>## [1] &quot;RSE = 6.21576040539807&quot;</code></pre>
<p>Hệ số <span class="math inline">\(R^2\)</span> của mô hình được tính toán như sau</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>TSS <span class="ot">&lt;-</span> <span class="fu">sum</span>((y <span class="sc">-</span> <span class="fu">mean</span>(y))<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>R_squared <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> RSS<span class="sc">/</span>TSS</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;Hệ số R-squared: &quot;</span>, R_squared))</span></code></pre></div>
<pre><code>## [1] &quot;Hệ số R-squared:  0.54414629758648&quot;</code></pre>
<p>Phương sai của các hệ số <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\beta_1\)</span>, các giá trị của phân phối <span class="math inline">\(student\)</span>, và p-value được tính toán như sau</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>n<span class="ot">&lt;-</span><span class="fu">nrow</span>(Boston)</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>SE_beta0 <span class="ot">&lt;-</span> RSE <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="dv">1</span><span class="sc">/</span>n<span class="sc">+</span> <span class="fu">mean</span>(x)<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span><span class="fu">sum</span>(((x<span class="sc">-</span><span class="fu">mean</span>(x))<span class="sc">^</span><span class="dv">2</span>)))</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>SE_beta1 <span class="ot">&lt;-</span> RSE <span class="sc">*</span> <span class="fu">sqrt</span>(<span class="dv">1</span><span class="sc">/</span><span class="fu">sum</span>(((x<span class="sc">-</span><span class="fu">mean</span>(x))<span class="sc">^</span><span class="dv">2</span>)))</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>t_beta0 <span class="ot">&lt;-</span> beta0<span class="sc">/</span>SE_beta0</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>t_beta1 <span class="ot">&lt;-</span> beta1<span class="sc">/</span>SE_beta1</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>p_value_beta0 <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span><span class="sc">-</span><span class="fu">pt</span>(<span class="fu">abs</span>(t_beta0), <span class="at">df =</span> n<span class="dv">-2</span>))</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>p_value_beta1 <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span><span class="sc">-</span><span class="fu">pt</span>(<span class="fu">abs</span>(t_beta1), <span class="at">df =</span> n<span class="dv">-2</span>))</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;Các giá trị phân phối student: &quot;</span>, t_beta0, <span class="st">&quot; - &quot;</span>, t_beta1))</span></code></pre></div>
<pre><code>## [1] &quot;Các giá trị phân phối student:  61.4151455186417  -  -24.5278998511877&quot;</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">&quot;Các giá trị p-value: &quot;</span>, p_value_beta0, <span class="st">&quot; - &quot;</span>,p_value_beta1))</span></code></pre></div>
<pre><code>## [1] &quot;Các giá trị p-value:  0  -  0&quot;</code></pre>
<p>Có thể thấy rằng các giá trị p-value đều nhỏ, cho thấy các hệ số tuyến tính đều khác không một cách có ý nghĩa.</p>
<p>Tất cả các tính toán ở trên đều có thể được thực hiện thông qua hàm có sẵn là hàm <code>lm()</code>. Cách sử dụng hàm <code>lm()</code> xây dựng mô hình tuyến tính mà biến <code>medv</code> phụ thuộc vào biến <code>lstat</code> như sau</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>lm1<span class="ot">&lt;-</span><span class="fu">lm</span>(medv<span class="sc">~</span>lstat, <span class="at">data =</span> Boston)</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="fu">summary</span>(lm1)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = medv ~ lstat, data = Boston)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -15.168  -3.990  -1.318   2.034  24.500 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***
## lstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 6.216 on 504 degrees of freedom
## Multiple R-squared:  0.5441, Adjusted R-squared:  0.5432 
## F-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Bạn đọc có thể kiểm tra các tính toán ở trên so với kết quả ước lượng từ hàm <code>lm()</code> là hoàn toàn tương tự nhau. Đối tượng <code>lm1</code> là một list có 12 phần tử trong đó có các phần tử như <code>coefficient</code> chứa giá trị các hệ số ước lượng hay <code>residuals</code> là véc-tơ phần dư.</p>
<p>Mô hình tuyến tính đa biến cũng có thể được ước lượng bằng hàm <code>lm()</code> giống như mô hình đơn biến. Chúng ta xây dựng mô hình tuyến tính đa biến mà trong đó biến <code>medv</code> phụ thuộc vào tất cả các biến còn lại như sau</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>Boston<span class="sc">$</span>chas<span class="ot">&lt;-</span><span class="fu">as.factor</span>(Boston<span class="sc">$</span>chas)</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>lm.all<span class="ot">&lt;-</span><span class="fu">lm</span>(medv<span class="sc">~</span>., <span class="at">data =</span> Boston)</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="fu">summary</span>(lm.all)</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = medv ~ ., data = Boston)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -15.595  -2.730  -0.518   1.777  26.199 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  3.646e+01  5.103e+00   7.144 3.28e-12 ***
## crim        -1.080e-01  3.286e-02  -3.287 0.001087 ** 
## zn           4.642e-02  1.373e-02   3.382 0.000778 ***
## indus        2.056e-02  6.150e-02   0.334 0.738288    
## chas1        2.687e+00  8.616e-01   3.118 0.001925 ** 
## nox         -1.777e+01  3.820e+00  -4.651 4.25e-06 ***
## rm           3.810e+00  4.179e-01   9.116  &lt; 2e-16 ***
## age          6.922e-04  1.321e-02   0.052 0.958229    
## dis         -1.476e+00  1.995e-01  -7.398 6.01e-13 ***
## rad          3.060e-01  6.635e-02   4.613 5.07e-06 ***
## tax         -1.233e-02  3.760e-03  -3.280 0.001112 ** 
## ptratio     -9.527e-01  1.308e-01  -7.283 1.31e-12 ***
## black        9.312e-03  2.686e-03   3.467 0.000573 ***
## lstat       -5.248e-01  5.072e-02 -10.347  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 4.745 on 492 degrees of freedom
## Multiple R-squared:  0.7406, Adjusted R-squared:  0.7338 
## F-statistic: 108.1 on 13 and 492 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Có thể nhận thấy rằng hầu hết các biến trong mô hình đều có ý nghĩa ngoại trừ hai biến là <code>indus</code> và <code>age</code>.</p>
</div>
<div id="lựa-chọn-biến-trong-mô-hình-hồi-quy-tuyến-tính" class="section level3 hasAnchor" number="1.5.2">
<h3><span class="header-section-number">1.5.2</span> Lựa chọn biến trong mô hình hồi quy tuyến tính<a href="#lựa-chọn-biến-trong-mô-hình-hồi-quy-tuyến-tính" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Chúng ta sẽ sử dụng sai số xác thực chéo làm tiêu chí để lựa chọn biến trong mô hình hồi quy tuyến tính. Hàm số dùng để tạo chỉ số trong xác thực chéo là hàm <code>createFolds()</code> của thư viện <span class="math inline">\(\textbf{caret}\)</span>. Dữ liệu sẽ được chia ngẫu nhiên thành <span class="math inline">\(k = 5\)</span> phần theo biến mục tiêu để đảm bảo phân phối của biến mục tiêu trong từng tập xác thực tương tự nhau.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="co"># Chia dữ liệu ngẫu nhiên thành 5 phần theo biến medv</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">10</span>)</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>fold_number <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>index <span class="ot">&lt;-</span> <span class="fu">createFolds</span>(Boston<span class="sc">$</span>medv, <span class="at">k =</span> fold_number)</span></code></pre></div>
<p>Để tính sai số xác thực chéo, với mỗi <span class="math inline">\(i \in \{1, 2, 3, 4, 5\}\)</span> chúng ta xây dựng mô hình trên dữ liệu Boston loại trừ đi các quan sát thuộc tập xác thực <span class="math inline">\(i\)</span>. Sau đó tính toán sai số của mô hình trên tập xác thực thứ <span class="math inline">\(i\)</span>. Sai số trong bài toán hồi quy được tính bằng RMSE. Sai số xác thực chéo là giá trị trung bình của sai số trên các tập xác thực <span class="math inline">\(i\)</span>, <span class="math inline">\(1 \leq i \leq 5\)</span>. Ví dụ, chúng ta xác định sai số của mô hình đơn biến gồm một biến giải thích <code>lstat</code> và mô hình tuyến tính đa biến bao gồm tất cả các biến như sau:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="co"># Sai số giữa hai véc-tơ số tính bằng RMSE</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>RMSE <span class="ot">&lt;-</span> <span class="cf">function</span>(y,y.hat) <span class="fu">sqrt</span>(<span class="fu">mean</span>((y <span class="sc">-</span> y.hat)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a><span class="co"># Hàm số tính sai số xác thực chéo hồi quy tuyến tính</span></span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a>cv.lm<span class="ot">&lt;-</span><span class="cf">function</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, dat, target){</span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a>  <span class="co"># seed: khởi tạo ngẫu nhiên</span></span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a>  <span class="co"># fold_number: số lượng folds</span></span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a>  <span class="co"># dat: dữ liệu xây dựng mô hình (X)</span></span>
<span id="cb39-9"><a href="#cb39-9" tabindex="-1"></a>  <span class="co"># target: biến mục tiêu (Y)</span></span>
<span id="cb39-10"><a href="#cb39-10" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb39-11"><a href="#cb39-11" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(dat) ; p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(dat)</span>
<span id="cb39-12"><a href="#cb39-12" tabindex="-1"></a>  </span>
<span id="cb39-13"><a href="#cb39-13" tabindex="-1"></a>  <span class="co"># Tạo dữ liệu xác thực chéo</span></span>
<span id="cb39-14"><a href="#cb39-14" tabindex="-1"></a>  y <span class="ot">&lt;-</span> target</span>
<span id="cb39-15"><a href="#cb39-15" tabindex="-1"></a>  x <span class="ot">&lt;-</span> dat</span>
<span id="cb39-16"><a href="#cb39-16" tabindex="-1"></a>  index <span class="ot">&lt;-</span> <span class="fu">createFolds</span>(y, <span class="at">k =</span> fold_number)</span>
<span id="cb39-17"><a href="#cb39-17" tabindex="-1"></a>  </span>
<span id="cb39-18"><a href="#cb39-18" tabindex="-1"></a>  <span class="co"># Véc-tơ sai số xác thực chéo</span></span>
<span id="cb39-19"><a href="#cb39-19" tabindex="-1"></a>  error_reg <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, fold_number) </span>
<span id="cb39-20"><a href="#cb39-20" tabindex="-1"></a>  </span>
<span id="cb39-21"><a href="#cb39-21" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>fold_number){</span>
<span id="cb39-22"><a href="#cb39-22" tabindex="-1"></a>    test.index <span class="ot">&lt;-</span> index[[i]] <span class="co"># chỉ số tập xác thực</span></span>
<span id="cb39-23"><a href="#cb39-23" tabindex="-1"></a>    test.index <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">:</span>n) <span class="sc">%in%</span> test.index</span>
<span id="cb39-24"><a href="#cb39-24" tabindex="-1"></a>    </span>
<span id="cb39-25"><a href="#cb39-25" tabindex="-1"></a>    <span class="co"># Dữ liệu huấn luyện</span></span>
<span id="cb39-26"><a href="#cb39-26" tabindex="-1"></a>    x.train <span class="ot">&lt;-</span> x <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span>test.index)</span>
<span id="cb39-27"><a href="#cb39-27" tabindex="-1"></a>    y.train <span class="ot">&lt;-</span> y[<span class="sc">!</span>test.index]</span>
<span id="cb39-28"><a href="#cb39-28" tabindex="-1"></a>    </span>
<span id="cb39-29"><a href="#cb39-29" tabindex="-1"></a>    <span class="co"># Dữ liệu xác thực</span></span>
<span id="cb39-30"><a href="#cb39-30" tabindex="-1"></a>    x.test <span class="ot">&lt;-</span> x <span class="sc">%&gt;%</span> <span class="fu">filter</span>(test.index)</span>
<span id="cb39-31"><a href="#cb39-31" tabindex="-1"></a>    y.test <span class="ot">&lt;-</span> y[test.index]</span>
<span id="cb39-32"><a href="#cb39-32" tabindex="-1"></a>    </span>
<span id="cb39-33"><a href="#cb39-33" tabindex="-1"></a>    <span class="co"># Mô hình tuyến tính</span></span>
<span id="cb39-34"><a href="#cb39-34" tabindex="-1"></a>    lm.model <span class="ot">&lt;-</span> <span class="fu">lm</span>(y.train<span class="sc">~</span>., <span class="at">data =</span> x.train) <span class="co"># ước lượng</span></span>
<span id="cb39-35"><a href="#cb39-35" tabindex="-1"></a>    lm.pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(lm.model, x.test) <span class="co"># dự đoán</span></span>
<span id="cb39-36"><a href="#cb39-36" tabindex="-1"></a>    error_reg[i] <span class="ot">&lt;-</span> <span class="fu">RMSE</span>(y.test,lm.pred)                </span>
<span id="cb39-37"><a href="#cb39-37" tabindex="-1"></a>  }</span>
<span id="cb39-38"><a href="#cb39-38" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(error_reg))</span>
<span id="cb39-39"><a href="#cb39-39" tabindex="-1"></a>}</span>
<span id="cb39-40"><a href="#cb39-40" tabindex="-1"></a></span>
<span id="cb39-41"><a href="#cb39-41" tabindex="-1"></a><span class="co"># Sai số xác thực chéo hồi quy đơn</span></span>
<span id="cb39-42"><a href="#cb39-42" tabindex="-1"></a>mydat <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">select</span>(Boston, lstat)</span>
<span id="cb39-43"><a href="#cb39-43" tabindex="-1"></a>y <span class="ot">&lt;-</span> Boston<span class="sc">$</span>medv</span>
<span id="cb39-44"><a href="#cb39-44" tabindex="-1"></a><span class="fu">cv.lm</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, <span class="at">dat =</span> mydat, <span class="at">target =</span> y)</span></code></pre></div>
<pre><code>## [1] 6.200729</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="co"># Sai số xác thực chéo hồi quy bội</span></span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>mydat <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">select</span>(Boston, <span class="sc">-</span>medv) <span class="co"># X</span></span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a><span class="fu">cv.lm</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, <span class="at">dat =</span> mydat, <span class="at">target =</span> y)</span></code></pre></div>
<pre><code>## [1] 4.857492</code></pre>
<p>Dữ liệu Boston bao gồm 13 biến độc lập do đó thực hiện lựa chọn biến bằng phương pháp best subset selection là có thể thực hiện được. Nguyên tắc lựa chọn mô hình là dựa trên sai số xác thực chéo, mô hình có sai số xác thực chéo nhỏ nhất sẽ được lựa chọn. Có <span class="math inline">\((2^{13} - 1)\)</span> mô hình cần được xây dựng và tính toán.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Boston)<span class="sc">-</span><span class="dv">1</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>number_model <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">^</span>p <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>var_name <span class="ot">&lt;-</span> <span class="fu">select</span>(Boston, <span class="sc">-</span> medv) <span class="sc">%&gt;%</span> <span class="fu">names</span>() </span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>cv.error <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, number_model)</span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">1</span>){</span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a><span class="co">#for (i in 1:number_model){</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a>  <span class="co"># Véc-tơ chứa tên các biến được lựa chọn</span></span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a>  selected_variable <span class="ot">&lt;-</span> var_name[<span class="fu">as.logical</span>(<span class="fu">intToBits</span>(i))[<span class="dv">1</span><span class="sc">:</span>p]]</span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a>  y <span class="ot">&lt;-</span> Boston<span class="sc">$</span>medv</span>
<span id="cb43-11"><a href="#cb43-11" tabindex="-1"></a>  mydat <span class="ot">&lt;-</span> <span class="fu">select</span>(Boston, selected_variable)</span>
<span id="cb43-12"><a href="#cb43-12" tabindex="-1"></a>  cv.error[i] <span class="ot">&lt;-</span> <span class="fu">cv.lm</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, <span class="at">dat =</span> mydat, <span class="at">target =</span> y)</span>
<span id="cb43-13"><a href="#cb43-13" tabindex="-1"></a>}</span>
<span id="cb43-14"><a href="#cb43-14" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" tabindex="-1"></a><span class="co"># Mô hình có sai số xác thực chéo nhỏ nhất</span></span>
<span id="cb43-16"><a href="#cb43-16" tabindex="-1"></a>best_model <span class="ot">&lt;-</span> <span class="fu">which.min</span>(cv.error)</span>
<span id="cb43-17"><a href="#cb43-17" tabindex="-1"></a><span class="co"># Danh sách các biến trong mô hình</span></span>
<span id="cb43-18"><a href="#cb43-18" tabindex="-1"></a>var_name[<span class="fu">as.logical</span>(<span class="fu">intToBits</span>(best_model))[<span class="dv">1</span><span class="sc">:</span>p]]</span></code></pre></div>
<pre><code>## [1] &quot;zn&quot;</code></pre>
<p>Như vậy mô hình tuyến tính có sai số xác thực chéo nhỏ nhất là mô hình có 11 biến liệt kê như trên. Lưu ý rằng, do dữ liệu có kích thước không lớn nên kết quả của mô hình sẽ phụ thuộc vào việc chia dữ liệu thành các tập xác thực.</p>
<p>Lựa chọn biến cho mô hình tuyến tính bằng phương pháp forward stepwise selection được thực hiện như sau</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="co"># Thứ tự chạy mô hình từ ít đến nhiều biến</span></span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">FALSE</span>,number_model,p)</span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_model){ </span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a>  M[i,] <span class="ot">&lt;-</span> <span class="fu">as.logical</span>(<span class="fu">intToBits</span>(i))[<span class="dv">1</span><span class="sc">:</span>p]</span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a>}</span>
<span id="cb45-6"><a href="#cb45-6" tabindex="-1"></a>M <span class="ot">&lt;-</span> M[<span class="fu">order</span>(<span class="fu">apply</span>(M,<span class="dv">1</span>,sum)),]</span>
<span id="cb45-7"><a href="#cb45-7" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" tabindex="-1"></a><span class="co"># Kết quả của quá trình forward stepwise được lưu</span></span>
<span id="cb45-9"><a href="#cb45-9" tabindex="-1"></a>fws_result <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Model_number =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>), </span>
<span id="cb45-10"><a href="#cb45-10" tabindex="-1"></a>                        <span class="at">Number_variable =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>), </span>
<span id="cb45-11"><a href="#cb45-11" tabindex="-1"></a>                        <span class="at">CV_error =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb45-12"><a href="#cb45-12" tabindex="-1"></a>current_best_model <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb45-13"><a href="#cb45-13" tabindex="-1"></a>j <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb45-14"><a href="#cb45-14" tabindex="-1"></a><span class="co"># Lựa chọn mô hình</span></span>
<span id="cb45-15"><a href="#cb45-15" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_model){</span>
<span id="cb45-16"><a href="#cb45-16" tabindex="-1"></a>  number_selected_variable <span class="ot">&lt;-</span> <span class="fu">sum</span>(M[i,])</span>
<span id="cb45-17"><a href="#cb45-17" tabindex="-1"></a>  current_select <span class="ot">&lt;-</span> var_name[M[i,]]</span>
<span id="cb45-18"><a href="#cb45-18" tabindex="-1"></a>  </span>
<span id="cb45-19"><a href="#cb45-19" tabindex="-1"></a>  <span class="cf">if</span> ( (i <span class="sc">==</span> <span class="dv">1</span>) <span class="sc">|</span> <span class="fu">all</span>(current_best_model <span class="sc">%in%</span> current_select) ){</span>
<span id="cb45-20"><a href="#cb45-20" tabindex="-1"></a>    j <span class="ot">&lt;-</span> j<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb45-21"><a href="#cb45-21" tabindex="-1"></a>    mydat <span class="ot">&lt;-</span> <span class="fu">select</span>(Boston, current_select)</span>
<span id="cb45-22"><a href="#cb45-22" tabindex="-1"></a>    cv.error <span class="ot">&lt;-</span> <span class="fu">cv.lm</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, <span class="at">dat =</span> mydat, <span class="at">target =</span> y)</span>
<span id="cb45-23"><a href="#cb45-23" tabindex="-1"></a>    fws_result[j,] <span class="ot">&lt;-</span> <span class="fu">c</span>(i, number_selected_variable, cv.error)</span>
<span id="cb45-24"><a href="#cb45-24" tabindex="-1"></a>  }  </span>
<span id="cb45-25"><a href="#cb45-25" tabindex="-1"></a>  </span>
<span id="cb45-26"><a href="#cb45-26" tabindex="-1"></a>  <span class="co"># Lưu lại mô hình có các biến tốt nhất</span></span>
<span id="cb45-27"><a href="#cb45-27" tabindex="-1"></a>  <span class="cf">if</span> (i <span class="sc">&lt;</span> number_model){</span>
<span id="cb45-28"><a href="#cb45-28" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">sum</span>(M[i<span class="sc">+</span><span class="dv">1</span>,])<span class="sc">-</span><span class="fu">sum</span>(M[i,]) <span class="sc">==</span>  <span class="dv">1</span>){</span>
<span id="cb45-29"><a href="#cb45-29" tabindex="-1"></a>      dat <span class="ot">&lt;-</span> <span class="fu">filter</span>(fws_result, Number_variable <span class="sc">==</span> number_selected_variable)</span>
<span id="cb45-30"><a href="#cb45-30" tabindex="-1"></a>      ind_best_model <span class="ot">&lt;-</span> dat<span class="sc">$</span>Model_number[<span class="fu">which.min</span>(dat<span class="sc">$</span>CV_error)]</span>
<span id="cb45-31"><a href="#cb45-31" tabindex="-1"></a>      current_best_model <span class="ot">&lt;-</span> var_name[M[ind_best_model,]]</span>
<span id="cb45-32"><a href="#cb45-32" tabindex="-1"></a>    }</span>
<span id="cb45-33"><a href="#cb45-33" tabindex="-1"></a>  } </span>
<span id="cb45-34"><a href="#cb45-34" tabindex="-1"></a>}</span></code></pre></div>
<p>Bạn đọc có thể dễ dàng nhận thấy rằng thời gian để thực hiện lựa chọn biến bằng phương pháp forward stepwise selection là nhanh hơn rất nhiều so với phương pháp lựa chọn tập hợp con tốt nhất.</p>
<p>Tương tự, chúng ta có thể thực hiện lựa chọn biến bằng phương pháp backward stepwise selection được thực hiện như sau</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="co"># Thứ tự chạy mô hình từ ít đến nhiều biến</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>M <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">FALSE</span>,number_model,p)</span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_model){ </span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a>  M[i,] <span class="ot">&lt;-</span> <span class="fu">as.logical</span>(<span class="fu">intToBits</span>(i))[<span class="dv">1</span><span class="sc">:</span>p]</span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a>}</span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a>M <span class="ot">&lt;-</span> M[<span class="fu">order</span>(<span class="fu">apply</span>(M,<span class="dv">1</span>,sum),<span class="at">decreasing =</span> <span class="cn">TRUE</span>),]</span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a><span class="co"># Kết quả của quá trình forward stepwise được lưu</span></span>
<span id="cb46-9"><a href="#cb46-9" tabindex="-1"></a>bws_result <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Model_number =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>), </span>
<span id="cb46-10"><a href="#cb46-10" tabindex="-1"></a>                         <span class="at">Number_variable =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>), </span>
<span id="cb46-11"><a href="#cb46-11" tabindex="-1"></a>                         <span class="at">CV_error =</span> <span class="fu">rep</span>(<span class="dv">0</span>, p<span class="sc">*</span>(p<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb46-12"><a href="#cb46-12" tabindex="-1"></a>current_best_model <span class="ot">&lt;-</span> var_name</span>
<span id="cb46-13"><a href="#cb46-13" tabindex="-1"></a>j <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb46-14"><a href="#cb46-14" tabindex="-1"></a><span class="co"># Lựa chọn mô hình</span></span>
<span id="cb46-15"><a href="#cb46-15" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>number_model){</span>
<span id="cb46-16"><a href="#cb46-16" tabindex="-1"></a>  number_selected_variable <span class="ot">&lt;-</span> <span class="fu">sum</span>(M[i,])</span>
<span id="cb46-17"><a href="#cb46-17" tabindex="-1"></a>  current_select <span class="ot">&lt;-</span> var_name[M[i,]]</span>
<span id="cb46-18"><a href="#cb46-18" tabindex="-1"></a>  </span>
<span id="cb46-19"><a href="#cb46-19" tabindex="-1"></a>  <span class="cf">if</span> ( (i <span class="sc">==</span> p) <span class="sc">|</span> <span class="fu">all</span>(current_select <span class="sc">%in%</span> current_best_model) ){</span>
<span id="cb46-20"><a href="#cb46-20" tabindex="-1"></a>    j <span class="ot">&lt;-</span> j<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb46-21"><a href="#cb46-21" tabindex="-1"></a>    mydat <span class="ot">&lt;-</span> <span class="fu">select</span>(Boston, current_select)</span>
<span id="cb46-22"><a href="#cb46-22" tabindex="-1"></a>    cv.error <span class="ot">&lt;-</span> <span class="fu">cv.lm</span>(<span class="at">seed =</span> <span class="dv">10</span>, <span class="at">fold_number =</span> <span class="dv">5</span>, <span class="at">dat =</span> mydat, <span class="at">target =</span> y)</span>
<span id="cb46-23"><a href="#cb46-23" tabindex="-1"></a>    bws_result[j,] <span class="ot">&lt;-</span> <span class="fu">c</span>(i, number_selected_variable, cv.error)</span>
<span id="cb46-24"><a href="#cb46-24" tabindex="-1"></a>  }  </span>
<span id="cb46-25"><a href="#cb46-25" tabindex="-1"></a>  </span>
<span id="cb46-26"><a href="#cb46-26" tabindex="-1"></a>  <span class="co"># Lưu lại mô hình có các biến tốt nhất</span></span>
<span id="cb46-27"><a href="#cb46-27" tabindex="-1"></a>  <span class="cf">if</span> (number_selected_variable <span class="sc">&gt;</span> <span class="dv">1</span>){</span>
<span id="cb46-28"><a href="#cb46-28" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">sum</span>(M[i,])<span class="sc">-</span><span class="fu">sum</span>(M[i<span class="sc">+</span><span class="dv">1</span>,]) <span class="sc">==</span>  <span class="dv">1</span>){</span>
<span id="cb46-29"><a href="#cb46-29" tabindex="-1"></a>      dat <span class="ot">&lt;-</span> <span class="fu">filter</span>(bws_result, Number_variable <span class="sc">==</span> number_selected_variable)</span>
<span id="cb46-30"><a href="#cb46-30" tabindex="-1"></a>      ind_best_model <span class="ot">&lt;-</span> dat<span class="sc">$</span>Model_number[<span class="fu">which.min</span>(dat<span class="sc">$</span>CV_error)]</span>
<span id="cb46-31"><a href="#cb46-31" tabindex="-1"></a>      current_best_model <span class="ot">&lt;-</span> var_name[M[ind_best_model,]]</span>
<span id="cb46-32"><a href="#cb46-32" tabindex="-1"></a>    }</span>
<span id="cb46-33"><a href="#cb46-33" tabindex="-1"></a>  } </span>
<span id="cb46-34"><a href="#cb46-34" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="hồi-quy-ridge-và-lasso" class="section level3 hasAnchor" number="1.5.3">
<h3><span class="header-section-number">1.5.3</span> Hồi quy ridge và lasso<a href="#hồi-quy-ridge-và-lasso" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Hồi quy ridge và lasso được thực hiện bằng hàm số <code>glmnet()</code> của thư viện cùng tên . Tham số <span class="math inline">\(\lambda\)</span> của các phương pháp này được tìm kiếm bằng phương pháp xác thực chéo. Hàm số thực hiện tính toán sai số xác thực chéo của hồi quy ridge và lasso là hàm <code>cv.glmnet()</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a><span class="co"># Chuẩn hóa dữ liệu về dạng số</span></span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>y <span class="ot">&lt;-</span> Boston<span class="sc">$</span>medv</span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(medv<span class="sc">~</span>.,Boston)</span>
<span id="cb47-6"><a href="#cb47-6" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" tabindex="-1"></a><span class="co"># Các giá trị lambda</span></span>
<span id="cb47-8"><a href="#cb47-8" tabindex="-1"></a>r.lambda<span class="ot">&lt;-</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="fl">0.3</span>,<span class="at">length=</span><span class="dv">100</span>)</span>
<span id="cb47-9"><a href="#cb47-9" tabindex="-1"></a>l.lambda<span class="ot">&lt;-</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="fl">0.1</span>,<span class="at">length=</span><span class="dv">100</span>)</span>
<span id="cb47-10"><a href="#cb47-10" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">50</span>)</span>
<span id="cb47-11"><a href="#cb47-11" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" tabindex="-1"></a><span class="co"># Xác thực chéo với ridge (tham số alpha = 0)</span></span>
<span id="cb47-13"><a href="#cb47-13" tabindex="-1"></a>cv.ridge <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">0</span>, </span>
<span id="cb47-14"><a href="#cb47-14" tabindex="-1"></a>                  <span class="at">nfolds =</span> <span class="dv">5</span>, <span class="at">lambda=</span>r.lambda)</span>
<span id="cb47-15"><a href="#cb47-15" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" tabindex="-1"></a></span>
<span id="cb47-17"><a href="#cb47-17" tabindex="-1"></a><span class="co"># Xác thực chéo với lasso (tham số alpha = 1)</span></span>
<span id="cb47-18"><a href="#cb47-18" tabindex="-1"></a>cv.lasso <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">1</span>, </span>
<span id="cb47-19"><a href="#cb47-19" tabindex="-1"></a>                  <span class="at">nfolds =</span> <span class="dv">5</span>, <span class="at">lambda=</span>l.lambda)</span></code></pre></div>
<p>Sai số xác thực chéo tính bằng MSE được lưu trong véc-tơ con có tên là <code>$cvm</code>. Chúng ta có sai số xác thực chéo cho mỗi giá trị của <span class="math inline">\(\lambda\)</span> của hồi quy ridge và lasso như hình <a href="#eq:fglmthuchanh01">(<strong>??</strong>)</a></p>
<div class="figure"><span style="display:block;" id="fig:fglmthuchanh01"></span>
<img src="bookdown-demo_files/figure-html/fglmthuchanh01-1.png" alt="Sai số xác thực chéo tương ứng với mỗi giá trị của siêu tham số lambda trong hồi quy ridge và lasso." width="672" />
<p class="caption">
Figure 1.14: Sai số xác thực chéo tương ứng với mỗi giá trị của siêu tham số lambda trong hồi quy ridge và lasso.
</p>
</div>
<p>Có thể thấy rằng trong hồi quy ridge và lasso, tham số <span class="math inline">\(\lambda\)</span> cho sai số xác thực chéo nhỏ nhất lần lượt là 0.14 và 0.027. Sai số xác thực chéo trong hồi quy ridge và lasso không tốt hơn so với mô hình hồi quy tuyến tính bội.</p>
<p>Do các phương pháp ràng buộc tham số sẽ tránh được hiện tượng khớp dữ liệu quá mức, chúng ta có thể tạo thêm các biến giải thích cho biến giá nhà bằng cách nhân chéo các biến giải thích hiện có. Tổng số biến mới được tạo thành là <span class="math inline">\(p\times(p+1)/2\)</span>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">select</span>(Boston, <span class="sc">-</span>medv)</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(dat)</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">sapply</span>(dat,  </span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>             <span class="cf">function</span>(x){</span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>               x <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(x)</span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a>               <span class="fu">return</span> ((x <span class="sc">-</span> <span class="fu">mean</span>(x))<span class="sc">/</span><span class="fu">sd</span>(x))</span>
<span id="cb48-8"><a href="#cb48-8" tabindex="-1"></a>             })</span>
<span id="cb48-9"><a href="#cb48-9" tabindex="-1"></a></span>
<span id="cb48-10"><a href="#cb48-10" tabindex="-1"></a>dat<span class="ot">&lt;-</span><span class="fu">as.data.frame</span>(dat)</span>
<span id="cb48-11"><a href="#cb48-11" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>p){</span>
<span id="cb48-13"><a href="#cb48-13" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> i<span class="sc">:</span>p){</span>
<span id="cb48-14"><a href="#cb48-14" tabindex="-1"></a>    dat <span class="ot">&lt;-</span> <span class="fu">mutate</span>(dat, <span class="at">newcol =</span> dat[,i]<span class="sc">*</span>dat[,j])</span>
<span id="cb48-15"><a href="#cb48-15" tabindex="-1"></a>    <span class="fu">names</span>(dat)[<span class="fu">length</span>(dat)] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;X&quot;</span>,i,<span class="st">&quot;_&quot;</span>,j)</span>
<span id="cb48-16"><a href="#cb48-16" tabindex="-1"></a>  }</span>
<span id="cb48-17"><a href="#cb48-17" tabindex="-1"></a>}</span>
<span id="cb48-18"><a href="#cb48-18" tabindex="-1"></a>dat<span class="ot">&lt;-</span><span class="fu">mutate</span>(dat, <span class="st">&quot;medv&quot;</span> <span class="ot">=</span> Boston<span class="sc">$</span>medv)</span>
<span id="cb48-19"><a href="#cb48-19" tabindex="-1"></a><span class="co"># Chuẩn hóa dữ liệu về dạng số</span></span>
<span id="cb48-20"><a href="#cb48-20" tabindex="-1"></a>y <span class="ot">&lt;-</span> dat<span class="sc">$</span>medv</span>
<span id="cb48-21"><a href="#cb48-21" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(medv<span class="sc">~</span>.,dat)</span>
<span id="cb48-22"><a href="#cb48-22" tabindex="-1"></a></span>
<span id="cb48-23"><a href="#cb48-23" tabindex="-1"></a><span class="co"># Các giá trị lambda</span></span>
<span id="cb48-24"><a href="#cb48-24" tabindex="-1"></a>r.lambda<span class="ot">&lt;-</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="at">length=</span><span class="dv">100</span>)</span>
<span id="cb48-25"><a href="#cb48-25" tabindex="-1"></a>l.lambda<span class="ot">&lt;-</span><span class="fu">seq</span>(<span class="dv">0</span>,<span class="fl">0.2</span>,<span class="at">length=</span><span class="dv">100</span>)</span>
<span id="cb48-26"><a href="#cb48-26" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">50</span>)</span>
<span id="cb48-27"><a href="#cb48-27" tabindex="-1"></a></span>
<span id="cb48-28"><a href="#cb48-28" tabindex="-1"></a><span class="co"># Xác thực chéo với ridge (tham số alpha = 0)</span></span>
<span id="cb48-29"><a href="#cb48-29" tabindex="-1"></a>cv.ridge <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">0</span>, </span>
<span id="cb48-30"><a href="#cb48-30" tabindex="-1"></a>                  <span class="at">nfolds =</span> <span class="dv">5</span>, <span class="at">lambda=</span>r.lambda)</span>
<span id="cb48-31"><a href="#cb48-31" tabindex="-1"></a></span>
<span id="cb48-32"><a href="#cb48-32" tabindex="-1"></a></span>
<span id="cb48-33"><a href="#cb48-33" tabindex="-1"></a><span class="co"># Xác thực chéo với lasso (tham số alpha = 1)</span></span>
<span id="cb48-34"><a href="#cb48-34" tabindex="-1"></a>cv.lasso <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x, y, <span class="at">alpha =</span> <span class="dv">1</span>, </span>
<span id="cb48-35"><a href="#cb48-35" tabindex="-1"></a>                  <span class="at">nfolds =</span> <span class="dv">5</span>, <span class="at">lambda=</span>l.lambda)</span></code></pre></div>
<p>Chúng ta có sai số xác thực chéo cho mỗi giá trị của <span class="math inline">\(\lambda\)</span> của hồi quy ridge và lasso với dữ liệu sau khi biến đổi như hình <a href="#eq:fglmthuchanh02">(<strong>??</strong>)</a></p>
<div class="figure"><span style="display:block;" id="fig:fglmthuchanh02"></span>
<img src="bookdown-demo_files/figure-html/fglmthuchanh02-1.png" alt="Sai số xác thực chéo tương ứng với mỗi giá trị của siêu tham số lambda trong hồi quy ridge và lasso." width="672" />
<p class="caption">
Figure 1.15: Sai số xác thực chéo tương ứng với mỗi giá trị của siêu tham số lambda trong hồi quy ridge và lasso.
</p>
</div>
<p>Có thể thấy rằng việc áp dụng hồi quy ridge và lasso trên dữ liệu có số lượng lớn biến giải thích mới được tạo thành bằng cách nhân chéo các biến hiện có không chỉ tránh được hiện tương mô hình bị khớp quá mức mà còn cải thiện khả năng dự đoán của mô hình. Sai số xác thực chéo đã giảm đáng kể so với mô hình chỉ sử dụng các biến ban đầu.</p>
</div>
</div>
<div id="bài-tập" class="section level2 hasAnchor" number="1.6">
<h2><span class="header-section-number">1.6</span> Bài tập<a href="#bài-tập" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="bài-tập-lý-thuyết" class="section level3 hasAnchor" number="1.6.1">
<h3><span class="header-section-number">1.6.1</span> Bài tập lý thuyết<a href="#bài-tập-lý-thuyết" class="anchor-section" aria-label="Anchor link to header"></a></h3>
</div>
<div id="bài-tập-thực-hành" class="section level3 hasAnchor" number="1.6.2">
<h3><span class="header-section-number">1.6.2</span> Bài tập thực hành<a href="#bài-tập-thực-hành" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<!-- # REFERENCE -->
<!-- ### Source from thesis -->
<!-- **1.** Chen, Chun-houh, Wolfgang Karl Härdle, and Antony Unwin, eds (2007). *Handbook of data visualization.* \ -->
<!-- **2.** Aparicio, Manuela, and Carlos J. Costa. (2015). *Data visualization - Communication design quarterly review.* \ -->
<!-- **3.** Hadley Wickham. (2010). *A Layered Grammar of Graphics.* \ -->
<!-- ### Souce from website -->
<!-- **4.** [https://www.tableau.com/learn/articles/data-visualization](https://www.tableau.com/learn/articles/data-visualization) \ -->
<!-- **5.** [https://www.r-graph-gallery.com/ggplot2-package.html](https://www.r-graph-gallery.com/ggplot2-package.html) \ -->
<!-- **6.** [http://r-statistics.co/ggplot2-Tutorial-With-R.html](http://r-statistics.co/ggplot2-Tutorial-With-R.html) \ -->
<!-- **7.** [https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf](https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf) \ -->
<!-- **8.** [https://www.kaggle.com/](https://www.kaggle.com/) \ -->

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
